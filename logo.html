<!DOCTYPE html>
<html>
<head>
  <title>IFWL Owner — Mega Operations Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    body{
      font-family: Arial, sans-serif;
      margin:0;
      background:
        linear-gradient(rgba(2,6,23,0.72), rgba(2,6,23,0.72)),
        url("./ifwl_bg.webp");
      background-size:cover;
      background-position:center;
      background-attachment:fixed;
      color:#111827;
    }

    header{
      padding:14px 18px;
      background:#111827;
      color:#fff;
    }
    .headerInner{
      max-width:1500px;
      margin:0 auto;
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
    }

    .brand{
      display:flex;
      gap:12px;
      align-items:flex-start;
      min-width:0;
    }
    .brand img{
      width:38px;height:38px;object-fit:contain;margin-top:2px;flex:0 0 auto;
      filter: drop-shadow(0 1px 1px rgba(0,0,0,0.25));
    }
    .brandText{min-width:0;}
    .brandTitle{font-weight:900; font-size:18px;}
    header .small{font-size:12px;opacity:0.85;margin-top:4px;line-height:1.2;word-break:break-word;}
    .welcomeLine{font-size:12px;opacity:0.95;margin-top:6px;line-height:1.25;}

    .wrap{
      padding:14px;
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
      max-width:1500px;
      margin:0 auto;
    }

    .card{
      background:rgba(255,255,255,0.92);
      border:1px solid rgba(229,231,235,0.95);
      border-radius:14px;
      padding:12px;
      box-shadow:0 10px 28px rgba(0,0,0,0.18);
    }

    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .rowBetween{display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
    .title{font-weight:900; font-size:16px; margin:0;}
    .muted{color:#6b7280; font-size:12px;}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, monospace;}

    button{padding:10px 12px; border:1px solid #d1d5db; border-radius:12px; background:#fff; cursor:pointer;}
    button.primary{background:#111827;color:#fff;border-color:#111827;}
    button:disabled{opacity:0.6;cursor:not-allowed;}

    select, input{
      padding:10px; border:1px solid #d1d5db; border-radius:12px;
      box-sizing:border-box; font-size:16px; background:#fff;
    }
    .tinyInput{
      padding:8px 10px;
      font-size:14px;
      border-radius:10px;
    }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:4px 10px; border-radius:999px;
      border:1px solid #e5e7eb; background:#fff;
      font-size:12px; color:#111827; white-space:nowrap;
    }
    .pill strong{font-weight:900;}

    .kpiGrid{
      display:grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap:12px;
      margin-top:10px;
    }
    .kpi{
      background:#fff;
      border:1px solid #e5e7eb;
      border-radius:14px;
      padding:12px;
      box-shadow:0 8px 18px rgba(0,0,0,0.08);
      min-height:92px;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
    }
    .kpi .label{font-size:12px; color:#6b7280; font-weight:800;}
    .kpi .value{font-size:22px; font-weight:900; margin-top:6px;}
    .kpi .sub{font-size:12px; color:#6b7280; margin-top:6px; line-height:1.25;}

    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
      margin-top:12px;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:12px;
    }
    .grid4{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:12px;
    }

    .chartCard{
      background:#fff;
      border:1px solid #e5e7eb;
      border-radius:14px;
      padding:12px;
      box-shadow:0 8px 18px rgba(0,0,0,0.08);
    }
    .chartTitle{font-weight:900; font-size:13px;}
    canvas{width:100% !important; height:310px !important;}

    .tableWrap{
      overflow:auto;
      border:1px solid #e5e7eb;
      border-radius:12px;
      background:#fff;
      margin-top:10px;
    }
    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      min-width:980px;
    }
    th, td{
      padding:10px;
      border-bottom:1px solid #f3f4f6;
      font-size:13px;
      text-align:left;
      vertical-align:top;
    }
    th{
      position:sticky;
      top:0;
      background:#f9fafb;
      z-index:2;
      font-size:12px;
      color:#111827;
      border-bottom:1px solid #e5e7eb;
      white-space:nowrap;
    }
    tr:last-child td{border-bottom:0;}

    details{
      background:#fff;
      border:1px solid #e5e7eb;
      border-radius:14px;
      padding:10px 12px;
      box-shadow:0 8px 18px rgba(0,0,0,0.06);
    }
    summary{
      cursor:pointer;
      font-weight:900;
      list-style:none;
    }
    summary::-webkit-details-marker { display:none; }

    .toast{
      position:fixed; right:16px; bottom:16px;
      background:#111827; color:#fff;
      padding:10px 12px; border-radius:12px;
      opacity:0; transform: translateY(8px);
      transition: all .18s ease;
      z-index:9999;
      max-width: min(520px, calc(100vw - 32px));
      white-space: pre-wrap;
    }
    .toast.show{opacity:1; transform: translateY(0);}

    /* Steward audit (Owner) */
    .auditBox{
      border:1px solid #e5e7eb;
      border-radius:14px;
      padding:12px;
      background:rgba(250,250,250,0.92);
      margin-top:12px;
    }
    .auditTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .auditTitle{
      font-weight:900;
      font-size:14px;
      margin:0;
    }
    .auditMeta{
      margin-top:6px;
      font-size:12px;
      color:#6b7280;
      line-height:1.25;
    }
    .auditTableWrap{
      margin-top:10px;
      overflow:auto;
      border:1px solid #e5e7eb;
      border-radius:12px;
      background:#fff;
    }
    table.auditTable{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      min-width:860px;
    }
    .auditTable th, .auditTable td{
      padding:10px;
      border-bottom:1px solid #f3f4f6;
      font-size:13px;
      text-align:left;
      vertical-align:top;
      white-space:nowrap;
    }
    .auditTable th{
      position:sticky;
      top:0;
      background:#f9fafb;
      z-index:2;
      font-size:12px;
      color:#111827;
      border-bottom:1px solid #e5e7eb;
    }
    .auditTable tr:last-child td{border-bottom:0;}
    .auditTable tr.inactive td{
      background:#fef2f2;
      color:#991b1b;
      font-weight:900;
    }

    @media (max-width: 1300px){
      .kpiGrid{grid-template-columns: repeat(3, minmax(0, 1fr));}
      .grid3{grid-template-columns:1fr;}
      .grid2{grid-template-columns:1fr;}
      .grid4{grid-template-columns:1fr;}
    }
    @media (max-width: 980px){
      body{background-attachment:scroll;}
      .headerInner{flex-direction:column; align-items:stretch;}
      header .row{width:100%;}
      header button{width:100%;}
      .kpiGrid{grid-template-columns: repeat(2, minmax(0, 1fr));}
      canvas{height:280px !important;}
      table{min-width:860px;}
      table.auditTable{min-width:860px;}
    }
  </style>
</head>

<body>
  <header>
    <div class="headerInner">
      <div class="brand">
        <img src="./ifwl_logo.png" alt="IFWL logo">
        <div class="brandText">
          <div class="brandTitle">IFWL Owner — Mega Operations Dashboard</div>
          <div class="welcomeLine" id="welcomeLine">Loading your profile…</div>
          <div class="small" id="who">Loading…</div>
        </div>
      </div>

      <div class="row">
        <button id="backHeadBtn">Back to Head Stewards Dashboard</button>
        <button id="backClassifierBtn">Back to Classifier</button>
        <button id="logoutBtn">Sign out</button>
      </div>
    </div>
  </header>

  <div class="wrap">
    <div class="card">
      <div class="rowBetween">
        <div>
          <div class="title">Owner Snapshot — Everything (tickets, people, throughput, accountability)</div>
          <div class="muted">Big owner view. Pulls directly from Firebase. RT collections are ignored.</div>
        </div>

        <div class="row">
          <span class="pill" id="permPill">Permissions: …</span>

          <label class="muted" style="display:flex;align-items:center;gap:8px;">
            Range:
            <select id="rangeDays">
              <option value="7" selected>Last 7 days</option>
              <option value="14">Last 14 days</option>
              <option value="30">Last 30 days</option>
            </select>
          </label>

          <label class="muted" style="display:flex;align-items:center;gap:8px;">
            Ticket scan:
            <input id="ticketLimit" class="tinyInput" type="number" min="200" max="10000" step="100" value="2000" style="width:110px;">
          </label>

          <label class="muted" style="display:flex;align-items:center;gap:8px;">
            <input type="checkbox" id="deepScan">
            Deep scan (slower)
          </label>

          <button id="refreshBtn" class="primary">Refresh all</button>
        </div>
      </div>

      <!-- System overview -->
      <div class="grid2" style="margin-top:12px;">
        <div class="chartCard">
          <div class="rowBetween">
            <div>
              <div class="chartTitle">System Overview (counts)</div>
              <div class="muted">Quick visibility across collections</div>
            </div>
            <span class="muted" id="sysHint">—</span>
          </div>
          <div class="kpiGrid" id="sysKpis" style="grid-template-columns: repeat(3, minmax(0, 1fr)); margin-top:10px;"></div>

          <details style="margin-top:10px;">
            <summary>Recent ticket searches (ticket_search_logs)</summary>
            <div class="tableWrap" style="margin-top:10px;">
              <table style="min-width:860px;">
                <thead>
                  <tr>
                    <th>When</th>
                    <th>User</th>
                    <th>Query</th>
                    <th>Result count</th>
                  </tr>
                </thead>
                <tbody id="tbodySearchLogs"></tbody>
              </table>
            </div>
          </details>
        </div>

        <!-- Steward audit -->
        <div class="chartCard">
          <div class="auditTop">
            <div>
              <div class="auditTitle">Steward Activity (Last 7 Days) — Accountability Overview</div>
              <div class="muted" style="margin-top:4px;">
                Note: Dave is exempt unless explicitly requested to review deadlock cases.
              </div>
            </div>
            <div class="row">
              <label class="muted" style="display:flex;align-items:center;gap:8px;">
                <input type="checkbox" id="showOnlyInactive">
                Show only inactive
              </label>
              <button id="refreshAuditBtn">Refresh</button>
            </div>
          </div>

          <div class="auditMeta" id="auditMeta">Loading…</div>

          <div class="auditTableWrap" id="auditTableWrap" style="display:none;">
            <table class="auditTable" aria-label="Steward input table">
              <thead>
                <tr>
                  <th>Steward</th>
                  <th>Comments (7d)</th>
                  <th>Reviews (7d)</th>
                  <th>Tickets Touched (7d)</th>
                  <th>Last Active</th>
                  <th>Status</th>
                </tr>
              </thead>
              <tbody id="auditTbody"></tbody>
            </table>
          </div>

          <div class="muted" style="margin-top:8px;">
            Counts include <span class="mono">collectionGroup</span> queries across all tickets. Inactive stewards are highlighted red.
          </div>
        </div>
      </div>

      <!-- KPIs -->
      <div class="kpiGrid" id="kpiGrid"></div>

      <!-- Charts -->
      <div class="grid3">
        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Created vs Resolved (daily)</div>
            <span class="muted" id="createdResolvedHint">—</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartCreatedResolved"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Pipeline breakdown</div>
            <span class="muted" id="pipelineHint">—</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartPipeline"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Status mix (donut)</div>
            <span class="muted" id="statusMixHint">—</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartStatusDonut"></canvas></div>
        </div>
      </div>

      <div class="grid3">
        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Turnaround time distribution (open → resolved)</div>
            <span class="muted" id="tatHint">—</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartTAT"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Pending → Submitted to SimGrid (distribution)</div>
            <span class="muted" id="p2sHint">—</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartP2S"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Top competitions (count)</div>
            <span class="muted" id="topCompHint">—</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartTopCompetitions"></canvas></div>
        </div>
      </div>

      <div class="grid3">
        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Post-race outcome codes (top)</div>
            <span class="muted" id="codesHint">—</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartOutcomeCodes"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">CAUSE total distribution</div>
            <span class="muted" id="causeHint">—</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartCauseDist"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Resolve reasons (top)</div>
            <span class="muted" id="reasonsHint">—</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartResolveReasons"></canvas></div>
        </div>
      </div>

      <!-- Tables -->
      <div class="grid4">
        <div class="chartCard">
          <div class="rowBetween">
            <div>
              <div class="chartTitle">Oldest open tickets</div>
              <div class="muted">Backlog pressure points</div>
            </div>
          </div>
          <div class="tableWrap">
            <table>
              <thead>
                <tr>
                  <th>Ticket</th>
                  <th>Status</th>
                  <th>Competition</th>
                  <th>Event</th>
                  <th>Accused</th>
                  <th>Reporter</th>
                  <th>Age</th>
                  <th>Created</th>
                  <th>Open</th>
                </tr>
              </thead>
              <tbody id="tbodyOldestOpen"></tbody>
            </table>
          </div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div>
              <div class="chartTitle">Green light queues</div>
              <div class="muted">Pending vs Awaiting — both visible</div>
            </div>
          </div>

          <details open style="margin-top:10px;">
            <summary>Oldest pending green light</summary>
            <div class="muted" id="pendingHint" style="margin-top:6px;">—</div>
            <div class="tableWrap" style="margin-top:10px;">
              <table style="min-width:860px;">
                <thead>
                  <tr>
                    <th>Ticket</th>
                    <th>Pending since</th>
                    <th>Age</th>
                    <th>Competition</th>
                    <th>Event</th>
                    <th>Accused</th>
                    <th>Open</th>
                  </tr>
                </thead>
                <tbody id="tbodyPending"></tbody>
              </table>
            </div>
          </details>

          <details style="margin-top:10px;">
            <summary>Oldest awaiting green light</summary>
            <div class="muted" id="awaitingHint" style="margin-top:6px;">—</div>
            <div class="tableWrap" style="margin-top:10px;">
              <table style="min-width:860px;">
                <thead>
                  <tr>
                    <th>Ticket</th>
                    <th>Awaiting since</th>
                    <th>Age</th>
                    <th>Competition</th>
                    <th>Event</th>
                    <th>Accused</th>
                    <th>Open</th>
                  </tr>
                </thead>
                <tbody id="tbodyAwaiting"></tbody>
              </table>
            </div>
          </details>

          <div class="muted" style="margin-top:10px;">
            Awaiting detection uses your ticket fields and status text. If you standardise an <span class="mono">awaitingAt</span> timestamp later, this becomes perfect.
          </div>
        </div>
      </div>

      <div class="grid4">
        <div class="chartCard">
          <div class="rowBetween">
            <div>
              <div class="chartTitle">Recently resolved (latest 20)</div>
              <div class="muted">Shows resolvedBy + reason + CAUSE</div>
            </div>
          </div>
          <div class="tableWrap">
            <table style="min-width:980px;">
              <thead>
                <tr>
                  <th>Resolved at</th>
                  <th>Ticket</th>
                  <th>Competition</th>
                  <th>Event</th>
                  <th>Outcome</th>
                  <th>CAUSE</th>
                  <th>Resolved by</th>
                  <th>Reason</th>
                  <th>Open</th>
                </tr>
              </thead>
              <tbody id="tbodyRecentResolved"></tbody>
            </table>
          </div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div>
              <div class="chartTitle">Risk / SLA breaches (owner)</div>
              <div class="muted">Tune thresholds in code (defaults below)</div>
            </div>
          </div>

          <div class="muted" id="slaHint" style="margin-top:8px;">—</div>

          <div class="tableWrap">
            <table style="min-width:980px;">
              <thead>
                <tr>
                  <th>Ticket</th>
                  <th>Status</th>
                  <th>Competition</th>
                  <th>Event</th>
                  <th>Age</th>
                  <th>Pending age</th>
                  <th>Awaiting age</th>
                  <th>Open</th>
                </tr>
              </thead>
              <tbody id="tbodySla"></tbody>
            </table>
          </div>

          <details style="margin-top:10px;">
            <summary>Top people + competitions</summary>
            <div class="grid2" style="margin-top:10px;">
              <div>
                <div class="muted"><b>Top reporters</b></div>
                <div class="tableWrap" style="margin-top:8px;">
                  <table style="min-width:760px;">
                    <thead><tr><th>Reporter</th><th>Tickets</th></tr></thead>
                    <tbody id="tbodyTopReporters"></tbody>
                  </table>
                </div>
              </div>
              <div>
                <div class="muted"><b>Top accused</b></div>
                <div class="tableWrap" style="margin-top:8px;">
                  <table style="min-width:760px;">
                    <thead><tr><th>Accused</th><th>Tickets</th></tr></thead>
                    <tbody id="tbodyTopAccused"></tbody>
                  </table>
                </div>
              </div>
            </div>

            <div style="margin-top:10px;">
              <div class="muted"><b>Top competitions</b></div>
              <div class="tableWrap" style="margin-top:8px;">
                <table style="min-width:860px;">
                  <thead><tr><th>Competition</th><th>Tickets</th><th>Open</th><th>Resolved</th><th>NFA %</th></tr></thead>
                  <tbody id="tbodyTopCompetitions"></tbody>
                </table>
              </div>
            </div>
          </details>
        </div>
      </div>

      <div class="muted" style="margin-top:10px;">
        Owner notes: This page reads from Firebase and calculates metrics client-side. If you later add standard timestamps like
        <span class="mono">awaitingAt</span>, <span class="mono">pendingAt</span>, <span class="mono">greenlitAt</span>, you’ll unlock perfect stage timing and SLA enforcement.
      </div>
    </div>
  </div>

  <div class="toast" id="toast">Saved</div>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <script src="./firebase-init.js"></script>

  <script>
    const $ = (id) => document.getElementById(id);

    const toastEl = $("toast");
    function toast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      setTimeout(() => toastEl.classList.remove("show"), 2200);
    }

    window.addEventListener("error", (e) => {
      const msg = (e?.message || "Unknown JS error") + (e?.filename ? `\n${e.filename}:${e.lineno || 0}` : "");
      console.error("JS error:", e);
      toast("JS ERROR:\n" + msg);
    });
    window.addEventListener("unhandledrejection", (e) => {
      console.error("Promise rejection:", e);
      toast("PROMISE ERROR:\n" + (e?.reason?.message || e?.reason || "Unknown"));
    });

    function escapeHtml(s){
      return (s ?? "").toString()
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
    }

    // ignore RT collections per request
    function isRaceTeamCollection(name){
      return String(name || "").toLowerCase().startsWith("rt");
    }

    function norm(s){
      return String(s || "").trim();
    }
    function lower(s){
      return String(s || "").toLowerCase().trim();
    }
    function trunc(s, n=80){
      s = String(s || "");
      return s.length > n ? s.slice(0,n-1) + "…" : s;
    }

    function isFinalised(status){
      const s = (status || "").trim().toUpperCase();
      return s === "FINALISED" || s === "FINALIZED" || s === "CLOSED" || s === "RESOLVED";
    }

    function msFromTs(v){
      try{
        if (!v) return 0;
        if (v.toDate) return v.toDate().getTime();
        if (typeof v === "number") return v;
        const d = new Date(v);
        const ms = d.getTime();
        return isNaN(ms) ? 0 : ms;
      }catch{ return 0; }
    }

    function pickFirstMs(obj, keys){
      for (const k of keys){
        const ms = msFromTs(obj?.[k]);
        if (ms && ms > 0) return ms;
      }
      return 0;
    }

    function fmtDate(ms){
      if (!ms) return "—";
      return new Date(ms).toLocaleString();
    }

    function fmtDuration(ms){
      if (!ms || ms < 0) return "—";
      const sec = Math.floor(ms/1000);
      const min = Math.floor(sec/60);
      const hr = Math.floor(min/60);
      const day = Math.floor(hr/24);
      const remH = hr % 24;
      const remM = min % 60;
      if (day > 0) return `${day}d ${remH}h`;
      if (hr > 0) return `${hr}h ${remM}m`;
      if (min > 0) return `${min}m`;
      return `${sec}s`;
    }

    function median(arr){
      if (!arr.length) return null;
      const a = [...arr].sort((x,y)=>x-y);
      const mid = Math.floor(a.length/2);
      return (a.length % 2 === 0) ? (a[mid-1] + a[mid]) / 2 : a[mid];
    }
    function avg(arr){
      if (!arr.length) return null;
      return arr.reduce((s,v)=>s+v,0) / arr.length;
    }

    function bucketHoursToLabel(hours){
      if (hours < 2) return "<2h";
      if (hours < 6) return "2–6h";
      if (hours < 12) return "6–12h";
      if (hours < 24) return "12–24h";
      if (hours < 48) return "1–2d";
      if (hours < 96) return "2–4d";
      return "4d+";
    }

    function dayKey(ms){
      const d = new Date(ms);
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,"0");
      const dd = String(d.getDate()).padStart(2,"0");
      return `${y}-${m}-${dd}`;
    }

    function makeDateKeysBack(days){
      const keys = [];
      const now = new Date();
      for (let i = days-1; i >= 0; i--){
        const d = new Date(now.getFullYear(), now.getMonth(), now.getDate() - i);
        keys.push(dayKey(d.getTime()));
      }
      return keys;
    }

    // ticket timestamps
    function getCreatedMs(x){
      return pickFirstMs(x, [
        "timestamp","createdAt","created","submittedAt","openedAt","openAt"
      ]);
    }

    function getResolvedMs(x){
      // Your screenshot shows finalOutcome.resolvedAt (nested)
      const nested = pickFirstMs(x?.finalOutcome || {}, ["resolvedAt"]);
      if (nested) return nested;

      const direct = pickFirstMs(x, [
        "finalisedAt","finalizedAt","closedAt","resolvedAt","finalisedTimestamp",
        "statusFinalisedAt","statusFinalizedAt","statusUpdatedAt","updatedAt","lastUpdatedAt"
      ]);
      if (direct) return direct;

      // proxy
      return pickFirstMs(x, [
        "simgridGreenlitAt","simgridSubmittedAt","simgridApprovedAt","simgridCompletedAt"
      ]);
    }

    function getPendingMs(x){
      return pickFirstMs(x, [
        "simgridPendingAt","simgridPendingGreenlitAt","pendingAt","pendingGreenlitAt","pendingSince"
      ]);
    }
    function getSubmittedMs(x){
      return pickFirstMs(x, [
        "simgridSubmittedAt","simgridSubmittedOn","submittedToSimgridAt","submittedAtSimgrid","simgridCompletedAt"
      ]);
    }

    // Awaiting detection
    function boolish(v){ return v === true || String(v||"").toLowerCase() === "true"; }
    function isAwaitingGreenLight(t){
      const status = String(t?.status || "").toLowerCase();
      const statusMatch = status.includes("await") && status.includes("green");
      const fieldMatch = (
        boolish(t?.awaitingGreenLight) ||
        boolish(t?.awaitingGreenlit) ||
        boolish(t?.readyForGreenlight) ||
        boolish(t?.readyForGreenlit) ||
        boolish(t?.awaitingHeadSteward) ||
        boolish(t?.headStewardAwaiting) ||
        boolish(t?.awaitingApproval)
      );
      return statusMatch || fieldMatch;
    }
    function getAwaitingMs(t){
      const direct = pickFirstMs(t, [
        "awaitingGreenlitAt","awaitingGreenLightAt","readyForGreenlightAt","readyForGreenlitAt",
        "awaitingAt","awaitingSince","headStewardAwaitingAt","awaitingApprovalAt"
      ]);
      if (direct) return direct;
      return pickFirstMs(t, ["statusUpdatedAt","updatedAt","lastUpdatedAt","createdAt","timestamp"]);
    }

    function ticketUrl(id){ return `ticket.html?id=${encodeURIComponent(id || "")}`; }

    // chart instances
    let cCreatedResolved=null, cPipeline=null, cStatusDonut=null, cTAT=null, cP2S=null, cTopComps=null, cCodes=null, cCause=null, cReasons=null;

    function destroyCharts(){
      for (const ch of [cCreatedResolved,cPipeline,cStatusDonut,cTAT,cP2S,cTopComps,cCodes,cCause,cReasons]){
        if (ch && typeof ch.destroy === "function") ch.destroy();
      }
      cCreatedResolved=cPipeline=cStatusDonut=cTAT=cP2S=cTopComps=cCodes=cCause=cReasons=null;
    }

    function applyChartDefaults(){
      if (typeof Chart === "undefined") return;
      const dpr = Math.min(3, Math.max(2, window.devicePixelRatio || 1));
      Chart.defaults.devicePixelRatio = dpr;
      Chart.defaults.responsive = true;
      Chart.defaults.maintainAspectRatio = false;
      Chart.defaults.font.family = "Arial, sans-serif";
      Chart.defaults.font.size = 12;
      Chart.defaults.elements.line.borderWidth = 2;
      Chart.defaults.elements.point.radius = 2;
      Chart.defaults.elements.point.hoverRadius = 4;
      Chart.defaults.plugins.legend.labels.boxWidth = 14;
      Chart.defaults.plugins.legend.labels.boxHeight = 14;
      Chart.defaults.scale.ticks.maxTicksLimit = 8;
    }

    function baseChartOptions(){
      return {
        responsive: true,
        maintainAspectRatio: false,
        devicePixelRatio: Math.min(3, Math.max(2, window.devicePixelRatio || 1)),
        animation: { duration: 250 },
        plugins: {
          legend: { display: true, labels: { font: { size: 12, weight: "700" } } },
          tooltip: { titleFont: { size: 12, weight: "800" }, bodyFont: { size: 12 } }
        },
        scales: {
          x: { ticks: { font: { size: 11 } } },
          y: { beginAtZero: true, ticks: { precision: 0, font: { size: 11 } } }
        }
      };
    }

    function renderKPIs(kpis){
      $("kpiGrid").innerHTML = kpis.map(k => `
        <div class="kpi">
          <div class="label">${escapeHtml(k.label)}</div>
          <div class="value">${escapeHtml(k.value)}</div>
          <div class="sub">${escapeHtml(k.sub || "")}</div>
        </div>
      `).join("");
    }
    function renderSysKPIs(kpis){
      $("sysKpis").innerHTML = kpis.map(k => `
        <div class="kpi" style="min-height:86px;">
          <div class="label">${escapeHtml(k.label)}</div>
          <div class="value">${escapeHtml(k.value)}</div>
          <div class="sub">${escapeHtml(k.sub || "")}</div>
        </div>
      `).join("");
    }

    function topNFromMap(m, n=10){
      return Array.from(m.entries())
        .sort((a,b)=> (b[1]||0)-(a[1]||0))
        .slice(0,n);
    }

    // ---------------------------
    // Steward audit (kept from your working version)
    // ---------------------------
    let auditRowsCache = [];
    function safeKey(email){ return (email || "").replaceAll("/", "_").replaceAll("\\", "_").trim(); }
    function displayStewardName(raw){
      const s = String(raw || "").trim();
      if (!s) return "Unknown";
      const at = s.indexOf("@");
      return at > 0 ? s.slice(0, at) : s;
    }
    function roleLooksLikeSteward(adminDoc){
      const role = String(adminDoc?.role || "").toLowerCase();
      return (
        role.includes("steward") ||
        role.includes("head") ||
        adminDoc?.headsteward === true ||
        adminDoc?.owner === true
      );
    }
    function ticketIdFromDocRef(docRef){
      try{ return docRef?.parent?.parent?.id || ""; }catch{ return ""; }
    }
    function renderAuditTableFromCache(){
      const metaEl = $("auditMeta");
      const wrapEl = $("auditTableWrap");
      const bodyEl = $("auditTbody");
      const onlyInactive = $("showOnlyInactive").checked === true;
      bodyEl.innerHTML = "";
      const rows = onlyInactive ? auditRowsCache.filter(r => r.inactive) : [...auditRowsCache];
      if (!rows.length){
        wrapEl.style.display = "none";
        metaEl.textContent = onlyInactive ? "No inactive stewards in this window ✅" : "No steward roster/activity data to display.";
        return;
      }
      for (const r of rows){
        const tr = document.createElement("tr");
        if (r.inactive) tr.className = "inactive";
        const last = r.lastActiveMs ? new Date(r.lastActiveMs).toLocaleString() : "—";
        const statusTxt = r.inactive ? "Non-compliant — No steward actions logged" : "OK";
        tr.innerHTML = `
          <td class="mono">${escapeHtml(displayStewardName(r.email))}</td>
          <td><b>${r.comments}</b></td>
          <td><b>${r.reviews}</b></td>
          <td><b>${r.ticketsTouched}</b></td>
          <td>${escapeHtml(last)}</td>
          <td>${escapeHtml(statusTxt)}</td>
        `;
        bodyEl.appendChild(tr);
      }
      wrapEl.style.display = "block";
    }

    async function loadStewardAudit7d(){
      const metaEl = $("auditMeta");
      const wrapEl = $("auditTableWrap");
      const bodyEl = $("auditTbody");
      wrapEl.style.display = "none";
      bodyEl.innerHTML = "";
      metaEl.textContent = "Loading…";
      auditRowsCache = [];
      const now = Date.now();
      const sinceMs = now - (7 * 24 * 60 * 60 * 1000);
      const since = firebase.firestore.Timestamp.fromDate(new Date(sinceMs));

      let rosterEmails = [];
      try{
        const adminsSnap = await db.collection("admins").get();
        rosterEmails = adminsSnap.docs
          .map(d => ({ id: d.id, data: d.data() || {} }))
          .filter(x => roleLooksLikeSteward(x.data))
          .map(x => String(x.id || "").toLowerCase().trim())
          .filter(Boolean);
      }catch(e){
        console.error("Admins roster read failed:", e);
        metaEl.textContent = "Audit failed: cannot read /admins roster. Check Firestore rules.";
        return;
      }

      const m = new Map();
      function getOrCreate(email){
        const k = safeKey(email || "unknown") || "unknown";
        if (!m.has(k)){
          m.set(k, { email: email || "unknown", comments:0, reviews:0, tickets:new Set(), lastActiveMs:0 });
        }
        return m.get(k);
      }

      let commentDocs = 0;
      let reviewDocs = 0;

      try{
        const commentsSnap = await db.collectionGroup("steward_comments").where("createdAt", ">=", since).get();
        commentDocs = commentsSnap.size;
        commentsSnap.forEach(doc => {
          const d = doc.data() || {};
          const ts = d.createdAt && d.createdAt.toDate ? d.createdAt.toDate() : null;
          if (!ts) return;
          const author = String(d.authorKey || d.stewardEmail || "unknown").trim() || "unknown";
          const s = getOrCreate(author);
          s.comments += 1;
          const ticketId = ticketIdFromDocRef(doc.ref);
          if (ticketId) s.tickets.add(ticketId);
          const tms = ts.getTime();
          if (tms > s.lastActiveMs) s.lastActiveMs = tms;
        });

        const reviewsSnap = await db.collectionGroup("reviews").where("submittedAt", ">=", since).get();
        reviewDocs = reviewsSnap.size;
        reviewsSnap.forEach(doc => {
          const d = doc.data() || {};
          const ts = d.submittedAt && d.submittedAt.toDate ? d.submittedAt.toDate() : null;
          if (!ts) return;
          const author = String(d.stewardEmail || d.authorKey || "unknown").trim() || "unknown";
          const s = getOrCreate(author);
          s.reviews += 1;
          const ticketId = ticketIdFromDocRef(doc.ref);
          if (ticketId) s.tickets.add(ticketId);
          const tms = ts.getTime();
          if (tms > s.lastActiveMs) s.lastActiveMs = tms;
        });

      }catch(e){
        console.error("Steward audit collectionGroup failed:", e);
        metaEl.textContent =
          "Audit failed. Either rules deny collectionGroup reads or an index is required. Check console error.";
        return;
      }

      const rosterRows = rosterEmails.map(email => {
        const k = safeKey(email) || "unknown";
        const existing = m.get(k);
        const comments = existing ? existing.comments : 0;
        const reviews = existing ? existing.reviews : 0;
        const ticketsTouched = existing ? existing.tickets.size : 0;
        const lastActiveMs = existing ? existing.lastActiveMs : 0;
        const inactive = (comments + reviews) === 0;
        return { email, comments, reviews, ticketsTouched, lastActiveMs, inactive };
      });

      rosterRows.sort((a,b) => {
        if (a.inactive !== b.inactive) return a.inactive ? -1 : 1;
        const at = (a.comments + a.reviews);
        const bt = (b.comments + b.reviews);
        if (bt !== at) return bt - at;
        return (b.lastActiveMs || 0) - (a.lastActiveMs || 0);
      });

      auditRowsCache = rosterRows;
      const inactiveCount = rosterRows.filter(r => r.inactive).length;
      metaEl.textContent =
        `Loaded. Roster: ${rosterEmails.length} • Inactive: ${inactiveCount} • Comments scanned: ${commentDocs} • Reviews scanned: ${reviewDocs} • Window: last 7 days.`;
      renderAuditTableFromCache();
    }

    // ---------------------------
    // Owner "system overview" counts + search logs
    // ---------------------------
    async function safeCount(col){
      try{
        const snap = await db.collection(col).limit(5000).get();
        return snap.size;
      }catch(e){
        console.warn("Count failed for", col, e);
        return null;
      }
    }

    async function loadSystemOverview(){
      $("sysHint").textContent = "Loading…";
      renderSysKPIs([
        {label:"Tickets", value:"—", sub:"Loading…"},
        {label:"Members", value:"—", sub:"Loading…"},
        {label:"Drivers", value:"—", sub:"Loading…"},
        {label:"Tracks", value:"—", sub:"Loading…"},
        {label:"Admins", value:"—", sub:"Loading…"},
        {label:"Regulations", value:"—", sub:"Loading…"}
      ]);

      const [ticketsC, membersC, driversC, tracksC, adminsC, regsC] = await Promise.all([
        safeCount("tickets"),
        safeCount("members"),
        safeCount("drivers"),
        safeCount("tracks"),
        safeCount("admins"),
        safeCount("regulations")
      ]);

      renderSysKPIs([
        {label:"Tickets", value: ticketsC==null?"—":String(ticketsC), sub:"tickets collection"},
        {label:"Members", value: membersC==null?"—":String(membersC), sub:"members collection"},
        {label:"Drivers", value: driversC==null?"—":String(driversC), sub:"drivers collection"},
        {label:"Tracks", value: tracksC==null?"—":String(tracksC), sub:"tracks collection"},
        {label:"Admins", value: adminsC==null?"—":String(adminsC), sub:"admins collection"},
        {label:"Regulations", value: regsC==null?"—":String(regsC), sub:"regulations collection"}
      ]);

      $("sysHint").textContent = "Loaded";

      // search logs (best-effort)
      const tbody = $("tbodySearchLogs");
      tbody.innerHTML = "";
      try{
        const snap = await db.collection("ticket_search_logs").limit(30).get();
        const rows = snap.docs
          .map(d => ({ id:d.id, ...(d.data()||{}) }))
          .map(x => ({
            when: pickFirstMs(x, ["createdAt","timestamp","time","at"]),
            user: x.email || x.user || x.uid || "—",
            query: x.query || x.search || x.term || x.filters || x.text || "—",
            count: x.count || x.results || x.resultCount || "—"
          }))
          .sort((a,b)=> (b.when||0)-(a.when||0));

        if (!rows.length){
          tbody.innerHTML = `<tr><td colspan="4" class="muted">No search logs found (or rules denied).</td></tr>`;
          return;
        }
        for (const r of rows){
          tbody.insertAdjacentHTML("beforeend", `
            <tr>
              <td>${escapeHtml(fmtDate(r.when))}</td>
              <td class="mono">${escapeHtml(trunc(r.user, 40))}</td>
              <td>${escapeHtml(trunc(typeof r.query==="string"?r.query:JSON.stringify(r.query), 120))}</td>
              <td><b>${escapeHtml(String(r.count))}</b></td>
            </tr>
          `);
        }
      }catch(e){
        console.warn("ticket_search_logs read failed:", e);
        tbody.innerHTML = `<tr><td colspan="4" class="muted">Cannot read ticket_search_logs (rules/index). Check console.</td></tr>`;
      }
    }

    // ---------------------------
    // Main owner load
    // ---------------------------
    function renderOldestOpen(rows){
      const tbody = $("tbodyOldestOpen");
      tbody.innerHTML = "";
      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="9" class="muted">No open tickets found.</td></tr>`;
        return;
      }
      for (const r of rows){
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td class="mono">${escapeHtml(r.id)}</td>
            <td>${escapeHtml(r.status || "")}</td>
            <td>${escapeHtml(trunc(r.competition || "", 70))}</td>
            <td>${escapeHtml(r.event || "")}</td>
            <td>${escapeHtml(trunc(r.accused || "", 40))}</td>
            <td>${escapeHtml(trunc(r.reporter || "", 40))}</td>
            <td><b>${escapeHtml(r.ageLabel)}</b></td>
            <td>${escapeHtml(fmtDate(r.createdMs))}</td>
            <td><a href="${ticketUrl(r.id)}" target="_blank" rel="noopener">Open</a></td>
          </tr>
        `);
      }
    }

    function renderPending(rows){
      const tbody = $("tbodyPending");
      tbody.innerHTML = "";
      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="7" class="muted">No pending green light tickets.</td></tr>`;
        return;
      }
      for (const r of rows){
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td class="mono">${escapeHtml(r.id)}</td>
            <td>${escapeHtml(fmtDate(r.pendingMs))}</td>
            <td><b>${escapeHtml(r.ageLabel)}</b></td>
            <td>${escapeHtml(trunc(r.competition || "", 70))}</td>
            <td>${escapeHtml(r.event || "")}</td>
            <td>${escapeHtml(trunc(r.accused || "", 40))}</td>
            <td><a href="${ticketUrl(r.id)}" target="_blank" rel="noopener">Open</a></td>
          </tr>
        `);
      }
    }

    function renderAwaiting(rows){
      const tbody = $("tbodyAwaiting");
      tbody.innerHTML = "";
      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="7" class="muted">No awaiting green light tickets.</td></tr>`;
        return;
      }
      for (const r of rows){
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td class="mono">${escapeHtml(r.id)}</td>
            <td>${escapeHtml(fmtDate(r.awaitingMs))}</td>
            <td><b>${escapeHtml(r.ageLabel)}</b></td>
            <td>${escapeHtml(trunc(r.competition || "", 70))}</td>
            <td>${escapeHtml(r.event || "")}</td>
            <td>${escapeHtml(trunc(r.accused || "", 40))}</td>
            <td><a href="${ticketUrl(r.id)}" target="_blank" rel="noopener">Open</a></td>
          </tr>
        `);
      }
    }

    function renderRecentResolved(rows){
      const tbody = $("tbodyRecentResolved");
      tbody.innerHTML = "";
      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="9" class="muted">No resolved tickets found.</td></tr>`;
        return;
      }
      for (const r of rows){
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td>${escapeHtml(fmtDate(r.resolvedMs))}</td>
            <td class="mono">${escapeHtml(r.id)}</td>
            <td>${escapeHtml(trunc(r.competition || "", 70))}</td>
            <td>${escapeHtml(r.event || "")}</td>
            <td>${escapeHtml(trunc(r.outcome || "", 60))}</td>
            <td><b>${escapeHtml(String(r.causeTotal ?? "—"))}</b></td>
            <td class="mono">${escapeHtml(trunc(r.resolvedBy || "", 40))}</td>
            <td>${escapeHtml(trunc(r.resolveReason || "", 80))}</td>
            <td><a href="${ticketUrl(r.id)}" target="_blank" rel="noopener">Open</a></td>
          </tr>
        `);
      }
    }

    function renderSla(rows, meta){
      $("slaHint").textContent = meta || "—";
      const tbody = $("tbodySla");
      tbody.innerHTML = "";
      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="8" class="muted">No SLA breaches detected ✅</td></tr>`;
        return;
      }
      for (const r of rows){
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td class="mono">${escapeHtml(r.id)}</td>
            <td>${escapeHtml(r.status || "")}</td>
            <td>${escapeHtml(trunc(r.competition || "", 70))}</td>
            <td>${escapeHtml(r.event || "")}</td>
            <td><b>${escapeHtml(r.age || "—")}</b></td>
            <td>${escapeHtml(r.pendingAge || "—")}</td>
            <td>${escapeHtml(r.awaitingAge || "—")}</td>
            <td><a href="${ticketUrl(r.id)}" target="_blank" rel="noopener">Open</a></td>
          </tr>
        `);
      }
    }

    function renderTopSimple(tbodyId, pairs){
      const tbody = $(tbodyId);
      tbody.innerHTML = "";
      if (!pairs.length){
        tbody.innerHTML = `<tr><td colspan="2" class="muted">No data.</td></tr>`;
        return;
      }
      for (const [k,v] of pairs){
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td>${escapeHtml(trunc(k, 60))}</td>
            <td><b>${escapeHtml(String(v))}</b></td>
          </tr>
        `);
      }
    }

    function renderTopCompetitionsTable(rows){
      const tbody = $("tbodyTopCompetitions");
      tbody.innerHTML = "";
      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="5" class="muted">No data.</td></tr>`;
        return;
      }
      for (const r of rows){
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td>${escapeHtml(trunc(r.name, 80))}</td>
            <td><b>${r.total}</b></td>
            <td>${r.open}</td>
            <td>${r.resolved}</td>
            <td>${r.nfaPct}</td>
          </tr>
        `);
      }
    }

    async function loadDashboard(){
      destroyCharts();

      const days = parseInt($("rangeDays").value, 10) || 7;
      const limit = Math.max(200, Math.min(10000, parseInt($("ticketLimit").value, 10) || 2000));
      const deep = $("deepScan").checked === true;

      const nowMs = Date.now();
      const rangeStartMs = nowMs - days*24*60*60*1000;
      const range7StartMs = nowMs - 7*24*60*60*1000;

      $("createdResolvedHint").textContent = "Loading…";
      $("pipelineHint").textContent = "Loading…";
      $("statusMixHint").textContent = "Loading…";
      $("tatHint").textContent = "Loading…";
      $("p2sHint").textContent = "Loading…";
      $("topCompHint").textContent = "Loading…";
      $("codesHint").textContent = "Loading…";
      $("causeHint").textContent = "Loading…";
      $("reasonsHint").textContent = "Loading…";
      $("pendingHint").textContent = "Loading…";
      $("awaitingHint").textContent = "Loading…";

      renderKPIs([
        {label:"Open (live)", value:"—", sub:"Loading…"},
        {label:"Pending green light", value:"—", sub:"Loading…"},
        {label:"Awaiting green light", value:"—", sub:"Loading…"},
        {label:"Greenlit (not submitted)", value:"—", sub:"Loading…"},
        {label:"Submitted (range)", value:"—", sub:`Last ${days} days`},
        {label:"Resolved (range)", value:"—", sub:`Last ${days} days`},
        {label:"Avg turnaround (7d)", value:"—", sub:"created→resolved"},
        {label:"Median turnaround (7d)", value:"—", sub:"created→resolved"},
        {label:"Avg pending→submit", value:"—", sub:"range"},
        {label:"NFA rate (range)", value:"—", sub:"postRaceCode contains NFA"},
        {label:"CAUSE avg (range)", value:"—", sub:"finalOutcome.causeTotal"},
        {label:"Backlog oldest open", value:"—", sub:"ticket age"}
      ]);

      // Read tickets (owner view)
      const snap = await db.collection("tickets").limit(limit).get();
      const tickets = snap.docs.map(d => ({ id:d.id, ...(d.data()||{}) }));

      // aggregates
      const openTickets = [];
      const resolvedTickets = [];
      const pendingGreen = [];
      const awaitingGreen = [];
      const greenlitNotSubmitted = [];
      const submittedInRange = [];

      const createdCounts = new Map();
      const resolvedCounts = new Map();

      const statusCounts = new Map();

      const tatSamplesMs = [];
      const p2sSamplesMs = [];

      const competitionCounts = new Map();
      const reporterCounts = new Map();
      const accusedCounts = new Map();

      const outcomeCodeCounts = new Map();
      const resolveReasonCounts = new Map();

      const causeTotals = []; // numeric
      let nfaCountRange = 0;
      let rangeTicketCount = 0;

      let tatProxyCount = 0;

      // SLA thresholds (tune)
      const SLA_OPEN_AGE_MS = 7 * 24 * 60 * 60 * 1000;       // open older than 7 days
      const SLA_PENDING_AGE_MS = 48 * 60 * 60 * 1000;        // pending > 48h
      const SLA_AWAITING_AGE_MS = 48 * 60 * 60 * 1000;       // awaiting > 48h

      // optional deep scan helpers (more key checks)
      function statusBucket(t){
        const s = lower(t.status);
        if (isFinalised(t.status) || getResolvedMs(t)) return "Resolved";
        if (t.simgridSubmitted === true) return "Submitted";
        if (t.simgridGreenlit === true && t.simgridSubmitted !== true) return "Greenlit";
        if (t.simgridPendingGreenlit === true) return "Pending";
        if (isAwaitingGreenLight(t)) return "Awaiting";
        if (!s) return "Open";
        return s.length > 28 ? s.slice(0,28)+"…" : s;
      }

      for (const t of tickets){
        const createdMs = getCreatedMs(t);
        const resolvedMs = getResolvedMs(t);

        const status = String(t.status || "");
        const bucket = statusBucket(t);
        statusCounts.set(bucket, (statusCounts.get(bucket)||0) + 1);

        const comp = norm(t.competition || t.league || t.series || "");
        const reporter = norm(t.reporter || t.driverReporting || t.reportedBy || "");
        const accused = norm(t.accused || "");

        if (comp) competitionCounts.set(comp, (competitionCounts.get(comp)||0) + 1);
        if (reporter) reporterCounts.set(reporter, (reporterCounts.get(reporter)||0) + 1);
        if (accused) accusedCounts.set(accused, (accusedCounts.get(accused)||0) + 1);

        const isResolved = isFinalised(status) || !!resolvedMs || !!(t.finalOutcome && t.finalOutcome.resolvedAt);
        if (!isResolved) openTickets.push({ ...t, createdMs, resolvedMs });
        if (isResolved) resolvedTickets.push({ ...t, createdMs, resolvedMs });

        const pendingFlag = t.simgridPendingGreenlit === true;
        const greenlit = t.simgridGreenlit === true;
        const submitted = t.simgridSubmitted === true;

        if (pendingFlag && !greenlit && !submitted){
          const pendingMs = getPendingMs(t);
          pendingGreen.push({ ...t, createdMs, pendingMs, resolvedMs });
        }
        if (!pendingFlag && isAwaitingGreenLight(t) && !greenlit && !submitted){
          const awaitingMs = getAwaitingMs(t);
          awaitingGreen.push({ ...t, createdMs, awaitingMs, resolvedMs });
        }
        if (greenlit && !submitted){
          greenlitNotSubmitted.push({ ...t, createdMs });
        }

        const submittedMs = getSubmittedMs(t);
        if (submitted && submittedMs && submittedMs >= rangeStartMs){
          submittedInRange.push({ ...t, submittedMs, createdMs });
        }

        // daily trends
        if (createdMs && createdMs >= rangeStartMs){
          const k = dayKey(createdMs);
          createdCounts.set(k, (createdCounts.get(k) || 0) + 1);
        }
        if (resolvedMs && resolvedMs >= rangeStartMs){
          const k = dayKey(resolvedMs);
          resolvedCounts.set(k, (resolvedCounts.get(k) || 0) + 1);
        }

        // range ticket base for rates
        if (createdMs && createdMs >= rangeStartMs) rangeTicketCount++;

        // turnaround samples (resolved in last 7d)
        if (createdMs && resolvedMs && resolvedMs >= range7StartMs){
          // proxy check: if the nested resolvedAt isn't present and finalised fields absent
          const direct = pickFirstMs(t, ["finalisedAt","finalizedAt","closedAt","resolvedAt"]);
          const nested = pickFirstMs(t?.finalOutcome || {}, ["resolvedAt"]);
          if (!direct && !nested) tatProxyCount++;
          tatSamplesMs.push(resolvedMs - createdMs);
        }

        // pending->submit samples (submitted in chosen range + have pending ts)
        const pendingMs = getPendingMs(t);
        if (pendingMs && submittedMs && submittedMs >= rangeStartMs){
          p2sSamplesMs.push(submittedMs - pendingMs);
        }

        // outcome code + reasons + cause totals (only if resolved/range-ish)
        const outcomeCode = norm(t.postRaceCode || t.ruleBreach || (t.finalOutcome && t.finalOutcome.resolvedPenaltyVote) || "");
        if (outcomeCode) outcomeCodeCounts.set(outcomeCode, (outcomeCodeCounts.get(outcomeCode)||0) + 1);

        const resolveReason = norm((t.finalOutcome && t.finalOutcome.resolveReason) || t.resolveReason || "");
        if (resolveReason) resolveReasonCounts.set(resolveReason, (resolveReasonCounts.get(resolveReason)||0) + 1);

        const causeTotalRaw = (t.finalOutcome && t.finalOutcome.causeTotal);
        const causeTotal = (causeTotalRaw === 0 || causeTotalRaw) ? Number(causeTotalRaw) : null;
        if (causeTotal != null && !Number.isNaN(causeTotal) && createdMs && createdMs >= rangeStartMs){
          causeTotals.push(causeTotal);
        }

        // NFA rate
        if (createdMs && createdMs >= rangeStartMs){
          const pr = lower(t.postRaceCode);
          if (pr.includes("nfa") || pr.includes("no further action")) nfaCountRange++;
        }

        // deep scan optional: if you add more text fields later, you can extend here.
        if (deep){
          // placeholder for future deeper analytics (e.g. keyword scan)
        }
      }

      // Open age stats
      const openAgesMs = openTickets
        .map(t => t.createdMs ? (nowMs - t.createdMs) : null)
        .filter(x => x != null && x >= 0);

      openTickets.sort((a,b) => (a.createdMs||0) - (b.createdMs||0));
      const oldestOpen = openTickets[0];

      pendingGreen.sort((a,b) => (a.pendingMs||0) - (b.pendingMs||0));
      awaitingGreen.sort((a,b) => (a.awaitingMs||0) - (b.awaitingMs||0));

      // resolved in range
      const resolvedInRange = resolvedTickets.filter(t => (t.resolvedMs||0) >= rangeStartMs);

      // compute CAUSE stats (range)
      const causeAvg = avg(causeTotals);
      const causeMed = median(causeTotals);

      // KPIs
      const tatAvg = avg(tatSamplesMs);
      const tatMed = median(tatSamplesMs);
      const p2sAvg = avg(p2sSamplesMs);
      const p2sMed = median(p2sSamplesMs);

      const nfaPct = rangeTicketCount ? Math.round((nfaCountRange / rangeTicketCount) * 100) : 0;

      renderKPIs([
        {label:"Open (live)", value:String(openTickets.length), sub: openTickets.length ? "Not resolved yet" : "No open tickets 🎉"},
        {label:"Pending green light", value:String(pendingGreen.length), sub: pendingGreen[0]?.pendingMs ? `Oldest: ${fmtDuration(nowMs - pendingGreen[0].pendingMs)}` : "—"},
        {label:"Awaiting green light", value:String(awaitingGreen.length), sub: awaitingGreen[0]?.awaitingMs ? `Oldest: ${fmtDuration(nowMs - awaitingGreen[0].awaitingMs)}` : "—"},
        {label:"Greenlit (not submitted)", value:String(greenlitNotSubmitted.length), sub: "Approved but not pushed"},
        {label:"Submitted (range)", value:String(submittedInRange.length), sub:`Last ${days} day(s)`},
        {label:"Resolved (range)", value:String(resolvedInRange.length), sub:`Last ${days} day(s)`},
        {label:"Avg turnaround (7d)", value: tatAvg ? fmtDuration(tatAvg) : "—", sub: tatSamplesMs.length ? `Samples: ${tatSamplesMs.length}` : "No samples"},
        {label:"Median turnaround (7d)", value: tatMed ? fmtDuration(tatMed) : "—", sub: tatProxyCount ? `Proxy used: ${tatProxyCount}/${tatSamplesMs.length}` : "—"},
        {label:"Avg pending→submit", value: p2sAvg ? fmtDuration(p2sAvg) : "—", sub: p2sMed ? `Median: ${fmtDuration(p2sMed)}` : `Need pending + submitted ts`},
        {label:"NFA rate (range)", value: rangeTicketCount ? `${nfaPct}%` : "—", sub: rangeTicketCount ? `${nfaCountRange}/${rangeTicketCount} tickets` : "No range data"},
        {label:"CAUSE avg (range)", value: causeTotals.length ? String(Math.round(causeAvg*100)/100) : "—", sub: causeTotals.length ? `Median: ${causeMed}` : "No causeTotal data"},
        {label:"Backlog oldest open", value: oldestOpen?.createdMs ? fmtDuration(nowMs - oldestOpen.createdMs) : "—", sub: oldestOpen ? `Ticket: ${oldestOpen.id}` : "—"}
      ]);

      // tables: oldest open / pending / awaiting
      const oldestOpenRows = openTickets.slice(0, 15).map(t => ({
        id: t.id,
        status: t.status || "",
        competition: t.competition || "",
        event: t.event || "",
        accused: t.accused || "",
        reporter: t.reporter || t.driverReporting || "",
        createdMs: t.createdMs || 0,
        ageLabel: t.createdMs ? fmtDuration(nowMs - t.createdMs) : "—"
      }));
      renderOldestOpen(oldestOpenRows);

      const pendingRows = pendingGreen.slice(0, 15).map(t => ({
        id: t.id,
        pendingMs: t.pendingMs || 0,
        ageLabel: t.pendingMs ? fmtDuration(nowMs - t.pendingMs) : "—",
        competition: t.competition || "",
        event: t.event || "",
        accused: t.accused || ""
      }));
      renderPending(pendingRows);

      const awaitingRows = awaitingGreen.slice(0, 15).map(t => ({
        id: t.id,
        awaitingMs: t.awaitingMs || 0,
        ageLabel: t.awaitingMs ? fmtDuration(nowMs - t.awaitingMs) : "—",
        competition: t.competition || "",
        event: t.event || "",
        accused: t.accused || ""
      }));
      renderAwaiting(awaitingRows);

      $("pendingHint").textContent = pendingGreen.length ? `Oldest pending: ${fmtDuration(nowMs - (pendingGreen[0].pendingMs||nowMs))}` : "No pending items";
      $("awaitingHint").textContent = awaitingGreen.length ? `Oldest awaiting: ${fmtDuration(nowMs - (awaitingGreen[0].awaitingMs||nowMs))}` : "No awaiting items";

      // recent resolved table
      const recentResolved = resolvedTickets
        .filter(t => t.resolvedMs)
        .sort((a,b)=> (b.resolvedMs||0)-(a.resolvedMs||0))
        .slice(0, 20)
        .map(t => {
          const fo = t.finalOutcome || {};
          return {
            id: t.id,
            resolvedMs: t.resolvedMs,
            competition: t.competition || "",
            event: t.event || "",
            outcome: t.postRaceCode || (fo.resolvedPenaltyVote || ""),
            causeTotal: (fo.causeTotal === 0 || fo.causeTotal) ? fo.causeTotal : "—",
            resolvedBy: fo.resolvedBy || t.resolvedBy || "",
            resolveReason: fo.resolveReason || t.resolveReason || ""
          };
        });
      renderRecentResolved(recentResolved);

      // SLA breaches list
      const slaRows = [];
      for (const t of openTickets){
        const ageMs = t.createdMs ? (nowMs - t.createdMs) : 0;
        const pendingMs = getPendingMs(t);
        const awaitingMs = getAwaitingMs(t);
        const pAge = pendingMs ? (nowMs - pendingMs) : 0;
        const aAge = (isAwaitingGreenLight(t) && awaitingMs) ? (nowMs - awaitingMs) : 0;

        const isBreach =
          (ageMs && ageMs > SLA_OPEN_AGE_MS) ||
          (pendingMs && pAge > SLA_PENDING_AGE_MS) ||
          ((isAwaitingGreenLight(t)) && awaitingMs && aAge > SLA_AWAITING_AGE_MS);

        if (isBreach){
          slaRows.push({
            id: t.id,
            status: t.status || "",
            competition: t.competition || "",
            event: t.event || "",
            age: ageMs ? fmtDuration(ageMs) : "—",
            pendingAge: pendingMs ? fmtDuration(pAge) : "—",
            awaitingAge: (isAwaitingGreenLight(t) && awaitingMs) ? fmtDuration(aAge) : "—"
          });
        }
      }
      slaRows.sort((a,b)=> {
        // sort by longest age first (approx)
        const ax = a.age.includes("d") ? parseInt(a.age) : 0;
        const bx = b.age.includes("d") ? parseInt(b.age) : 0;
        return bx - ax;
      });
      renderSla(slaRows.slice(0, 25), `Thresholds: Open>${fmtDuration(SLA_OPEN_AGE_MS)} • Pending>${fmtDuration(SLA_PENDING_AGE_MS)} • Awaiting>${fmtDuration(SLA_AWAITING_AGE_MS)} • Showing up to 25`);

      // Top reporters / accused / competitions tables
      renderTopSimple("tbodyTopReporters", topNFromMap(reporterCounts, 12));
      renderTopSimple("tbodyTopAccused", topNFromMap(accusedCounts, 12));

      // competition breakdown (open/resolved/nfa)
      const topComps = topNFromMap(competitionCounts, 12).map(([name,total]) => {
        let open=0, resolved=0, nfa=0;
        for (const t of tickets){
          if (norm(t.competition||"") !== name) continue;
          const createdMs = getCreatedMs(t);
          const resolvedMs = getResolvedMs(t);
          const isResolved = isFinalised(t.status) || !!resolvedMs || !!(t.finalOutcome && t.finalOutcome.resolvedAt);
          if (isResolved) resolved++; else open++;
          if (createdMs && createdMs >= rangeStartMs){
            const pr = lower(t.postRaceCode);
            if (pr.includes("nfa") || pr.includes("no further action")) nfa++;
          }
        }
        const nfaPctLocal = total ? `${Math.round((nfa/Math.max(1,total))*100)}%` : "—";
        return { name, total, open, resolved, nfaPct: nfaPctLocal };
      });
      renderTopCompetitionsTable(topComps);

      // ---------------------------
      // Charts
      // ---------------------------
      const dateKeys = makeDateKeysBack(Math.min(days, 30));
      const createdSeries = dateKeys.map(k => createdCounts.get(k) || 0);
      const resolvedSeries = dateKeys.map(k => resolvedCounts.get(k) || 0);
      $("createdResolvedHint").textContent = `Last ${Math.min(days,30)} day(s)`;

      cCreatedResolved = new Chart($("chartCreatedResolved"), {
        type: "line",
        data: { labels: dateKeys, datasets: [
          { label:"Created", data: createdSeries, tension:0.3 },
          { label:"Resolved", data: resolvedSeries, tension:0.3 }
        ]},
        options: baseChartOptions()
      });

      $("pipelineHint").textContent = "Counts are current; Submitted/Resolved are in selected range";
      cPipeline = new Chart($("chartPipeline"), {
        type:"bar",
        data:{
          labels:["Open","Pending","Awaiting","Greenlit","Submitted (range)","Resolved (range)"],
          datasets:[{ label:"Tickets", data:[
            openTickets.length,
            pendingGreen.length,
            awaitingGreen.length,
            greenlitNotSubmitted.length,
            submittedInRange.length,
            resolvedInRange.length
          ]}]
        },
        options:{ ...baseChartOptions(), plugins:{ ...baseChartOptions().plugins, legend:{ display:false } } }
      });

      // Status donut
      const statusPairs = Array.from(statusCounts.entries()).sort((a,b)=>b[1]-a[1]).slice(0,10);
      const statusLabels = statusPairs.map(x=>x[0]);
      const statusVals = statusPairs.map(x=>x[1]);
      $("statusMixHint").textContent = "Top 10 buckets";
      cStatusDonut = new Chart($("chartStatusDonut"), {
        type:"doughnut",
        data:{ labels: statusLabels, datasets:[{ data: statusVals }]},
        options:{ responsive:true, maintainAspectRatio:false, plugins:{ legend:{ display:true } } }
      });

      // TAT distribution
      const tatBuckets = new Map([["<2h",0],["2–6h",0],["6–12h",0],["12–24h",0],["1–2d",0],["2–4d",0],["4d+",0]]);
      for (const ms of tatSamplesMs){
        const hours = ms/(1000*60*60);
        const label = bucketHoursToLabel(hours);
        tatBuckets.set(label, (tatBuckets.get(label)||0)+1);
      }
      const tatLabels = Array.from(tatBuckets.keys());
      const tatValues = tatLabels.map(k=>tatBuckets.get(k)||0);
      $("tatHint").textContent = tatSamplesMs.length
        ? `Last 7 days • Avg: ${fmtDuration(tatAvg)} • Median: ${fmtDuration(tatMed)}`
        : "Last 7 days • No usable samples yet";
      cTAT = new Chart($("chartTAT"), {
        type:"bar",
        data:{ labels: tatLabels, datasets:[{ label:"Tickets", data: tatValues }]},
        options:{ ...baseChartOptions(), plugins:{ ...baseChartOptions().plugins, legend:{ display:false } } }
      });

      // Pending->Submit distribution
      const p2sBuckets = new Map([["<2h",0],["2–6h",0],["6–12h",0],["12–24h",0],["1–2d",0],["2–4d",0],["4d+",0]]);
      for (const ms of p2sSamplesMs){
        const hours = ms/(1000*60*60);
        const label = bucketHoursToLabel(hours);
        p2sBuckets.set(label, (p2sBuckets.get(label)||0)+1);
      }
      const p2sLabels = Array.from(p2sBuckets.keys());
      const p2sValues = p2sLabels.map(k=>p2sBuckets.get(k)||0);
      $("p2sHint").textContent = p2sSamplesMs.length
        ? `Last ${days} days • Avg: ${fmtDuration(p2sAvg)} • Median: ${fmtDuration(p2sMed)}`
        : `Last ${days} days • No samples (need pending + submitted timestamps)`;
      cP2S = new Chart($("chartP2S"), {
        type:"bar",
        data:{ labels:p2sLabels, datasets:[{ label:"Tickets", data:p2sValues }]},
        options:{ ...baseChartOptions(), plugins:{ ...baseChartOptions().plugins, legend:{ display:false } } }
      });

      // Top competitions chart
      const topCompPairs = topNFromMap(competitionCounts, 8);
      $("topCompHint").textContent = `Top ${topCompPairs.length} competitions`;
      cTopComps = new Chart($("chartTopCompetitions"), {
        type:"bar",
        data:{
          labels: topCompPairs.map(x=>trunc(x[0], 26)),
          datasets:[{ label:"Tickets", data: topCompPairs.map(x=>x[1]) }]
        },
        options:{ ...baseChartOptions(), plugins:{ ...baseChartOptions().plugins, legend:{ display:false } } }
      });

      // Outcome codes chart
      const topCodePairs = topNFromMap(outcomeCodeCounts, 8);
      $("codesHint").textContent = `Top ${topCodePairs.length} codes`;
      cCodes = new Chart($("chartOutcomeCodes"), {
        type:"bar",
        data:{
          labels: topCodePairs.map(x=>trunc(x[0], 26)),
          datasets:[{ label:"Tickets", data: topCodePairs.map(x=>x[1]) }]
        },
        options:{ ...baseChartOptions(), plugins:{ ...baseChartOptions().plugins, legend:{ display:false } } }
      });

      // CAUSE dist chart (bucketed)
      const causeBuckets = new Map([["0",0],["1–5",0],["6–10",0],["11–20",0],["21–30",0],["31+",0]]);
      for (const v of causeTotals){
        if (v === 0) causeBuckets.set("0", (causeBuckets.get("0")||0)+1);
        else if (v <= 5) causeBuckets.set("1–5", (causeBuckets.get("1–5")||0)+1);
        else if (v <= 10) causeBuckets.set("6–10", (causeBuckets.get("6–10")||0)+1);
        else if (v <= 20) causeBuckets.set("11–20", (causeBuckets.get("11–20")||0)+1);
        else if (v <= 30) causeBuckets.set("21–30", (causeBuckets.get("21–30")||0)+1);
        else causeBuckets.set("31+", (causeBuckets.get("31+")||0)+1);
      }
      const causeLabels = Array.from(causeBuckets.keys());
      const causeVals = causeLabels.map(k=>causeBuckets.get(k)||0);
      $("causeHint").textContent = causeTotals.length ? `Samples: ${causeTotals.length} • Avg: ${Math.round(causeAvg*100)/100} • Median: ${causeMed}` : "No causeTotal data";
      cCause = new Chart($("chartCauseDist"), {
        type:"bar",
        data:{ labels:causeLabels, datasets:[{ label:"Tickets", data:causeVals }]},
        options:{ ...baseChartOptions(), plugins:{ ...baseChartOptions().plugins, legend:{ display:false } } }
      });

      // Resolve reasons chart
      const topReasonPairs = topNFromMap(resolveReasonCounts, 8);
      $("reasonsHint").textContent = `Top ${topReasonPairs.length} reasons`;
      cReasons = new Chart($("chartResolveReasons"), {
        type:"bar",
        data:{
          labels: topReasonPairs.map(x=>trunc(x[0], 26)),
          datasets:[{ label:"Tickets", data: topReasonPairs.map(x=>x[1]) }]
        },
        options:{ ...baseChartOptions(), plugins:{ ...baseChartOptions().plugins, legend:{ display:false } } }
      });

      toast("Owner dashboard loaded ✅");
    }

    async function waitForFirebaseReady(maxMs = 8000){
      const start = Date.now();
      while (Date.now() - start < maxMs){
        if (typeof auth !== "undefined" && typeof db !== "undefined" && auth && db) return true;
        await new Promise(r => setTimeout(r, 80));
      }
      return false;
    }

    // ---------------------------
    // buttons
    // ---------------------------
    $("backHeadBtn").onclick = () => window.location.href = "https://ifwlowner.github.io/ACC-driver-classifier/headsteward.html";
    $("backClassifierBtn").onclick = () => window.location.href = "index.html";
    $("logoutBtn").onclick = async () => { await auth.signOut(); window.location.href = "admin.html"; };

    $("refreshBtn").onclick = async () => {
      try{
        await loadSystemOverview();
        await loadStewardAudit7d();
        await loadDashboard();
      }catch(e){
        console.error(e);
        toast("Refresh failed:\n" + (e?.message || e));
      }
    };
    $("rangeDays").onchange = () => $("refreshBtn").click();
    $("ticketLimit").onchange = () => $("refreshBtn").click();
    $("deepScan").onchange = () => $("refreshBtn").click();

    $("refreshAuditBtn").onclick = () => loadStewardAudit7d();
    $("showOnlyInactive").onchange = () => renderAuditTableFromCache();

    // ---------------------------
    // boot
    // ---------------------------
    (async () => {
      const ok = await waitForFirebaseReady();
      if (!ok){
        toast("Firebase not ready.\nCheck firebase-init.js path + console.");
        return;
      }
      try{ applyChartDefaults(); }catch(e){ console.warn("Chart defaults failed:", e); }

      auth.onAuthStateChanged(async (user) => {
        try{
          if (!user){ window.location.href = "admin.html"; return; }

          const email = (user.email || "").toLowerCase().trim();
          const adminSnap = await db.collection("admins").doc(email).get();
          if (!adminSnap.exists){ await auth.signOut(); window.location.href = "admin.html"; return; }

          const data = adminSnap.data() || {};
          const roleText = String(data.role || "").toLowerCase();
          const isOwner = roleText.includes("owner") || data.owner === true;

          if (!isOwner){
            toast("Access denied (owner only).");
            await auth.signOut();
            window.location.href = "admin.html";
            return;
          }

          $("permPill").textContent = "Permissions: Owner";

          const nameGuess = (email.split("@")[0] || "").replace(/[._-]+/g, " ").trim();
          const niceName = nameGuess ? nameGuess.replace(/\b\w/g, c => c.toUpperCase()) : "Owner";

          $("welcomeLine").textContent = `Welcome, ${niceName}. This page shows maximum visibility across IFWL operations.`;
          $("who").textContent = `Signed in as: ${email} | role: ${data.role || "admin"}`;

          await loadSystemOverview();
          await loadStewardAudit7d();
          await loadDashboard();
        }catch(e){
          console.error(e);
          toast("Auth/load error:\n" + (e?.message || e));
        }
      });
    })();
  </script>
</body>
</html>
