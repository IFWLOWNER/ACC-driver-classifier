<!DOCTYPE html>
<html>
<head>
  <title>IFWL Owner ‚Äî Overview Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    body{
      font-family: Arial, sans-serif;
      margin:0;
      background:
        linear-gradient(rgba(2,6,23,0.72), rgba(2,6,23,0.72)),
        url("./ifwl_bg.webp");
      background-size:cover;
      background-position:center;
      background-attachment:fixed;
      color:#111827;
    }

    header{
      padding:14px 18px;
      background:#111827;
      color:#fff;
    }
    .headerInner{
      max-width:1400px;
      margin:0 auto;
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
    }

    .brand{
      display:flex;
      gap:12px;
      align-items:flex-start;
      min-width:0;
    }
    .brand img{
      width:38px;height:38px;object-fit:contain;margin-top:2px;flex:0 0 auto;
      filter: drop-shadow(0 1px 1px rgba(0,0,0,0.25));
    }
    .brandText{min-width:0;}
    .brandTitle{font-weight:900; font-size:18px;}
    header .small{font-size:12px;opacity:0.85;margin-top:4px;line-height:1.2;word-break:break-word;}
    .welcomeLine{font-size:12px;opacity:0.95;margin-top:6px;line-height:1.25;}

    .wrap{
      padding:14px;
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
      max-width:1400px;
      margin:0 auto;
    }

    .card{
      background:rgba(255,255,255,0.92);
      border:1px solid rgba(229,231,235,0.95);
      border-radius:14px;
      padding:12px;
      box-shadow:0 10px 28px rgba(0,0,0,0.18);
    }

    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .rowBetween{display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
    .title{font-weight:900; font-size:16px; margin:0;}
    .muted{color:#6b7280; font-size:12px;}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, monospace;}

    button{padding:10px 12px; border:1px solid #d1d5db; border-radius:12px; background:#fff; cursor:pointer;}
    button.primary{background:#111827;color:#fff;border-color:#111827;}
    button:disabled{opacity:0.6;cursor:not-allowed;}

    select, input{
      padding:10px; border:1px solid #d1d5db; border-radius:12px;
      box-sizing:border-box; font-size:16px; background:#fff;
    }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:4px 10px; border-radius:999px;
      border:1px solid #e5e7eb; background:#fff;
      font-size:12px; color:#111827; white-space:nowrap;
    }
    .pill strong{font-weight:900;}

    .kpiGrid{
      display:grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap:12px;
      margin-top:10px;
    }
    .kpi{
      background:#fff;
      border:1px solid #e5e7eb;
      border-radius:14px;
      padding:12px;
      box-shadow:0 8px 18px rgba(0,0,0,0.08);
      min-height:88px;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
    }
    .kpi .label{font-size:12px; color:#6b7280; font-weight:800;}
    .kpi .value{font-size:22px; font-weight:900; margin-top:6px;}
    .kpi .sub{font-size:12px; color:#6b7280; margin-top:6px; line-height:1.25;}

    .grid2{
      display:grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap:12px;
    }
    .gridCharts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:12px;
    }

    .chartCard{
      background:#fff;
      border:1px solid #e5e7eb;
      border-radius:14px;
      padding:12px;
      box-shadow:0 8px 18px rgba(0,0,0,0.08);
    }
    .chartTitle{font-weight:900; font-size:13px;}
    canvas{width:100% !important; height:280px !important;}

    .tableWrap{
      overflow:auto;
      border:1px solid #e5e7eb;
      border-radius:12px;
      background:#fff;
      margin-top:10px;
    }
    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      min-width:980px;
    }
    th, td{
      padding:10px;
      border-bottom:1px solid #f3f4f6;
      font-size:13px;
      text-align:left;
      vertical-align:top;
    }
    th{
      position:sticky;
      top:0;
      background:#f9fafb;
      z-index:2;
      font-size:12px;
      color:#111827;
      border-bottom:1px solid #e5e7eb;
      white-space:nowrap;
    }
    tr:last-child td{border-bottom:0;}

    .tag{
      display:inline-block;
      padding:3px 10px;
      border-radius:999px;
      border:1px solid #e5e7eb;
      background:#fff;
      font-size:12px;
      font-weight:900;
      white-space:nowrap;
    }
    .tag.ok{border-color:#86efac;background:#ecfdf5;color:#065f46;}
    .tag.bad{border-color:#fca5a5;background:#fef2f2;color:#991b1b;}
    .tag.neutral{border-color:#d1d5db;background:#f9fafb;color:#111827;}

    a{color:#111827;}
    a:hover{opacity:0.85;}

    .toast{
      position:fixed; right:16px; bottom:16px;
      background:#111827; color:#fff;
      padding:10px 12px; border-radius:12px;
      opacity:0; transform: translateY(8px);
      transition: all .18s ease;
      z-index:9999;
      max-width: min(520px, calc(100vw - 32px));
      white-space: pre-wrap;
    }
    .toast.show{opacity:1; transform: translateY(0);}

    @media (max-width: 1200px){
      .kpiGrid{grid-template-columns: repeat(3, minmax(0, 1fr));}
      .grid2{grid-template-columns:1fr;}
    }
    @media (max-width: 980px){
      body{background-attachment:scroll;}
      .headerInner{flex-direction:column; align-items:stretch;}
      header .row{width:100%;}
      header button{width:100%;}
      .kpiGrid{grid-template-columns: repeat(2, minmax(0, 1fr));}
      .gridCharts{grid-template-columns:1fr;}
      canvas{height:260px !important;}
      table{min-width:860px;}
    }
  </style>
</head>

<body>
  <header>
    <div class="headerInner">
      <div class="brand">
        <img src="./ifwl_logo.png" alt="IFWL logo">
        <div class="brandText">
          <div class="brandTitle">IFWL Owner ‚Äî Overview Dashboard</div>
          <div class="welcomeLine" id="welcomeLine">Loading your profile‚Ä¶</div>
          <div class="small" id="who">Loading‚Ä¶</div>
        </div>
      </div>

      <div class="row">
        <button id="backHeadBtn">Back to Head Stewards Dashboard</button>
        <button id="backClassifierBtn">Back to Classifier</button>
        <button id="logoutBtn">Sign out</button>
      </div>
    </div>
  </header>

  <div class="wrap">
    <div class="card">
      <div class="rowBetween">
        <div>
          <div class="title">Operations Snapshot</div>
          <div class="muted">Live + last 7 days performance (turnaround, pending, SimGrid throughput)</div>
        </div>
        <div class="row">
          <span class="pill" id="permPill">Permissions: ‚Ä¶</span>
          <select id="rangeDays">
            <option value="7" selected>Last 7 days</option>
            <option value="14">Last 14 days</option>
            <option value="30">Last 30 days</option>
          </select>
          <button id="refreshBtn" class="primary">Refresh</button>
        </div>
      </div>

      <div class="kpiGrid" id="kpiGrid"></div>

      <div class="gridCharts">
        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Tickets created vs finalised (daily)</div>
            <span class="muted" id="createdFinalisedHint">‚Äî</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartDaily"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Ticket pipeline breakdown</div>
            <span class="muted" id="pipelineHint">‚Äî</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartPipeline"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Turnaround time distribution (open ‚Üí finalised)</div>
            <span class="muted" id="tatHint">‚Äî</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartTAT"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Pending ‚Üí Submitted to SimGrid (time)</div>
            <span class="muted" id="pendingToSubmitHint">‚Äî</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartPendingSubmit"></canvas></div>
        </div>
      </div>

      <div class="grid2" style="margin-top:12px;">
        <div class="chartCard">
          <div class="rowBetween">
            <div>
              <div class="chartTitle">Oldest open tickets</div>
              <div class="muted">Helps identify backlog + long-running cases</div>
            </div>
          </div>
          <div class="tableWrap">
            <table>
              <thead>
                <tr>
                  <th>Ticket</th>
                  <th>Status</th>
                  <th>Event</th>
                  <th>Accused</th>
                  <th>Reporter</th>
                  <th>Age</th>
                  <th>Created</th>
                  <th>Open</th>
                </tr>
              </thead>
              <tbody id="tbodyOldestOpen"></tbody>
            </table>
          </div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div>
              <div class="chartTitle">Oldest pending green light</div>
              <div class="muted">Tickets waiting for Head Steward confirmation</div>
            </div>
          </div>
          <div class="tableWrap">
            <table>
              <thead>
                <tr>
                  <th>Ticket</th>
                  <th>Pending since</th>
                  <th>Pending age</th>
                  <th>Event</th>
                  <th>Accused</th>
                  <th>Open</th>
                </tr>
              </thead>
              <tbody id="tbodyPending"></tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- Steward accountability -->
      <div class="grid2" style="margin-top:12px;">
        <div class="chartCard">
          <div class="rowBetween">
            <div>
              <div class="chartTitle">Steward activity (comments / reviews)</div>
              <div class="muted" id="stewardActivityHint">Loading‚Ä¶</div>
            </div>
          </div>
          <div class="tableWrap">
            <table>
              <thead>
                <tr>
                  <th>Steward</th>
                  <th>Email / Key</th>
                  <th>Comments (range)</th>
                  <th>Reviews (range)</th>
                  <th>Last commented</th>
                  <th>Last reviewed</th>
                  <th>Last action</th>
                </tr>
              </thead>
              <tbody id="tbodyStewardActivity"></tbody>
            </table>
          </div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div>
              <div class="chartTitle">‚ÄúNaughty list‚Äù ‚Äî stewards who have failed to do their role</div>
              <div class="muted" id="naughtyHint">Loading‚Ä¶</div>
            </div>
          </div>
          <div class="tableWrap">
            <table>
              <thead>
                <tr>
                  <th>Steward</th>
                  <th>Email / Key</th>
                  <th>Last action</th>
                  <th>Reason</th>
                </tr>
              </thead>
              <tbody id="tbodyNaughty"></tbody>
            </table>
          </div>
          <div class="muted" style="margin-top:8px;" id="naughtyFooterNote">
            If you see ‚Äúadmins load failed‚Äù, update Firestore rules to let Head Steward/Owner read the admins roster.
          </div>
        </div>
      </div>

      <div class="muted" style="margin-top:10px;" id="notes">
        This dashboard will use fallbacks if some timestamps aren‚Äôt stored yet:
        <span class="mono">open‚Üífinalised</span> will use <span class="mono">finalisedAt</span> if present,
        otherwise it will fall back to <span class="mono">simgridGreenlitAt</span> (or <span class="mono">simgridSubmittedAt</span>) as a proxy.
      </div>
    </div>
  </div>

  <div class="toast" id="toast">Saved</div>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <script src="./firebase-init.js"></script>

  <script>
    const $ = (id) => document.getElementById(id);

    const toastEl = $("toast");
    function toast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      setTimeout(() => toastEl.classList.remove("show"), 2200);
    }

    function escapeHtml(s){
      return (s ?? "").toString()
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
    }

    function isFinalised(status){
      const s = (status || "").trim().toUpperCase();
      return s === "FINALISED" || s === "FINALIZED" || s === "CLOSED" || s === "RESOLVED";
    }

    function msFromTs(v){
      try{
        if (!v) return 0;
        if (v.toDate) return v.toDate().getTime();
        if (typeof v === "number") return v;
        const d = new Date(v);
        const ms = d.getTime();
        return isNaN(ms) ? 0 : ms;
      }catch{ return 0; }
    }

    function pickFirstMs(obj, keys){
      for (const k of keys){
        const ms = msFromTs(obj?.[k]);
        if (ms && ms > 0) return ms;
      }
      return 0;
    }

    function fmtDate(ms){
      if (!ms) return "‚Äî";
      return new Date(ms).toLocaleString();
    }

    function fmtDuration(ms){
      if (!ms || ms < 0) return "‚Äî";
      const sec = Math.floor(ms/1000);
      const min = Math.floor(sec/60);
      const hr = Math.floor(min/60);
      const day = Math.floor(hr/24);
      const remH = hr % 24;
      const remM = min % 60;
      if (day > 0) return `${day}d ${remH}h`;
      if (hr > 0) return `${hr}h ${remM}m`;
      if (min > 0) return `${min}m`;
      return `${sec}s`;
    }

    function normKey(s){ return (s || "").toString().trim().toLowerCase(); }
    function safeNameFromKey(key){
      const k = normKey(key);
      if (!k) return "";
      if (k.includes("@")){
        const nameGuess = (k.split("@")[0] || "").replace(/[._-]+/g, " ").trim();
        return nameGuess ? nameGuess.replace(/\b\w/g, c => c.toUpperCase()) : k;
      }
      return k;
    }

    function getCreatedMs(x){
      return pickFirstMs(x, ["timestamp","createdAt","created","submittedAt","openedAt","openAt"]);
    }
    function getFinalisedMs(x){
      const direct = pickFirstMs(x, [
        "finalisedAt","finalizedAt","closedAt","resolvedAt","finalisedTimestamp",
        "statusFinalisedAt","statusFinalizedAt","statusUpdatedAt","updatedAt","lastUpdatedAt"
      ]);
      if (direct) return direct;

      const proxy = pickFirstMs(x, [
        "simgridGreenlitAt","simgridSubmittedAt","simgridApprovedAt","simgridCompletedAt"
      ]);
      return proxy || 0;
    }
    function getPendingMs(x){
      return pickFirstMs(x, ["simgridPendingAt","simgridPendingGreenlitAt","pendingAt","pendingGreenlitAt","pendingSince"]);
    }
    function getSubmittedMs(x){
      return pickFirstMs(x, ["simgridSubmittedAt","simgridSubmittedOn","submittedToSimgridAt","submittedAtSimgrid","simgridCompletedAt"]);
    }

    function ticketUrl(id){ return `ticket.html?id=${encodeURIComponent(id || "")}`; }

    $("backHeadBtn").onclick = () => window.location.href = "https://ifwlowner.github.io/ACC-driver-classifier/headsteward.html";
    $("backClassifierBtn").onclick = () => window.location.href = "index.html";
    $("logoutBtn").onclick = async () => { await auth.signOut(); window.location.href = "admin.html"; };

    $("refreshBtn").onclick = () => loadDashboard();
    $("rangeDays").onchange = () => loadDashboard();

    // Charts
    let chartDaily = null;
    let chartPipeline = null;
    let chartTAT = null;
    let chartPendingSubmit = null;

    function destroyCharts(){
      for (const ch of [chartDaily, chartPipeline, chartTAT, chartPendingSubmit]){
        if (ch && typeof ch.destroy === "function") ch.destroy();
      }
      chartDaily = chartPipeline = chartTAT = chartPendingSubmit = null;
    }

    function median(arr){
      if (!arr.length) return null;
      const a = [...arr].sort((x,y)=>x-y);
      const mid = Math.floor(a.length/2);
      return (a.length % 2 === 0) ? (a[mid-1] + a[mid]) / 2 : a[mid];
    }
    function avg(arr){
      if (!arr.length) return null;
      return arr.reduce((s,v)=>s+v,0) / arr.length;
    }

    function bucketHoursToLabel(hours){
      if (hours < 2) return "<2h";
      if (hours < 6) return "2‚Äì6h";
      if (hours < 12) return "6‚Äì12h";
      if (hours < 24) return "12‚Äì24h";
      if (hours < 48) return "1‚Äì2d";
      if (hours < 96) return "2‚Äì4d";
      return "4d+";
    }

    function dayKey(ms){
      const d = new Date(ms);
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,"0");
      const dd = String(d.getDate()).padStart(2,"0");
      return `${y}-${m}-${dd}`;
    }

    function makeDateKeysBack(days){
      const keys = [];
      const now = new Date();
      for (let i = days-1; i >= 0; i--){
        const d = new Date(now.getFullYear(), now.getMonth(), now.getDate() - i);
        keys.push(dayKey(d.getTime()));
      }
      return keys;
    }

    function renderKPIs(kpis){
      $("kpiGrid").innerHTML = kpis.map(k => `
        <div class="kpi">
          <div class="label">${escapeHtml(k.label)}</div>
          <div class="value">${escapeHtml(k.value)}</div>
          <div class="sub">${escapeHtml(k.sub || "")}</div>
        </div>
      `).join("");
    }

    function renderOldestOpen(rows){
      const tbody = $("tbodyOldestOpen");
      tbody.innerHTML = "";
      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="8" class="muted">No open tickets found.</td></tr>`;
        return;
      }
      for (const r of rows){
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td class="mono">${escapeHtml(r.id)}</td>
            <td>${escapeHtml(r.status || "")}</td>
            <td>${escapeHtml(r.event || "")}</td>
            <td>${escapeHtml(r.accused || "")}</td>
            <td>${escapeHtml(r.reporter || "")}</td>
            <td><b>${escapeHtml(r.ageLabel)}</b></td>
            <td>${escapeHtml(fmtDate(r.createdMs))}</td>
            <td><a href="${ticketUrl(r.id)}" target="_blank" rel="noopener">Open</a></td>
          </tr>
        `);
      }
    }

    function renderPending(rows){
      const tbody = $("tbodyPending");
      tbody.innerHTML = "";
      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="6" class="muted">No pending green light tickets.</td></tr>`;
        return;
      }
      for (const r of rows){
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td class="mono">${escapeHtml(r.id)}</td>
            <td>${escapeHtml(fmtDate(r.pendingMs))}</td>
            <td><b>${escapeHtml(r.pendingAgeLabel)}</b></td>
            <td>${escapeHtml(r.event || "")}</td>
            <td>${escapeHtml(r.accused || "")}</td>
            <td><a href="${ticketUrl(r.id)}" target="_blank" rel="noopener">Open</a></td>
          </tr>
        `);
      }
    }

    function isStewardRole(roleVal){
      const r = (roleVal || "").toString().toLowerCase();
      return r.includes("steward");
    }

    function renderStewardActivity(rows){
      const tbody = $("tbodyStewardActivity");
      tbody.innerHTML = "";
      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="7" class="muted">No stewards found (admins.role must include ‚Äústeward‚Äù).</td></tr>`;
        return;
      }
      for (const r of rows){
        const active = (r.rangeComments + r.rangeReviews) > 0;
        const tag = active ? `<span class="tag ok">ACTIVE</span>` : `<span class="tag bad">INACTIVE</span>`;
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td><b>${escapeHtml(r.name || "‚Äî")}</b> ${tag}</td>
            <td class="mono">${escapeHtml(r.key)}</td>
            <td><b>${r.rangeComments}</b></td>
            <td><b>${r.rangeReviews}</b></td>
            <td>${escapeHtml(fmtDate(r.lastCommentMs))}</td>
            <td>${escapeHtml(fmtDate(r.lastReviewMs))}</td>
            <td><b>${escapeHtml(fmtDate(r.lastActionMs))}</b></td>
          </tr>
        `);
      }
    }

    function renderNaughty(rows, days){
      const tbody = $("tbodyNaughty");
      tbody.innerHTML = "";
      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="4" class="muted">No one on the naughty list üéâ</td></tr>`;
        return;
      }
      for (const r of rows){
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td><b>${escapeHtml(r.name || "‚Äî")}</b></td>
            <td class="mono">${escapeHtml(r.key)}</td>
            <td><b>${escapeHtml(fmtDate(r.lastActionMs))}</b></td>
            <td><span class="tag bad">No comment/review in last ${days}d</span></td>
          </tr>
        `);
      }
    }

    async function loadStewardAccountability({days, rangeStartMs, nowMs}){
      $("stewardActivityHint").textContent = "Loading‚Ä¶";
      $("naughtyHint").textContent = "Loading‚Ä¶";
      $("tbodyStewardActivity").innerHTML = `<tr><td colspan="7" class="muted">Loading‚Ä¶</td></tr>`;
      $("tbodyNaughty").innerHTML = `<tr><td colspan="4" class="muted">Loading‚Ä¶</td></tr>`;

      // 1) Load roster (this was failing due to rules)
      let stewards = [];
      try{
        const adminSnap = await db.collection("admins").limit(2000).get();
        const admins = adminSnap.docs.map(d => ({ id:d.id, ...(d.data()||{}) }));
        stewards = admins
          .filter(a => isStewardRole(a.role))
          .map(a => {
            const key = normKey(a.email || a.authorKey || a.key || a.id);
            const name = a.name || a.displayName || safeNameFromKey(key);
            return { key, name };
          })
          .filter(s => !!s.key);
      }catch(e){
        console.error("admins load failed", e);
        $("stewardActivityHint").textContent = "Admins roster blocked by Firestore rules (update rules to allow Head Steward/Owner read).";
        $("tbodyStewardActivity").innerHTML = `<tr><td colspan="7" class="muted">admins load failed: ${escapeHtml(e?.message || e)}</td></tr>`;
        $("tbodyNaughty").innerHTML = `<tr><td colspan="4" class="muted">Cannot build naughty list (no steward roster).</td></tr>`;
        $("naughtyHint").textContent = "Roster not available.";
        return;
      }

      const map = new Map();
      for (const s of stewards){
        map.set(s.key, {
          key: s.key,
          name: s.name,
          rangeComments: 0,
          rangeReviews: 0,
          lastCommentMs: 0,
          lastReviewMs: 0,
          lastActionMs: 0
        });
      }

      const rangeStartDate = new Date(rangeStartMs);
      const nowDate = new Date(nowMs);

      function apply(type, key, ms, inRange){
        const k = normKey(key);
        if (!k || !map.has(k) || !ms) return;
        const row = map.get(k);

        if (type === "comment"){
          row.lastCommentMs = Math.max(row.lastCommentMs || 0, ms);
          if (inRange) row.rangeComments++;
        } else if (type === "review"){
          row.lastReviewMs = Math.max(row.lastReviewMs || 0, ms);
          if (inRange) row.rangeReviews++;
        }
        row.lastActionMs = Math.max(row.lastActionMs || 0, ms);
      }

      // 2) Comments in range
      let commentsOk = true;
      try{
        const snap = await db.collectionGroup("steward_comments")
          .where("createdAt", ">=", rangeStartDate)
          .where("createdAt", "<=", nowDate)
          .orderBy("createdAt", "desc")
          .limit(5000)
          .get();

        snap.forEach(doc => {
          const d = doc.data() || {};
          apply("comment", d.authorKey, msFromTs(d.createdAt), true);
        });
      }catch(e){
        commentsOk = false;
        console.error("steward_comments query blocked", e);
      }

      // 3) Reviews in range (optional)
      let reviewsOk = true;
      try{
        const snap = await db.collectionGroup("reviews")
          .where("createdAt", ">=", rangeStartDate)
          .where("createdAt", "<=", nowDate)
          .orderBy("createdAt", "desc")
          .limit(5000)
          .get();

        snap.forEach(doc => {
          const d = doc.data() || {};
          apply("review", d.authorKey || d.reviewerKey, msFromTs(d.createdAt), true);
        });
      }catch(e){
        reviewsOk = false;
        console.error("reviews query blocked", e);
      }

      // 4) Best-effort last action overall
      try{
        const recent = await db.collectionGroup("steward_comments").orderBy("createdAt","desc").limit(2000).get();
        recent.forEach(doc => {
          const d = doc.data() || {};
          apply("comment", d.authorKey, msFromTs(d.createdAt), false);
        });
      }catch(e){ /* optional */ }

      try{
        const recent = await db.collectionGroup("reviews").orderBy("createdAt","desc").limit(2000).get();
        recent.forEach(doc => {
          const d = doc.data() || {};
          apply("review", d.authorKey || d.reviewerKey, msFromTs(d.createdAt), false);
        });
      }catch(e){ /* optional */ }

      const rows = Array.from(map.values()).sort((a,b) => {
        const aScore = a.rangeComments*3 + a.rangeReviews*2;
        const bScore = b.rangeComments*3 + b.rangeReviews*2;
        if (bScore !== aScore) return bScore - aScore;
        return (b.lastActionMs||0) - (a.lastActionMs||0);
      });

      const naughty = rows.filter(r => (r.rangeComments + r.rangeReviews) === 0);

      const bits = [
        `Selected range: last ${days} day(s)`,
        `Stewards: ${rows.length}`,
        `Inactive: ${naughty.length}`
      ];
      if (!commentsOk) bits.push("comments query blocked");
      if (!reviewsOk) bits.push("reviews query blocked");
      $("stewardActivityHint").textContent = bits.join(" ‚Ä¢ ");

      $("naughtyHint").textContent = `No comment/review detected in last ${days} day(s).`;

      renderStewardActivity(rows);
      renderNaughty(naughty, days);
    }

    async function loadDashboard(){
      try{
        destroyCharts();

        $("pipelineHint").textContent = "Loading‚Ä¶";
        $("createdFinalisedHint").textContent = "Loading‚Ä¶";
        $("tatHint").textContent = "Loading‚Ä¶";
        $("pendingToSubmitHint").textContent = "Loading‚Ä¶";

        renderKPIs([
          {label:"Tickets live (open)", value:"‚Äî", sub:"Loading‚Ä¶"},
          {label:"Oldest open ticket", value:"‚Äî", sub:"Loading‚Ä¶"},
          {label:"Avg age of open", value:"‚Äî", sub:"Loading‚Ä¶"},
          {label:"Pending green light", value:"‚Äî", sub:"Loading‚Ä¶"},
          {label:"Submitted to SimGrid", value:"‚Äî", sub:"Loading‚Ä¶"},
          {label:"Avg pending ‚Üí submit", value:"‚Äî", sub:"Loading‚Ä¶"}
        ]);

        const days = parseInt($("rangeDays").value, 10) || 7;
        const nowMs = Date.now();
        const rangeStartMs = nowMs - days*24*60*60*1000;
        const range7StartMs = nowMs - 7*24*60*60*1000;

        // Steward accountability runs in parallel (won‚Äôt break page)
        loadStewardAccountability({days, rangeStartMs, nowMs}).catch(e => {
          console.error("steward accountability failed", e);
          $("stewardActivityHint").textContent = "Steward section failed (see console).";
          $("tbodyStewardActivity").innerHTML = `<tr><td colspan="7" class="muted">Error: ${escapeHtml(e?.message || e)}</td></tr>`;
          $("tbodyNaughty").innerHTML = `<tr><td colspan="4" class="muted">‚Äî</td></tr>`;
        });

        const snap = await db.collection("tickets").limit(2000).get();
        const tickets = snap.docs.map(d => ({ id:d.id, ...(d.data()||{}) }));

        const openTickets = [];
        const finalisedTickets = [];
        const pendingGreen = [];
        const submittedSimgrid = [];

        const createdCounts = new Map();
        const finalisedCounts = new Map();

        const tatSamplesMs = [];
        const pendingToSubmitSamplesMs = [];
        let tatUsedProxyCount = 0;

        for (const t of tickets){
          const status = (t.status || "").toString();
          const createdMs = getCreatedMs(t);
          const finalMs = getFinalisedMs(t);
          const fin = isFinalised(status);

          if (!fin) openTickets.push({ ...t, createdMs });
          if (fin) finalisedTickets.push({ ...t, createdMs, finalMs });

          if (createdMs && createdMs >= rangeStartMs){
            const k = dayKey(createdMs);
            createdCounts.set(k, (createdCounts.get(k) || 0) + 1);
          }

          if (finalMs && finalMs >= rangeStartMs){
            const k = dayKey(finalMs);
            finalisedCounts.set(k, (finalisedCounts.get(k) || 0) + 1);
          }

          const pendingFlag = t.simgridPendingGreenlit === true;
          const greenlit = t.simgridGreenlit === true;
          const submitted = t.simgridSubmitted === true;

          if (pendingFlag && !greenlit && !submitted){
            const pendingMs = getPendingMs(t);
            pendingGreen.push({ ...t, pendingMs });
          }

          if (submitted){
            const submittedMs = getSubmittedMs(t);
            submittedSimgrid.push({ ...t, submittedMs });
          }

          if (createdMs && finalMs && finalMs >= range7StartMs){
            const directFinal = pickFirstMs(t, ["finalisedAt","finalizedAt","closedAt","resolvedAt","finalisedTimestamp","statusFinalisedAt","statusFinalizedAt"]);
            if (!directFinal) tatUsedProxyCount++;
            tatSamplesMs.push(finalMs - createdMs);
          }

          const pendingMs = getPendingMs(t);
          const submittedMs = getSubmittedMs(t);
          if (pendingMs && submittedMs && submittedMs >= rangeStartMs){
            pendingToSubmitSamplesMs.push(submittedMs - pendingMs);
          }
        }

        const openAgesMs = openTickets
          .map(t => t.createdMs ? (nowMs - t.createdMs) : null)
          .filter(x => x != null && x >= 0);

        openTickets.sort((a,b) => (a.createdMs||0) - (b.createdMs||0));
        const oldestOpen = openTickets[0];

        pendingGreen.sort((a,b) => (a.pendingMs||0) - (b.pendingMs||0));

        const submittedInRange = submittedSimgrid.filter(t => (t.submittedMs||0) >= rangeStartMs);

        const tatAvg = avg(tatSamplesMs);
        const tatMed = median(tatSamplesMs);
        const p2sAvg = avg(pendingToSubmitSamplesMs);
        const p2sMed = median(pendingToSubmitSamplesMs);

        renderKPIs([
          { label:"Tickets live (open)", value:String(openTickets.length), sub: openTickets.length ? "Status not finalised" : "No open tickets üéâ" },
          { label:"Oldest open ticket", value: oldestOpen?.createdMs ? fmtDuration(nowMs - oldestOpen.createdMs) : "‚Äî", sub: oldestOpen ? `Ticket: ${oldestOpen.id}` : "‚Äî" },
          { label:"Avg age of open", value: openAgesMs.length ? fmtDuration(avg(openAgesMs)) : "‚Äî", sub: openAgesMs.length ? `Median: ${fmtDuration(median(openAgesMs))}` : "‚Äî" },
          { label:"Pending green light", value:String(pendingGreen.length), sub: pendingGreen.length ? `Oldest: ${fmtDuration(nowMs - (pendingGreen[0].pendingMs||nowMs))}` : "None pending" },
          { label:"Submitted to SimGrid", value:String(submittedInRange.length), sub: `In last ${days} day(s)` },
          { label:"Avg pending ‚Üí submit", value: p2sAvg ? fmtDuration(p2sAvg) : "‚Äî", sub: p2sMed ? `Median: ${fmtDuration(p2sMed)}` : "‚Äî" }
        ]);

        renderOldestOpen(openTickets.slice(0, 12).map(t => ({
          id: t.id,
          status: t.status || "",
          event: t.event || "",
          accused: t.accused || "",
          reporter: t.reporter || "",
          createdMs: t.createdMs || 0,
          ageLabel: t.createdMs ? fmtDuration(nowMs - t.createdMs) : "‚Äî"
        })));

        renderPending(pendingGreen.slice(0, 12).map(t => ({
          id: t.id,
          pendingMs: t.pendingMs || 0,
          pendingAgeLabel: t.pendingMs ? fmtDuration(nowMs - t.pendingMs) : "‚Äî",
          event: t.event || "",
          accused: t.accused || ""
        })));

        // Charts
        const dateKeys = makeDateKeysBack(Math.min(days, 30));
        const createdSeries = dateKeys.map(k => createdCounts.get(k) || 0);
        const finalisedSeries = dateKeys.map(k => finalisedCounts.get(k) || 0);

        $("createdFinalisedHint").textContent = `Last ${Math.min(days,30)} day(s)`;

        chartDaily = new Chart($("chartDaily"), {
          type: "line",
          data: { labels: dateKeys, datasets: [
            { label: "Created", data: createdSeries, tension: 0.3 },
            { label: "Finalised", data: finalisedSeries, tension: 0.3 }
          ]},
          options: { responsive: true, plugins: { legend: { display: true } }, scales: { y: { beginAtZero: true, ticks: { precision: 0 } } } }
        });

        const greenlitNotSubmitted = finalisedTickets.filter(t => (t.simgridGreenlit === true && t.simgridSubmitted !== true));
        $("pipelineHint").textContent = "Counts are current; submitted is in selected range";

        chartPipeline = new Chart($("chartPipeline"), {
          type: "bar",
          data: { labels: ["Open", "Finalised", "Greenlit", "Pending", `Submitted (${days}d)`], datasets: [{
            label: "Tickets",
            data: [openTickets.length, finalisedTickets.length, greenlitNotSubmitted.length, pendingGreen.length, submittedInRange.length]
          }]},
          options: { responsive: true, plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true, ticks: { precision: 0 } } } }
        });

        const tatBuckets = new Map([["<2h",0],["2‚Äì6h",0],["6‚Äì12h",0],["12‚Äì24h",0],["1‚Äì2d",0],["2‚Äì4d",0],["4d+",0]]);
        for (const ms of tatSamplesMs){
          const hours = ms / (1000*60*60);
          const label = bucketHoursToLabel(hours);
          tatBuckets.set(label, (tatBuckets.get(label)||0) + 1);
        }
        const tatLabels = Array.from(tatBuckets.keys());
        const tatValues = tatLabels.map(k => tatBuckets.get(k) || 0);

        $("tatHint").textContent = !tatSamplesMs.length
          ? "Last 7 days ‚Ä¢ No usable timestamps found (need created + finalised/greenlit/submitted timestamps)"
          : `Last 7 days ‚Ä¢ Avg: ${fmtDuration(tatAvg)} ‚Ä¢ Median: ${fmtDuration(tatMed)}`
            + (tatUsedProxyCount ? ` ‚Ä¢ Proxy used: ${tatUsedProxyCount}/${tatSamplesMs.length}` : "");

        chartTAT = new Chart($("chartTAT"), {
          type: "bar",
          data: { labels: tatLabels, datasets: [{ label: "Tickets", data: tatValues }] },
          options: { responsive: true, plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true, ticks: { precision: 0 } } } }
        });

        const p2sBuckets = new Map([["<2h",0],["2‚Äì6h",0],["6‚Äì12h",0],["12‚Äì24h",0],["1‚Äì2d",0],["2‚Äì4d",0],["4d+",0]]);
        for (const ms of pendingToSubmitSamplesMs){
          const hours = ms / (1000*60*60);
          const label = bucketHoursToLabel(hours);
          p2sBuckets.set(label, (p2sBuckets.get(label)||0) + 1);
        }
        const p2sLabels = Array.from(p2sBuckets.keys());
        const p2sValues = p2sLabels.map(k => p2sBuckets.get(k) || 0);

        $("pendingToSubmitHint").textContent = pendingToSubmitSamplesMs.length
          ? `Last ${days} days ‚Ä¢ Avg: ${fmtDuration(p2sAvg)} ‚Ä¢ Median: ${fmtDuration(p2sMed)}`
          : `Last ${days} days ‚Ä¢ No samples (need BOTH pending timestamp + submitted timestamp)`;

        chartPendingSubmit = new Chart($("chartPendingSubmit"), {
          type: "bar",
          data: { labels: p2sLabels, datasets: [{ label: "Tickets", data: p2sValues }] },
          options: { responsive: true, plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true, ticks: { precision: 0 } } } }
        });

        toast("Dashboard loaded ‚úÖ");
      }catch(e){
        console.error(e);
        toast("Load failed:\n" + (e?.message || e));
      }
    }

    async function waitForFirebaseReady(maxMs = 8000){
      const start = Date.now();
      while (Date.now() - start < maxMs){
        if (typeof auth !== "undefined" && typeof db !== "undefined" && auth && db) return true;
        await new Promise(r => setTimeout(r, 80));
      }
      return false;
    }

    (async () => {
      const ok = await waitForFirebaseReady();
      if (!ok){
        toast("Firebase not ready.\nCheck firebase-init.js path + console.");
        return;
      }

      auth.onAuthStateChanged(async (user) => {
        try{
          if (!user){ window.location.href = "admin.html"; return; }

          const email = (user.email || "").toLowerCase().trim();
          const adminSnap = await db.collection("admins").doc(email).get();
          if (!adminSnap.exists){ await auth.signOut(); window.location.href = "admin.html"; return; }

          const data = adminSnap.data() || {};
          const roleText = String(data.role || "").toLowerCase();
          const isOwner = roleText.includes("owner") || data.owner === true;

          if (!isOwner){
            toast("Access denied (owner only).");
            await auth.signOut();
            window.location.href = "admin.html";
            return;
          }

          $("permPill").textContent = "Permissions: Owner";

          const nameGuess = (email.split("@")[0] || "").replace(/[._-]+/g, " ").trim();
          const niceName = nameGuess ? nameGuess.replace(/\b\w/g, c => c.toUpperCase()) : "Owner";

          $("welcomeLine").textContent = `Welcome, ${niceName}. This page shows live ops stats + performance.`;
          $("who").textContent = `Signed in as: ${email} | role: ${data.role || "admin"}`;

          await loadDashboard();
        }catch(e){
          console.error(e);
          toast("Auth/load error:\n" + (e?.message || e));
        }
      });
    })();
  </script>
</body>
</html>
