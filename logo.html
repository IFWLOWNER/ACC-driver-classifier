<!DOCTYPE html>
<html>
<head>
  <title>IFWL Owner â€” Overview Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    body{
      font-family: Arial, sans-serif;
      margin:0;
      background:
        linear-gradient(rgba(2,6,23,0.72), rgba(2,6,23,0.72)),
        url("./ifwl_bg.webp");
      background-size:cover;
      background-position:center;
      background-attachment:fixed;
      color:#111827;
    }

    header{
      padding:14px 18px;
      background:#111827;
      color:#fff;
    }
    .headerInner{
      max-width:1400px;
      margin:0 auto;
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
    }

    .brand{
      display:flex;
      gap:12px;
      align-items:flex-start;
      min-width:0;
    }
    .brand img{
      width:38px;height:38px;object-fit:contain;margin-top:2px;flex:0 0 auto;
      filter: drop-shadow(0 1px 1px rgba(0,0,0,0.25));
    }
    .brandText{min-width:0;}
    .brandTitle{font-weight:900; font-size:18px;}
    header .small{font-size:12px;opacity:0.85;margin-top:4px;line-height:1.2;word-break:break-word;}
    .welcomeLine{font-size:12px;opacity:0.95;margin-top:6px;line-height:1.25;}

    .wrap{
      padding:14px;
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
      max-width:1400px;
      margin:0 auto;
    }

    .card{
      background:rgba(255,255,255,0.92);
      border:1px solid rgba(229,231,235,0.95);
      border-radius:14px;
      padding:12px;
      box-shadow:0 10px 28px rgba(0,0,0,0.18);
    }

    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .rowBetween{display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
    .title{font-weight:900; font-size:16px; margin:0;}
    .muted{color:#6b7280; font-size:12px;}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, monospace;}

    button{padding:10px 12px; border:1px solid #d1d5db; border-radius:12px; background:#fff; cursor:pointer;}
    button.primary{background:#111827;color:#fff;border-color:#111827;}
    button:disabled{opacity:0.6;cursor:not-allowed;}

    select, input{
      padding:10px; border:1px solid #d1d5db; border-radius:12px;
      box-sizing:border-box; font-size:16px; background:#fff;
    }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:4px 10px; border-radius:999px;
      border:1px solid #e5e7eb; background:#fff;
      font-size:12px; color:#111827; white-space:nowrap;
    }
    .pill strong{font-weight:900;}

    .kpiGrid{
      display:grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap:12px;
      margin-top:10px;
    }
    .kpi{
      background:#fff;
      border:1px solid #e5e7eb;
      border-radius:14px;
      padding:12px;
      box-shadow:0 8px 18px rgba(0,0,0,0.08);
      min-height:88px;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
    }
    .kpi .label{font-size:12px; color:#6b7280; font-weight:800;}
    .kpi .value{font-size:22px; font-weight:900; margin-top:6px;}
    .kpi .sub{font-size:12px; color:#6b7280; margin-top:6px; line-height:1.25;}

    .grid2{
      display:grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap:12px;
    }
    .gridCharts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:12px;
    }

    .chartCard{
      background:#fff;
      border:1px solid #e5e7eb;
      border-radius:14px;
      padding:12px;
      box-shadow:0 8px 18px rgba(0,0,0,0.08);
    }
    .chartTitle{font-weight:900; font-size:13px;}
    canvas{width:100% !important; height:280px !important;}

    .tableWrap{
      overflow:auto;
      border:1px solid #e5e7eb;
      border-radius:12px;
      background:#fff;
      margin-top:10px;
    }
    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      min-width:980px;
    }
    th, td{
      padding:10px;
      border-bottom:1px solid #f3f4f6;
      font-size:13px;
      text-align:left;
      vertical-align:top;
    }
    th{
      position:sticky;
      top:0;
      background:#f9fafb;
      z-index:2;
      font-size:12px;
      color:#111827;
      border-bottom:1px solid #e5e7eb;
      white-space:nowrap;
    }
    tr:last-child td{border-bottom:0;}

    .tag{
      display:inline-block;
      padding:3px 10px;
      border-radius:999px;
      border:1px solid #e5e7eb;
      background:#fff;
      font-size:12px;
      font-weight:900;
      white-space:nowrap;
    }
    .tag.ok{border-color:#86efac;background:#ecfdf5;color:#065f46;}
    .tag.bad{border-color:#fca5a5;background:#fef2f2;color:#991b1b;}
    .tag.neutral{border-color:#d1d5db;background:#f9fafb;color:#111827;}

    a{color:#111827;}
    a:hover{opacity:0.85;}

    .toast{
      position:fixed; right:16px; bottom:16px;
      background:#111827; color:#fff;
      padding:10px 12px; border-radius:12px;
      opacity:0; transform: translateY(8px);
      transition: all .18s ease;
      z-index:9999;
      max-width: min(520px, calc(100vw - 32px));
      white-space: pre-wrap;
    }
    .toast.show{opacity:1; transform: translateY(0);}

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ NEW: Steward Input audit (Owner) â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .auditBox{
      border:1px solid #e5e7eb;
      border-radius:14px;
      padding:12px;
      background:rgba(250,250,250,0.92);
      margin-top:12px;
    }
    .auditTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .auditTitle{
      font-weight:900;
      font-size:14px;
      margin:0;
    }
    .auditMeta{
      margin-top:6px;
      font-size:12px;
      color:#6b7280;
      line-height:1.25;
    }
    .auditTableWrap{
      margin-top:10px;
      overflow:auto;
      border:1px solid #e5e7eb;
      border-radius:12px;
      background:#fff;
    }
    table.auditTable{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      min-width:860px;
    }
    .auditTable th, .auditTable td{
      padding:10px;
      border-bottom:1px solid #f3f4f6;
      font-size:13px;
      text-align:left;
      vertical-align:top;
      white-space:nowrap;
    }
    .auditTable th{
      position:sticky;
      top:0;
      background:#f9fafb;
      z-index:2;
      font-size:12px;
      color:#111827;
      border-bottom:1px solid #e5e7eb;
    }
    .auditTable tr:last-child td{border-bottom:0;}

    /* row highlight for "done none of that" */
    .auditTable tr.inactive td{
      background:#fef2f2;
      color:#991b1b;
      font-weight:900;
    }
    .auditTable tr.inactive td .mutedInline{
      color:#991b1b;
      font-weight:900;
      opacity:0.9;
    }

    @media (max-width: 1200px){
      .kpiGrid{grid-template-columns: repeat(3, minmax(0, 1fr));}
      .grid2{grid-template-columns:1fr;}
    }
    @media (max-width: 980px){
      body{background-attachment:scroll;}
      .headerInner{flex-direction:column; align-items:stretch;}
      header .row{width:100%;}
      header button{width:100%;}
      .kpiGrid{grid-template-columns: repeat(2, minmax(0, 1fr));}
      .gridCharts{grid-template-columns:1fr;}
      canvas{height:260px !important;}
      table{min-width:860px;}
      table.auditTable{min-width:860px;}
    }
  </style>
</head>

<body>
  <header>
    <div class="headerInner">
      <div class="brand">
        <img src="./ifwl_logo.png" alt="IFWL logo">
        <div class="brandText">
          <div class="brandTitle">IFWL Owner â€” Overview Dashboard</div>
          <div class="welcomeLine" id="welcomeLine">Loading your profileâ€¦</div>
          <div class="small" id="who">Loadingâ€¦</div>
        </div>
      </div>

      <div class="row">
        <button id="backHeadBtn">Back to Head Stewards Dashboard</button>
        <button id="backClassifierBtn">Back to Classifier</button>
        <button id="logoutBtn">Sign out</button>
      </div>
    </div>
  </header>

  <div class="wrap">
    <div class="card">
      <div class="rowBetween">
        <div>
          <div class="title">Operations Snapshot</div>
          <div class="muted">Live + last 7 days performance (turnaround, pending, SimGrid throughput)</div>
        </div>
        <div class="row">
          <span class="pill" id="permPill">Permissions: â€¦</span>
          <select id="rangeDays">
            <option value="7" selected>Last 7 days</option>
            <option value="14">Last 14 days</option>
            <option value="30">Last 30 days</option>
          </select>
          <button id="refreshBtn" class="primary">Refresh</button>
        </div>
      </div>

      <!-- NEW: Steward Input (Last 7 Days) + roster inactive highlights -->
      <div class="auditBox" aria-label="Steward input audit">
  <div class="auditTop">
    <div>
      <div class="auditTitle">Steward Activity (Last 7 Days) â€” Accountability Overview</div>
      <div class="muted" style="margin-top:4px;">
        Note: Dave is exempt unless explicitly requested to review deadlock cases.
      </div>
    </div>

    <div class="row">
      <label class="muted" style="display:flex;align-items:center;gap:8px;">
        <input type="checkbox" id="showOnlyInactive">
        Show only inactive
      </label>
      <button id="refreshAuditBtn">Refresh</button>
    </div>
  </div>


        <div class="auditMeta" id="auditMeta">Loadingâ€¦</div>

        <div class="auditTableWrap" id="auditTableWrap" style="display:none;">
          <table class="auditTable" aria-label="Steward input table">
            <thead>
              <tr>
                <th>Steward</th>
                <th>Comments (7d)</th>
                <th>Reviews (7d)</th>
                <th>Tickets Touched (7d)</th>
                <th>Last Active</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody id="auditTbody"></tbody>
          </table>
        </div>

        <div class="muted" style="margin-top:8px;">
          Counts include <span class="mono">collectionGroup</span> queries across all tickets. Inactive stewards are highlighted red.
        </div>
      </div>

      <div class="kpiGrid" id="kpiGrid"></div>

      <div class="gridCharts">
        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Tickets created vs finalised (daily)</div>
            <span class="muted" id="createdFinalisedHint">â€”</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartDaily"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Ticket pipeline breakdown</div>
            <span class="muted" id="pipelineHint">â€”</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartPipeline"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Turnaround time distribution (open â†’ finalised)</div>
            <span class="muted" id="tatHint">â€”</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartTAT"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Pending â†’ Submitted to SimGrid (time)</div>
            <span class="muted" id="pendingToSubmitHint">â€”</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartPendingSubmit"></canvas></div>
        </div>
      </div>

      <div class="grid2" style="margin-top:12px;">
        <div class="chartCard">
          <div class="rowBetween">
            <div>
              <div class="chartTitle">Oldest open tickets</div>
              <div class="muted">Helps identify backlog + long-running cases</div>
            </div>
          </div>
          <div class="tableWrap">
            <table>
              <thead>
                <tr>
                  <th>Ticket</th>
                  <th>Status</th>
                  <th>Event</th>
                  <th>Accused</th>
                  <th>Reporter</th>
                  <th>Age</th>
                  <th>Created</th>
                  <th>Open</th>
                </tr>
              </thead>
              <tbody id="tbodyOldestOpen"></tbody>
            </table>
          </div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div>
              <div class="chartTitle">Oldest pending green light</div>
              <div class="muted">Tickets waiting for Head Steward confirmation</div>
            </div>
          </div>
          <div class="tableWrap">
            <table>
              <thead>
                <tr>
                  <th>Ticket</th>
                  <th>Pending since</th>
                  <th>Pending age</th>
                  <th>Event</th>
                  <th>Accused</th>
                  <th>Open</th>
                </tr>
              </thead>
              <tbody id="tbodyPending"></tbody>
            </table>
          </div>
        </div>
      </div>

      <div class="muted" style="margin-top:10px;" id="notes">
        This dashboard will use fallbacks if some timestamps arenâ€™t stored yet:
        <span class="mono">openâ†’finalised</span> will use <span class="mono">finalisedAt</span> if present,
        otherwise it will fall back to <span class="mono">simgridGreenlitAt</span> (or <span class="mono">simgridSubmittedAt</span>) as a proxy.
      </div>
    </div>
  </div>

  <div class="toast" id="toast">Saved</div>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <script src="./firebase-init.js"></script>

  <script>
    const $ = (id) => document.getElementById(id);

    const toastEl = $("toast");
    function toast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      setTimeout(() => toastEl.classList.remove("show"), 2200);
    }

    // Show JS errors as toast so breakages are obvious
    window.addEventListener("error", (e) => {
      const msg = (e?.message || "Unknown JS error") + (e?.filename ? `\n${e.filename}:${e.lineno || 0}` : "");
      console.error("JS error:", e);
      toast("JS ERROR:\n" + msg);
    });
    window.addEventListener("unhandledrejection", (e) => {
      console.error("Promise rejection:", e);
      toast("PROMISE ERROR:\n" + (e?.reason?.message || e?.reason || "Unknown"));
    });

    function escapeHtml(s){
      return (s ?? "").toString()
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
    }

    function isFinalised(status){
      const s = (status || "").trim().toUpperCase();
      return s === "FINALISED" || s === "FINALIZED" || s === "CLOSED" || s === "RESOLVED";
    }

    function msFromTs(v){
      try{
        if (!v) return 0;
        if (v.toDate) return v.toDate().getTime();
        if (typeof v === "number") return v;
        const d = new Date(v);
        const ms = d.getTime();
        return isNaN(ms) ? 0 : ms;
      }catch{ return 0; }
    }

    function pickFirstMs(obj, keys){
      for (const k of keys){
        const ms = msFromTs(obj?.[k]);
        if (ms && ms > 0) return ms;
      }
      return 0;
    }

    function fmtDate(ms){
      if (!ms) return "â€”";
      return new Date(ms).toLocaleString();
    }

    function fmtDuration(ms){
      if (!ms || ms < 0) return "â€”";
      const sec = Math.floor(ms/1000);
      const min = Math.floor(sec/60);
      const hr = Math.floor(min/60);
      const day = Math.floor(hr/24);
      const remH = hr % 24;
      const remM = min % 60;
      if (day > 0) return `${day}d ${remH}h`;
      if (hr > 0) return `${hr}h ${remM}m`;
      if (min > 0) return `${min}m`;
      return `${sec}s`;
    }

    // Best-effort "created" timestamp:
    function getCreatedMs(x){
      return pickFirstMs(x, [
        "timestamp","createdAt","created","submittedAt","openedAt","openAt"
      ]);
    }

    // Best-effort "finalised" timestamp:
    function getFinalisedMs(x){
      const direct = pickFirstMs(x, [
        "finalisedAt","finalizedAt","closedAt","resolvedAt","finalisedTimestamp",
        "statusFinalisedAt","statusFinalizedAt","statusUpdatedAt","updatedAt","lastUpdatedAt"
      ]);
      if (direct) return direct;

      const proxy = pickFirstMs(x, [
        "simgridGreenlitAt","simgridSubmittedAt","simgridApprovedAt","simgridCompletedAt"
      ]);
      return proxy || 0;
    }

    function getPendingMs(x){
      return pickFirstMs(x, [
        "simgridPendingAt","simgridPendingGreenlitAt","pendingAt","pendingGreenlitAt","pendingSince"
      ]);
    }
    function getSubmittedMs(x){
      return pickFirstMs(x, [
        "simgridSubmittedAt","simgridSubmittedOn","submittedToSimgridAt","submittedAtSimgrid","simgridCompletedAt"
      ]);
    }

    function ticketUrl(id){ return `ticket.html?id=${encodeURIComponent(id || "")}`; }

    // ---------------------------
    // Auth / role gating
    // ---------------------------
    $("backHeadBtn").onclick = () => window.location.href = "https://ifwlowner.github.io/ACC-driver-classifier/headsteward.html";
    $("backClassifierBtn").onclick = () => window.location.href = "index.html";
    $("logoutBtn").onclick = async () => { await auth.signOut(); window.location.href = "admin.html"; };

    $("refreshBtn").onclick = () => loadDashboard();
    $("rangeDays").onchange = () => loadDashboard();

    // NEW: audit refresh
    $("refreshAuditBtn").onclick = () => loadStewardAudit7d();
    $("showOnlyInactive").onchange = () => renderAuditTableFromCache();

    // ---------------------------
    // Charts
    // ---------------------------
    let chartDaily = null;
    let chartPipeline = null;
    let chartTAT = null;
    let chartPendingSubmit = null;

    function destroyCharts(){
      for (const ch of [chartDaily, chartPipeline, chartTAT, chartPendingSubmit]){
        if (ch && typeof ch.destroy === "function") ch.destroy();
      }
      chartDaily = chartPipeline = chartTAT = chartPendingSubmit = null;
    }

    // ---------------------------
    // Stats helpers
    // ---------------------------
    function median(arr){
      if (!arr.length) return null;
      const a = [...arr].sort((x,y)=>x-y);
      const mid = Math.floor(a.length/2);
      return (a.length % 2 === 0) ? (a[mid-1] + a[mid]) / 2 : a[mid];
    }
    function avg(arr){
      if (!arr.length) return null;
      return arr.reduce((s,v)=>s+v,0) / arr.length;
    }

    function bucketHoursToLabel(hours){
      if (hours < 2) return "<2h";
      if (hours < 6) return "2â€“6h";
      if (hours < 12) return "6â€“12h";
      if (hours < 24) return "12â€“24h";
      if (hours < 48) return "1â€“2d";
      if (hours < 96) return "2â€“4d";
      return "4d+";
    }

    function dayKey(ms){
      const d = new Date(ms);
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,"0");
      const dd = String(d.getDate()).padStart(2,"0");
      return `${y}-${m}-${dd}`;
    }

    function makeDateKeysBack(days){
      const keys = [];
      const now = new Date();
      for (let i = days-1; i >= 0; i--){
        const d = new Date(now.getFullYear(), now.getMonth(), now.getDate() - i);
        keys.push(dayKey(d.getTime()));
      }
      return keys;
    }

    function renderKPIs(kpis){
      $("kpiGrid").innerHTML = kpis.map(k => `
        <div class="kpi">
          <div class="label">${escapeHtml(k.label)}</div>
          <div class="value">${escapeHtml(k.value)}</div>
          <div class="sub">${escapeHtml(k.sub || "")}</div>
        </div>
      `).join("");
    }

    function renderOldestOpen(rows){
      const tbody = $("tbodyOldestOpen");
      tbody.innerHTML = "";
      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="8" class="muted">No open tickets found.</td></tr>`;
        return;
      }
      for (const r of rows){
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td class="mono">${escapeHtml(r.id)}</td>
            <td>${escapeHtml(r.status || "")}</td>
            <td>${escapeHtml(r.event || "")}</td>
            <td>${escapeHtml(r.accused || "")}</td>
            <td>${escapeHtml(r.reporter || "")}</td>
            <td><b>${escapeHtml(r.ageLabel)}</b></td>
            <td>${escapeHtml(fmtDate(r.createdMs))}</td>
            <td><a href="${ticketUrl(r.id)}" target="_blank" rel="noopener">Open</a></td>
          </tr>
        `);
      }
    }

    function renderPending(rows){
      const tbody = $("tbodyPending");
      tbody.innerHTML = "";
      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="6" class="muted">No pending green light tickets.</td></tr>`;
        return;
      }
      for (const r of rows){
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td class="mono">${escapeHtml(r.id)}</td>
            <td>${escapeHtml(fmtDate(r.pendingMs))}</td>
            <td><b>${escapeHtml(r.pendingAgeLabel)}</b></td>
            <td>${escapeHtml(r.event || "")}</td>
            <td>${escapeHtml(r.accused || "")}</td>
            <td><a href="${ticketUrl(r.id)}" target="_blank" rel="noopener">Open</a></td>
          </tr>
        `);
      }
    }

    // ---------------------------
    // NEW: Steward audit (Owner) â€” cached rows for filtering
    // ---------------------------
    let auditRowsCache = []; // {email, comments, reviews, ticketsTouched, lastActiveMs, inactive, statusLabel}
    function safeKey(email){ return (email || "").replaceAll("/", "_").replaceAll("\\", "_").trim(); }

    function roleLooksLikeSteward(adminDoc){
      const role = String(adminDoc?.role || "").toLowerCase();
      // include stewards + head stewards + owners (theyâ€™re still part of accountability)
      return (
        role.includes("steward") ||
        role.includes("head") ||
        adminDoc?.headsteward === true ||
        adminDoc?.owner === true
      );
    }

    function ticketIdFromDocRef(docRef){
      try{ return docRef?.parent?.parent?.id || ""; }catch{ return ""; }
    }

    function renderAuditTableFromCache(){
      const metaEl = $("auditMeta");
      const wrapEl = $("auditTableWrap");
      const bodyEl = $("auditTbody");
      const onlyInactive = $("showOnlyInactive").checked === true;

      bodyEl.innerHTML = "";

      const rows = onlyInactive
        ? auditRowsCache.filter(r => r.inactive)
        : [...auditRowsCache];

      if (!rows.length){
        wrapEl.style.display = "none";
        metaEl.textContent = onlyInactive
          ? "No inactive stewards in this window âœ…"
          : "No steward roster/activity data to display.";
        return;
      }

      for (const r of rows){
        const tr = document.createElement("tr");
        if (r.inactive) tr.className = "inactive";

        const last = r.lastActiveMs ? new Date(r.lastActiveMs).toLocaleString() : "â€”";
        const statusTxt = r.inactive ? "Non-compliant â€” No steward actions logged" : "OK";

        tr.innerHTML = `
          <td class="mono">${escapeHtml(r.email)}</td>
          <td><b>${r.comments}</b></td>
          <td><b>${r.reviews}</b></td>
          <td><b>${r.ticketsTouched}</b></td>
          <td>${escapeHtml(last)}</td>
          <td>${escapeHtml(statusTxt)}</td>
        `;
        bodyEl.appendChild(tr);
      }

      wrapEl.style.display = "block";
    }

    async function loadStewardAudit7d(){
      const metaEl = $("auditMeta");
      const wrapEl = $("auditTableWrap");
      const bodyEl = $("auditTbody");

      wrapEl.style.display = "none";
      bodyEl.innerHTML = "";
      metaEl.textContent = "Loadingâ€¦";

      auditRowsCache = [];

      const now = Date.now();
      const sinceMs = now - (7 * 24 * 60 * 60 * 1000);
      const since = firebase.firestore.Timestamp.fromDate(new Date(sinceMs));

      // Step 1: roster (admins)
      let rosterEmails = [];
      try{
        const adminsSnap = await db.collection("admins").get();
        rosterEmails = adminsSnap.docs
          .map(d => ({ id: d.id, data: d.data() || {} }))
          .filter(x => roleLooksLikeSteward(x.data))
          .map(x => String(x.id || "").toLowerCase().trim())
          .filter(Boolean);
      }catch(e){
        console.error("Admins roster read failed:", e);
        metaEl.textContent = "Audit failed: cannot read /admins roster. This is a Firestore rules permission issue for /admins (Owner/Head Stewards must be allowed). Check console for exact error.";
        return;
      }

      // Stats map: key(email) -> stats
      const m = new Map();
      function getOrCreate(email){
        const k = safeKey(email || "unknown") || "unknown";
        if (!m.has(k)){
          m.set(k, { email: email || "unknown", comments:0, reviews:0, tickets:new Set(), lastActiveMs:0 });
        }
        return m.get(k);
      }

      let commentDocs = 0;
      let reviewDocs = 0;

      try{
        // Comments in last 7 days (collectionGroup)
        const commentsSnap = await db
          .collectionGroup("steward_comments")
          .where("createdAt", ">=", since)
          .get();

        commentDocs = commentsSnap.size;

        commentsSnap.forEach(doc => {
          const d = doc.data() || {};
          const ts = d.createdAt && d.createdAt.toDate ? d.createdAt.toDate() : null;
          if (!ts) return;

          // Your DB shows authorKey is the email string (good)
          const author = String(d.authorKey || d.stewardEmail || "unknown").trim() || "unknown";
          const s = getOrCreate(author);
          s.comments += 1;

          const ticketId = ticketIdFromDocRef(doc.ref);
          if (ticketId) s.tickets.add(ticketId);

          const tms = ts.getTime();
          if (tms > s.lastActiveMs) s.lastActiveMs = tms;
        });

        // Reviews in last 7 days (collectionGroup)
        // NOTE: your Head Steward page uses submittedAt. Keep the same.
        const reviewsSnap = await db
          .collectionGroup("reviews")
          .where("submittedAt", ">=", since)
          .get();

        reviewDocs = reviewsSnap.size;

        reviewsSnap.forEach(doc => {
          const d = doc.data() || {};
          const ts = d.submittedAt && d.submittedAt.toDate ? d.submittedAt.toDate() : null;
          if (!ts) return;

          const author = String(d.stewardEmail || d.authorKey || "unknown").trim() || "unknown";
          const s = getOrCreate(author);
          s.reviews += 1;

          const ticketId = ticketIdFromDocRef(doc.ref);
          if (ticketId) s.tickets.add(ticketId);

          const tms = ts.getTime();
          if (tms > s.lastActiveMs) s.lastActiveMs = tms;
        });

      }catch(e){
        console.error("Steward audit collectionGroup failed:", e);
        metaEl.textContent =
          "Audit failed. This is either:\n" +
          "â€¢ Firestore rules denying collectionGroup reads for steward_comments/reviews\n" +
          "â€¢ Or an index requirement.\n" +
          "Open console for the exact Firebase error (it often includes a 'create index' link).";
        return;
      }

      // Step 3: build rows for ALL roster members (including zero activity) and highlight inactive
      const rosterRows = rosterEmails.map(email => {
        const k = safeKey(email) || "unknown";
        const existing = m.get(k);
        const comments = existing ? existing.comments : 0;
        const reviews = existing ? existing.reviews : 0;
        const ticketsTouched = existing ? existing.tickets.size : 0;
        const lastActiveMs = existing ? existing.lastActiveMs : 0;
        const inactive = (comments + reviews) === 0;
        return { email, comments, reviews, ticketsTouched, lastActiveMs, inactive };
      });

      // Sort: inactive first (so failures are obvious), then by total activity desc, then last active desc
      rosterRows.sort((a,b) => {
        if (a.inactive !== b.inactive) return a.inactive ? -1 : 1;
        const at = (a.comments + a.reviews);
        const bt = (b.comments + b.reviews);
        if (bt !== at) return bt - at;
        return (b.lastActiveMs || 0) - (a.lastActiveMs || 0);
      });

      auditRowsCache = rosterRows;

      const inactiveCount = rosterRows.filter(r => r.inactive).length;
      metaEl.textContent =
        `Loaded. Roster: ${rosterEmails.length} â€¢ Inactive: ${inactiveCount} â€¢ Comments scanned: ${commentDocs} â€¢ Reviews scanned: ${reviewDocs} â€¢ Window: last 7 days.`;

      renderAuditTableFromCache();
    }

    // ---------------------------
    // Main load
    // ---------------------------
    async function loadDashboard(){
      try{
        destroyCharts();

        $("pipelineHint").textContent = "Loadingâ€¦";
        $("createdFinalisedHint").textContent = "Loadingâ€¦";
        $("tatHint").textContent = "Loadingâ€¦";
        $("pendingToSubmitHint").textContent = "Loadingâ€¦";

        renderKPIs([
          {label:"Tickets live (open)", value:"â€”", sub:"Loadingâ€¦"},
          {label:"Oldest open ticket", value:"â€”", sub:"Loadingâ€¦"},
          {label:"Avg age of open", value:"â€”", sub:"Loadingâ€¦"},
          {label:"Pending green light", value:"â€”", sub:"Loadingâ€¦"},
          {label:"Submitted to SimGrid", value:"â€”", sub:"Loadingâ€¦"},
          {label:"Avg pending â†’ submit", value:"â€”", sub:"Loadingâ€¦"}
        ]);

        const days = parseInt($("rangeDays").value, 10) || 7;
        const nowMs = Date.now();
        const rangeStartMs = nowMs - days*24*60*60*1000;
        const range7StartMs = nowMs - 7*24*60*60*1000;

        const snap = await db.collection("tickets").limit(2000).get();
        const tickets = snap.docs.map(d => ({ id:d.id, ...(d.data()||{}) }));

        const openTickets = [];
        const finalisedTickets = [];
        const pendingGreen = [];
        const submittedSimgrid = [];

        const createdCounts = new Map();
        const finalisedCounts = new Map();

        const tatSamplesMs = [];
        const pendingToSubmitSamplesMs = [];

        let tatUsedProxyCount = 0;

        for (const t of tickets){
          const status = (t.status || "").toString();
          const createdMs = getCreatedMs(t);
          const finalMs = getFinalisedMs(t);

          const fin = isFinalised(status);

          if (!fin) openTickets.push({ ...t, createdMs });
          if (fin) finalisedTickets.push({ ...t, createdMs, finalMs });

          if (createdMs && createdMs >= rangeStartMs){
            const k = dayKey(createdMs);
            createdCounts.set(k, (createdCounts.get(k) || 0) + 1);
          }

          if (finalMs && finalMs >= rangeStartMs){
            const k = dayKey(finalMs);
            finalisedCounts.set(k, (finalisedCounts.get(k) || 0) + 1);
          }

          const pendingFlag = t.simgridPendingGreenlit === true;
          const greenlit = t.simgridGreenlit === true;
          const submitted = t.simgridSubmitted === true;

          if (pendingFlag && !greenlit && !submitted){
            const pendingMs = getPendingMs(t);
            pendingGreen.push({ ...t, pendingMs });
          }

          if (submitted){
            const submittedMs = getSubmittedMs(t);
            submittedSimgrid.push({ ...t, submittedMs });
          }

          // Turnaround samples: finalised happened in last 7 days
          if (createdMs && finalMs && finalMs >= range7StartMs){
            const directFinal = pickFirstMs(t, [
              "finalisedAt","finalizedAt","closedAt","resolvedAt","finalisedTimestamp",
              "statusFinalisedAt","statusFinalizedAt"
            ]);
            if (!directFinal) tatUsedProxyCount++;
            tatSamplesMs.push(finalMs - createdMs);
          }

          // Pending->Submit samples (submitted in chosen range + have pending)
          const pendingMs = getPendingMs(t);
          const submittedMs = getSubmittedMs(t);
          if (pendingMs && submittedMs && submittedMs >= rangeStartMs){
            pendingToSubmitSamplesMs.push(submittedMs - pendingMs);
          }
        }

        // Open age stats
        const openAgesMs = openTickets
          .map(t => t.createdMs ? (nowMs - t.createdMs) : null)
          .filter(x => x != null && x >= 0);

        openTickets.sort((a,b) => (a.createdMs||0) - (b.createdMs||0));
        const oldestOpen = openTickets[0];

        // Pending stats
        pendingGreen.sort((a,b) => (a.pendingMs||0) - (b.pendingMs||0));
        const pendingAgesMs = pendingGreen
          .map(t => t.pendingMs ? (nowMs - t.pendingMs) : null)
          .filter(x => x != null && x >= 0);

        // Submitted in range
        const submittedInRange = submittedSimgrid.filter(t => (t.submittedMs||0) >= rangeStartMs);

        const tatAvg = avg(tatSamplesMs);
        const tatMed = median(tatSamplesMs);

        const p2sAvg = avg(pendingToSubmitSamplesMs);
        const p2sMed = median(pendingToSubmitSamplesMs);

        renderKPIs([
          {
            label:"Tickets live (open)",
            value:String(openTickets.length),
            sub: openTickets.length ? "Status not finalised" : "No open tickets ðŸŽ‰"
          },
          {
            label:"Oldest open ticket",
            value: oldestOpen?.createdMs ? fmtDuration(nowMs - oldestOpen.createdMs) : "â€”",
            sub: oldestOpen ? `Ticket: ${oldestOpen.id}` : "â€”"
          },
          {
            label:"Avg age of open",
            value: openAgesMs.length ? fmtDuration(avg(openAgesMs)) : "â€”",
            sub: openAgesMs.length ? `Median: ${fmtDuration(median(openAgesMs))}` : "â€”"
          },
          {
            label:"Pending green light",
            value:String(pendingGreen.length),
            sub: pendingGreen.length ? `Oldest: ${fmtDuration(nowMs - (pendingGreen[0].pendingMs||nowMs))}` : "None pending"
          },
          {
            label:"Submitted to SimGrid",
            value:String(submittedInRange.length),
            sub: `In last ${days} day(s)`
          },
          {
            label:"Avg pending â†’ submit",
            value: p2sAvg ? fmtDuration(p2sAvg) : "â€”",
            sub: p2sMed ? `Median: ${fmtDuration(p2sMed)}` : "â€”"
          }
        ]);

        const oldestOpenRows = openTickets.slice(0, 12).map(t => ({
          id: t.id,
          status: t.status || "",
          event: t.event || "",
          accused: t.accused || "",
          reporter: t.reporter || "",
          createdMs: t.createdMs || 0,
          ageLabel: t.createdMs ? fmtDuration(nowMs - t.createdMs) : "â€”"
        }));
        renderOldestOpen(oldestOpenRows);

        const pendingRows = pendingGreen.slice(0, 12).map(t => ({
          id: t.id,
          pendingMs: t.pendingMs || 0,
          pendingAgeLabel: t.pendingMs ? fmtDuration(nowMs - t.pendingMs) : "â€”",
          event: t.event || "",
          accused: t.accused || ""
        }));
        renderPending(pendingRows);

        // Chart 1: created vs finalised
        const dateKeys = makeDateKeysBack(Math.min(days, 30));
        const createdSeries = dateKeys.map(k => createdCounts.get(k) || 0);
        const finalisedSeries = dateKeys.map(k => finalisedCounts.get(k) || 0);

        $("createdFinalisedHint").textContent = `Last ${Math.min(days,30)} day(s)`;

        chartDaily = new Chart($("chartDaily"), {
          type: "line",
          data: {
            labels: dateKeys,
            datasets: [
              { label: "Created", data: createdSeries, tension: 0.3 },
              { label: "Finalised", data: finalisedSeries, tension: 0.3 }
            ]
          },
          options: {
            responsive: true,
            plugins: { legend: { display: true } },
            scales: { y: { beginAtZero: true, ticks: { precision: 0 } } }
          }
        });

        // Chart 2: pipeline breakdown
        const greenlitNotSubmitted = finalisedTickets.filter(t => (t.simgridGreenlit === true && t.simgridSubmitted !== true));
        $("pipelineHint").textContent = "Counts are current; submitted is in selected range";

        chartPipeline = new Chart($("chartPipeline"), {
          type: "bar",
          data: {
            labels: ["Open", "Finalised", "Greenlit", "Pending", `Submitted (${days}d)`],
            datasets: [{
              label: "Tickets",
              data: [
                openTickets.length,
                finalisedTickets.length,
                greenlitNotSubmitted.length,
                pendingGreen.length,
                submittedInRange.length
              ]
            }]
          },
          options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: { y: { beginAtZero: true, ticks: { precision: 0 } } }
          }
        });

        // Chart 3: turnaround distribution (last 7 days)
        const tatBuckets = new Map([["<2h",0],["2â€“6h",0],["6â€“12h",0],["12â€“24h",0],["1â€“2d",0],["2â€“4d",0],["4d+",0]]);
        for (const ms of tatSamplesMs){
          const hours = ms / (1000*60*60);
          const label = bucketHoursToLabel(hours);
          tatBuckets.set(label, (tatBuckets.get(label)||0) + 1);
        }
        const tatLabels = Array.from(tatBuckets.keys());
        const tatValues = tatLabels.map(k => tatBuckets.get(k) || 0);

        if (!tatSamplesMs.length){
          $("tatHint").textContent = "Last 7 days â€¢ No usable timestamps found (need created + finalised/greenlit/submitted timestamps)";
        } else {
          $("tatHint").textContent =
            `Last 7 days â€¢ Avg: ${fmtDuration(tatAvg)} â€¢ Median: ${fmtDuration(tatMed)}`
            + (tatUsedProxyCount ? ` â€¢ Proxy used: ${tatUsedProxyCount}/${tatSamplesMs.length}` : "");
        }

        chartTAT = new Chart($("chartTAT"), {
          type: "bar",
          data: { labels: tatLabels, datasets: [{ label: "Tickets", data: tatValues }] },
          options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: { y: { beginAtZero: true, ticks: { precision: 0 } } }
          }
        });

        // Chart 4: pending -> submit distribution (selected range)
        const p2sBuckets = new Map([["<2h",0],["2â€“6h",0],["6â€“12h",0],["12â€“24h",0],["1â€“2d",0],["2â€“4d",0],["4d+",0]]);
        for (const ms of pendingToSubmitSamplesMs){
          const hours = ms / (1000*60*60);
          const label = bucketHoursToLabel(hours);
          p2sBuckets.set(label, (p2sBuckets.get(label)||0) + 1);
        }
        const p2sLabels = Array.from(p2sBuckets.keys());
        const p2sValues = p2sLabels.map(k => p2sBuckets.get(k) || 0);

        $("pendingToSubmitHint").textContent = pendingToSubmitSamplesMs.length
          ? `Last ${days} days â€¢ Avg: ${fmtDuration(p2sAvg)} â€¢ Median: ${fmtDuration(p2sMed)}`
          : `Last ${days} days â€¢ No samples (need BOTH pending timestamp + submitted timestamp)`;

        chartPendingSubmit = new Chart($("chartPendingSubmit"), {
          type: "bar",
          data: { labels: p2sLabels, datasets: [{ label: "Tickets", data: p2sValues }] },
          options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: { y: { beginAtZero: true, ticks: { precision: 0 } } }
          }
        });

        toast("Dashboard loaded âœ…");
      }catch(e){
        console.error(e);
        toast("Load failed:\n" + (e?.message || e));
      }
    }

    async function waitForFirebaseReady(maxMs = 8000){
      const start = Date.now();
      while (Date.now() - start < maxMs){
        if (typeof auth !== "undefined" && typeof db !== "undefined" && auth && db) return true;
        await new Promise(r => setTimeout(r, 80));
      }
      return false;
    }

    (async () => {
      const ok = await waitForFirebaseReady();
      if (!ok){
        toast("Firebase not ready.\nCheck firebase-init.js path + console.");
        return;
      }

      auth.onAuthStateChanged(async (user) => {
        try{
          if (!user){ window.location.href = "admin.html"; return; }

          const email = (user.email || "").toLowerCase().trim();
          const adminSnap = await db.collection("admins").doc(email).get();
          if (!adminSnap.exists){ await auth.signOut(); window.location.href = "admin.html"; return; }

          const data = adminSnap.data() || {};
          const roleText = String(data.role || "").toLowerCase();
          const isOwner = roleText.includes("owner") || data.owner === true;

          if (!isOwner){
            toast("Access denied (owner only).");
            await auth.signOut();
            window.location.href = "admin.html";
            return;
          }

          $("permPill").textContent = "Permissions: Owner";

          const nameGuess = (email.split("@")[0] || "").replace(/[._-]+/g, " ").trim();
          const niceName = nameGuess ? nameGuess.replace(/\b\w/g, c => c.toUpperCase()) : "Owner";

          $("welcomeLine").textContent = `Welcome, ${niceName}. This page shows live ops stats + steward accountability.`;
          $("who").textContent = `Signed in as: ${email} | role: ${data.role || "admin"}`;

          // Load both panels
          await loadStewardAudit7d();
          await loadDashboard();
        }catch(e){
          console.error(e);
          toast("Auth/load error:\n" + (e?.message || e));
        }
      });
    })();
  </script>
</body>
</html>
