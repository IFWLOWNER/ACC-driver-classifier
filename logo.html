<!DOCTYPE html>
<html>
<head>
  <title>IFWL Owner ‚Äî Overview Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    body{
      font-family: Arial, sans-serif;
      margin:0;
      background:
        linear-gradient(rgba(2,6,23,0.72), rgba(2,6,23,0.72)),
        url("./ifwl_bg.webp");
      background-size:cover;
      background-position:center;
      background-attachment:fixed;
      color:#111827;
    }

    header{
      padding:14px 18px;
      background:#111827;
      color:#fff;
    }
    .headerInner{
      max-width:1400px;
      margin:0 auto;
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
    }

    .brand{
      display:flex;
      gap:12px;
      align-items:flex-start;
      min-width:0;
    }
    .brand img{
      width:38px;height:38px;object-fit:contain;margin-top:2px;flex:0 0 auto;
      filter: drop-shadow(0 1px 1px rgba(0,0,0,0.25));
    }
    .brandText{min-width:0;}
    .brandTitle{font-weight:900; font-size:18px;}
    header .small{font-size:12px;opacity:0.85;margin-top:4px;line-height:1.2;word-break:break-word;}
    .welcomeLine{font-size:12px;opacity:0.95;margin-top:6px;line-height:1.25;}

    .wrap{
      padding:14px;
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
      max-width:1400px;
      margin:0 auto;
    }

    .card{
      background:rgba(255,255,255,0.92);
      border:1px solid rgba(229,231,235,0.95);
      border-radius:14px;
      padding:12px;
      box-shadow:0 10px 28px rgba(0,0,0,0.18);
    }

    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .rowBetween{display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
    .title{font-weight:900; font-size:16px; margin:0;}
    .muted{color:#6b7280; font-size:12px;}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, monospace;}

    button{padding:10px 12px; border:1px solid #d1d5db; border-radius:12px; background:#fff; cursor:pointer;}
    button.primary{background:#111827;color:#fff;border-color:#111827;}
    button:disabled{opacity:0.6;cursor:not-allowed;}

    select, input{
      padding:10px; border:1px solid #d1d5db; border-radius:12px;
      box-sizing:border-box; font-size:16px; background:#fff;
    }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:4px 10px; border-radius:999px;
      border:1px solid #e5e7eb; background:#fff;
      font-size:12px; color:#111827; white-space:nowrap;
    }
    .pill strong{font-weight:900;}

    .kpiGrid{
      display:grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap:12px;
      margin-top:10px;
    }
    .kpi{
      background:#fff;
      border:1px solid #e5e7eb;
      border-radius:14px;
      padding:12px;
      box-shadow:0 8px 18px rgba(0,0,0,0.08);
      min-height:88px;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
    }
    .kpi .label{font-size:12px; color:#6b7280; font-weight:800;}
    .kpi .value{font-size:22px; font-weight:900; margin-top:6px;}
    .kpi .sub{font-size:12px; color:#6b7280; margin-top:6px; line-height:1.25;}

    .grid2{
      display:grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap:12px;
    }
    .gridCharts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:12px;
    }

    .chartCard{
      background:#fff;
      border:1px solid #e5e7eb;
      border-radius:14px;
      padding:12px;
      box-shadow:0 8px 18px rgba(0,0,0,0.08);
    }
    .chartTitle{font-weight:900; font-size:13px;}

    /* HQ canvas: keep CSS size, but Chart.js will render internally at higher DPR */
    canvas{width:100% !important; height:300px !important;}

    .tableWrap{
      overflow:auto;
      border:1px solid #e5e7eb;
      border-radius:12px;
      background:#fff;
      margin-top:10px;
    }
    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      min-width:980px;
    }
    th, td{
      padding:10px;
      border-bottom:1px solid #f3f4f6;
      font-size:13px;
      text-align:left;
      vertical-align:top;
    }
    th{
      position:sticky;
      top:0;
      background:#f9fafb;
      z-index:2;
      font-size:12px;
      color:#111827;
      border-bottom:1px solid #e5e7eb;
      white-space:nowrap;
    }
    tr:last-child td{border-bottom:0;}

    .tag{
      display:inline-block;
      padding:3px 10px;
      border-radius:999px;
      border:1px solid #e5e7eb;
      background:#fff;
      font-size:12px;
      font-weight:900;
      white-space:nowrap;
    }
    .tag.ok{border-color:#86efac;background:#ecfdf5;color:#065f46;}
    .tag.bad{border-color:#fca5a5;background:#fef2f2;color:#991b1b;}
    .tag.neutral{border-color:#d1d5db;background:#f9fafb;color:#111827;}

    a{color:#111827;}
    a:hover{opacity:0.85;}

    .toast{
      position:fixed; right:16px; bottom:16px;
      background:#111827; color:#fff;
      padding:10px 12px; border-radius:12px;
      opacity:0; transform: translateY(8px);
      transition: all .18s ease;
      z-index:9999;
      max-width: min(520px, calc(100vw - 32px));
      white-space: pre-wrap;
    }
    .toast.show{opacity:1; transform: translateY(0);}

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Steward Input audit (Owner) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .auditBox{
      border:1px solid #e5e7eb;
      border-radius:14px;
      padding:12px;
      background:rgba(250,250,250,0.92);
      margin-top:12px;
    }
    .auditTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .auditTitle{
      font-weight:900;
      font-size:14px;
      margin:0;
    }
    .auditMeta{
      margin-top:6px;
      font-size:12px;
      color:#6b7280;
      line-height:1.25;
    }
    .auditTableWrap{
      margin-top:10px;
      overflow:auto;
      border:1px solid #e5e7eb;
      border-radius:12px;
      background:#fff;
    }
    table.auditTable{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      min-width:860px;
    }
    .auditTable th, .auditTable td{
      padding:10px;
      border-bottom:1px solid #f3f4f6;
      font-size:13px;
      text-align:left;
      vertical-align:top;
      white-space:nowrap;
    }
    .auditTable th{
      position:sticky;
      top:0;
      background:#f9fafb;
      z-index:2;
      font-size:12px;
      color:#111827;
      border-bottom:1px solid #e5e7eb;
    }
    .auditTable tr:last-child td{border-bottom:0;}

    .auditTable tr.inactive td{
      background:#fef2f2;
      color:#991b1b;
      font-weight:900;
    }
    .auditTable tr.inactive td .mutedInline{
      color:#991b1b;
      font-weight:900;
      opacity:0.9;
    }

    @media (max-width: 1200px){
      .kpiGrid{grid-template-columns: repeat(3, minmax(0, 1fr));}
      .grid2{grid-template-columns:1fr;}
    }
    @media (max-width: 980px){
      body{background-attachment:scroll;}
      .headerInner{flex-direction:column; align-items:stretch;}
      header .row{width:100%;}
      header button{width:100%;}
      .kpiGrid{grid-template-columns: repeat(2, minmax(0, 1fr));}
      .gridCharts{grid-template-columns:1fr;}
      canvas{height:280px !important;}
      table{min-width:860px;}
      table.auditTable{min-width:860px;}
    }
  </style>
</head>

<body>
  <header>
    <div class="headerInner">
      <div class="brand">
        <img src="./ifwl_logo.png" alt="IFWL logo">
        <div class="brandText">
          <div class="brandTitle">IFWL Owner ‚Äî Overview Dashboard</div>
          <div class="welcomeLine" id="welcomeLine">Loading your profile‚Ä¶</div>
          <div class="small" id="who">Loading‚Ä¶</div>
        </div>
      </div>

      <div class="row">
        <button id="backHeadBtn">Back to Head Stewards Dashboard</button>
        <button id="backClassifierBtn">Back to Classifier</button>
        <button id="logoutBtn">Sign out</button>
      </div>
    </div>
  </header>

  <div class="wrap">
    <div class="card">
      <div class="rowBetween">
        <div>
          <div class="title">Operations Snapshot</div>
          <div class="muted">Live + last 7 days performance (turnaround, pending, SimGrid throughput)</div>
        </div>
        <div class="row">
          <span class="pill" id="permPill">Permissions: ‚Ä¶</span>
          <select id="rangeDays">
            <option value="7" selected>Last 7 days</option>
            <option value="14">Last 14 days</option>
            <option value="30">Last 30 days</option>
          </select>
          <button id="refreshBtn" class="primary">Refresh</button>
        </div>
      </div>

      <div class="auditBox" aria-label="Steward input audit">
        <div class="auditTop">
          <div>
            <div class="auditTitle">Steward Activity (Last 7 Days) ‚Äî Accountability Overview</div>
            <div class="muted" style="margin-top:4px;">
              Note: Dave is exempt unless explicitly requested to review deadlock cases.
            </div>
          </div>

          <div class="row">
            <label class="muted" style="display:flex;align-items:center;gap:8px;">
              <input type="checkbox" id="showOnlyInactive">
              Show only inactive
            </label>
            <button id="refreshAuditBtn">Refresh</button>
          </div>
        </div>

        <div class="auditMeta" id="auditMeta">Loading‚Ä¶</div>

        <div class="auditTableWrap" id="auditTableWrap" style="display:none;">
          <table class="auditTable" aria-label="Steward input table">
            <thead>
              <tr>
                <th>Steward</th>
                <th>Comments (7d)</th>
                <th>Reviews (7d)</th>
                <th>Tickets Touched (7d)</th>
                <th>Last Active</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody id="auditTbody"></tbody>
          </table>
        </div>

        <div class="muted" style="margin-top:8px;">
          Counts include <span class="mono">collectionGroup</span> queries across all tickets. Inactive stewards are highlighted red.
        </div>
      </div>

      <div class="kpiGrid" id="kpiGrid"></div>

      <div class="gridCharts">
        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Tickets created vs finalised (daily)</div>
            <span class="muted" id="createdFinalisedHint">‚Äî</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartDaily"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Ticket pipeline breakdown</div>
            <span class="muted" id="pipelineHint">‚Äî</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartPipeline"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Turnaround time distribution (open ‚Üí finalised)</div>
            <span class="muted" id="tatHint">‚Äî</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartTAT"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Pending ‚Üí Submitted to SimGrid (time)</div>
            <span class="muted" id="pendingToSubmitHint">‚Äî</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartPendingSubmit"></canvas></div>
        </div>
      </div>

      <div class="grid2" style="margin-top:12px;">
        <div class="chartCard">
          <div class="rowBetween">
            <div>
              <div class="chartTitle">Oldest open tickets</div>
              <div class="muted">Helps identify backlog + long-running cases</div>
            </div>
          </div>
          <div class="tableWrap">
            <table>
              <thead>
                <tr>
                  <th>Ticket</th>
                  <th>Status</th>
                  <th>Event</th>
                  <th>Accused</th>
                  <th>Reporter</th>
                  <th>Age</th>
                  <th>Created</th>
                  <th>Open</th>
                </tr>
              </thead>
              <tbody id="tbodyOldestOpen"></tbody>
            </table>
          </div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div>
              <div class="chartTitle">Green light queues</div>
              <div class="muted">Pending = flagged pending ‚Ä¢ Awaiting = ready/awaiting head steward action</div>
            </div>
          </div>

          <!-- Pending -->
          <div class="tableWrap" style="margin-top:10px;">
            <div class="rowBetween" style="padding:10px 10px 0 10px;">
              <div class="chartTitle">Oldest pending green light</div>
              <div class="muted" id="pendingTableHint">‚Äî</div>
            </div>
            <table>
              <thead>
                <tr>
                  <th>Ticket</th>
                  <th>Pending since</th>
                  <th>Pending age</th>
                  <th>Event</th>
                  <th>Accused</th>
                  <th>Open</th>
                </tr>
              </thead>
              <tbody id="tbodyPending"></tbody>
            </table>
          </div>

          <!-- Awaiting -->
          <div class="tableWrap" style="margin-top:12px;">
            <div class="rowBetween" style="padding:10px 10px 0 10px;">
              <div class="chartTitle">Oldest awaiting green light</div>
              <div class="muted" id="awaitingTableHint">‚Äî</div>
            </div>
            <table>
              <thead>
                <tr>
                  <th>Ticket</th>
                  <th>Awaiting since</th>
                  <th>Awaiting age</th>
                  <th>Event</th>
                  <th>Accused</th>
                  <th>Open</th>
                </tr>
              </thead>
              <tbody id="tbodyAwaiting"></tbody>
            </table>
          </div>

          <div class="muted" style="margin-top:10px;" id="greenQueueNotes">
            Detection notes: Awaiting tries common fields like <span class="mono">awaitingGreenLight</span>/<span class="mono">readyForGreenlight</span> and status text containing ‚Äúawait‚Äù + ‚Äúgreen‚Äù.
          </div>
        </div>
      </div>

      <div class="muted" style="margin-top:10px;" id="notes">
        This dashboard will use fallbacks if some timestamps aren‚Äôt stored yet:
        <span class="mono">open‚Üífinalised</span> will use <span class="mono">finalisedAt</span> if present,
        otherwise it will fall back to <span class="mono">simgridGreenlitAt</span> (or <span class="mono">simgridSubmittedAt</span>) as a proxy.
      </div>
    </div>
  </div>

  <div class="toast" id="toast">Saved</div>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <script src="./firebase-init.js"></script>

  <script>
    const $ = (id) => document.getElementById(id);

    const toastEl = $("toast");
    function toast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      setTimeout(() => toastEl.classList.remove("show"), 2200);
    }

    window.addEventListener("error", (e) => {
      const msg = (e?.message || "Unknown JS error") + (e?.filename ? `\n${e.filename}:${e.lineno || 0}` : "");
      console.error("JS error:", e);
      toast("JS ERROR:\n" + msg);
    });
    window.addEventListener("unhandledrejection", (e) => {
      console.error("Promise rejection:", e);
      toast("PROMISE ERROR:\n" + (e?.reason?.message || e?.reason || "Unknown"));
    });

    function escapeHtml(s){
      return (s ?? "").toString()
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
    }

    function isFinalised(status){
      const s = (status || "").trim().toUpperCase();
      return s === "FINALISED" || s === "FINALIZED" || s === "CLOSED" || s === "RESOLVED";
    }

    function msFromTs(v){
      try{
        if (!v) return 0;
        if (v.toDate) return v.toDate().getTime();
        if (typeof v === "number") return v;
        const d = new Date(v);
        const ms = d.getTime();
        return isNaN(ms) ? 0 : ms;
      }catch{ return 0; }
    }

    function pickFirstMs(obj, keys){
      for (const k of keys){
        const ms = msFromTs(obj?.[k]);
        if (ms && ms > 0) return ms;
      }
      return 0;
    }

    function fmtDate(ms){
      if (!ms) return "‚Äî";
      return new Date(ms).toLocaleString();
    }

    function fmtDuration(ms){
      if (!ms || ms < 0) return "‚Äî";
      const sec = Math.floor(ms/1000);
      const min = Math.floor(sec/60);
      const hr = Math.floor(min/60);
      const day = Math.floor(hr/24);
      const remH = hr % 24;
      const remM = min % 60;
      if (day > 0) return `${day}d ${remH}h`;
      if (hr > 0) return `${hr}h ${remM}m`;
      if (min > 0) return `${min}m`;
      return `${sec}s`;
    }

    function getCreatedMs(x){
      return pickFirstMs(x, [
        "timestamp","createdAt","created","submittedAt","openedAt","openAt"
      ]);
    }

    function getFinalisedMs(x){
      const direct = pickFirstMs(x, [
        "finalisedAt","finalizedAt","closedAt","resolvedAt","finalisedTimestamp",
        "statusFinalisedAt","statusFinalizedAt","statusUpdatedAt","updatedAt","lastUpdatedAt"
      ]);
      if (direct) return direct;

      const proxy = pickFirstMs(x, [
        "simgridGreenlitAt","simgridSubmittedAt","simgridApprovedAt","simgridCompletedAt"
      ]);
      return proxy || 0;
    }

    function getPendingMs(x){
      return pickFirstMs(x, [
        "simgridPendingAt","simgridPendingGreenlitAt","pendingAt","pendingGreenlitAt","pendingSince"
      ]);
    }
    function getSubmittedMs(x){
      return pickFirstMs(x, [
        "simgridSubmittedAt","simgridSubmittedOn","submittedToSimgridAt","submittedAtSimgrid","simgridCompletedAt"
      ]);
    }

    // NEW: "Awaiting green light" detection + timestamp
    function boolish(v){ return v === true || String(v||"").toLowerCase() === "true"; }
    function isAwaitingGreenLight(t){
      const status = String(t?.status || "").toLowerCase();
      const statusMatch = status.includes("await") && status.includes("green");
      const fieldMatch = (
        boolish(t?.awaitingGreenLight) ||
        boolish(t?.awaitingGreenlit) ||
        boolish(t?.readyForGreenlight) ||
        boolish(t?.readyForGreenlit) ||
        boolish(t?.awaitingHeadSteward) ||
        boolish(t?.headStewardAwaiting) ||
        boolish(t?.awaitingApproval)
      );
      return statusMatch || fieldMatch;
    }
    function getAwaitingMs(t){
      const direct = pickFirstMs(t, [
        "awaitingGreenlitAt","awaitingGreenLightAt","readyForGreenlightAt","readyForGreenlitAt",
        "awaitingAt","awaitingSince","headStewardAwaitingAt","awaitingApprovalAt"
      ]);
      if (direct) return direct;
      // fallback: if it‚Äôs marked awaiting but no timestamp, use updatedAt-ish
      return pickFirstMs(t, ["statusUpdatedAt","updatedAt","lastUpdatedAt","createdAt","timestamp"]);
    }

    function ticketUrl(id){ return `ticket.html?id=${encodeURIComponent(id || "")}`; }

    $("backHeadBtn").onclick = () => window.location.href = "https://ifwlowner.github.io/ACC-driver-classifier/headsteward.html";
    $("backClassifierBtn").onclick = () => window.location.href = "index.html";
    $("logoutBtn").onclick = async () => { await auth.signOut(); window.location.href = "admin.html"; };

    $("refreshBtn").onclick = () => loadDashboard();
    $("rangeDays").onchange = () => loadDashboard();

    $("refreshAuditBtn").onclick = () => loadStewardAudit7d();
    $("showOnlyInactive").onchange = () => renderAuditTableFromCache();

    // ---------------------------
    // Charts
    // ---------------------------
    let chartDaily = null;
    let chartPipeline = null;
    let chartTAT = null;
    let chartPendingSubmit = null;

    function destroyCharts(){
      for (const ch of [chartDaily, chartPipeline, chartTAT, chartPendingSubmit]){
        if (ch && typeof ch.destroy === "function") ch.destroy();
      }
      chartDaily = chartPipeline = chartTAT = chartPendingSubmit = null;
    }

    // HQ chart defaults
    function applyChartDefaults(){
      if (typeof Chart === "undefined") return;

      // Render crisp on retina/HiDPI
      const dpr = Math.min(3, Math.max(2, window.devicePixelRatio || 1));
      Chart.defaults.devicePixelRatio = dpr;

      Chart.defaults.responsive = true;
      Chart.defaults.maintainAspectRatio = false;

      Chart.defaults.font.family = "Arial, sans-serif";
      Chart.defaults.font.size = 12;

      // A touch thicker lines so they don‚Äôt look fuzzy
      Chart.defaults.elements.line.borderWidth = 2;
      Chart.defaults.elements.point.radius = 2;
      Chart.defaults.elements.point.hoverRadius = 4;

      Chart.defaults.plugins.legend.labels.boxWidth = 14;
      Chart.defaults.plugins.legend.labels.boxHeight = 14;

      // Less ‚Äúblurry‚Äù labels on some screens
      Chart.defaults.scale.ticks.maxTicksLimit = 8;
    }

    function baseChartOptions(){
      return {
        responsive: true,
        maintainAspectRatio: false,
        devicePixelRatio: Math.min(3, Math.max(2, window.devicePixelRatio || 1)),
        animation: { duration: 250 },
        plugins: {
          legend: {
            display: true,
            labels: { font: { size: 12, weight: "700" } }
          },
          tooltip: {
            titleFont: { size: 12, weight: "800" },
            bodyFont: { size: 12 }
          }
        },
        scales: {
          x: { ticks: { font: { size: 11 } } },
          y: { beginAtZero: true, ticks: { precision: 0, font: { size: 11 } } }
        }
      };
    }

    // ---------------------------
    // Stats helpers
    // ---------------------------
    function median(arr){
      if (!arr.length) return null;
      const a = [...arr].sort((x,y)=>x-y);
      const mid = Math.floor(a.length/2);
      return (a.length % 2 === 0) ? (a[mid-1] + a[mid]) / 2 : a[mid];
    }
    function avg(arr){
      if (!arr.length) return null;
      return arr.reduce((s,v)=>s+v,0) / arr.length;
    }

    function bucketHoursToLabel(hours){
      if (hours < 2) return "<2h";
      if (hours < 6) return "2‚Äì6h";
      if (hours < 12) return "6‚Äì12h";
      if (hours < 24) return "12‚Äì24h";
      if (hours < 48) return "1‚Äì2d";
      if (hours < 96) return "2‚Äì4d";
      return "4d+";
    }

    function dayKey(ms){
      const d = new Date(ms);
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,"0");
      const dd = String(d.getDate()).padStart(2,"0");
      return `${y}-${m}-${dd}`;
    }

    function makeDateKeysBack(days){
      const keys = [];
      const now = new Date();
      for (let i = days-1; i >= 0; i--){
        const d = new Date(now.getFullYear(), now.getMonth(), now.getDate() - i);
        keys.push(dayKey(d.getTime()));
      }
      return keys;
    }

    function renderKPIs(kpis){
      $("kpiGrid").innerHTML = kpis.map(k => `
        <div class="kpi">
          <div class="label">${escapeHtml(k.label)}</div>
          <div class="value">${escapeHtml(k.value)}</div>
          <div class="sub">${escapeHtml(k.sub || "")}</div>
        </div>
      `).join("");
    }

    function renderOldestOpen(rows){
      const tbody = $("tbodyOldestOpen");
      tbody.innerHTML = "";
      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="8" class="muted">No open tickets found.</td></tr>`;
        return;
      }
      for (const r of rows){
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td class="mono">${escapeHtml(r.id)}</td>
            <td>${escapeHtml(r.status || "")}</td>
            <td>${escapeHtml(r.event || "")}</td>
            <td>${escapeHtml(r.accused || "")}</td>
            <td>${escapeHtml(r.reporter || "")}</td>
            <td><b>${escapeHtml(r.ageLabel)}</b></td>
            <td>${escapeHtml(fmtDate(r.createdMs))}</td>
            <td><a href="${ticketUrl(r.id)}" target="_blank" rel="noopener">Open</a></td>
          </tr>
        `);
      }
    }

    function renderPending(rows){
      const tbody = $("tbodyPending");
      tbody.innerHTML = "";
      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="6" class="muted">No pending green light tickets.</td></tr>`;
        return;
      }
      for (const r of rows){
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td class="mono">${escapeHtml(r.id)}</td>
            <td>${escapeHtml(fmtDate(r.pendingMs))}</td>
            <td><b>${escapeHtml(r.pendingAgeLabel)}</b></td>
            <td>${escapeHtml(r.event || "")}</td>
            <td>${escapeHtml(r.accused || "")}</td>
            <td><a href="${ticketUrl(r.id)}" target="_blank" rel="noopener">Open</a></td>
          </tr>
        `);
      }
    }

    // NEW: Awaiting green light table render
    function renderAwaiting(rows){
      const tbody = $("tbodyAwaiting");
      tbody.innerHTML = "";
      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="6" class="muted">No awaiting green light tickets.</td></tr>`;
        return;
      }
      for (const r of rows){
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td class="mono">${escapeHtml(r.id)}</td>
            <td>${escapeHtml(fmtDate(r.awaitingMs))}</td>
            <td><b>${escapeHtml(r.awaitingAgeLabel)}</b></td>
            <td>${escapeHtml(r.event || "")}</td>
            <td>${escapeHtml(r.accused || "")}</td>
            <td><a href="${ticketUrl(r.id)}" target="_blank" rel="noopener">Open</a></td>
          </tr>
        `);
      }
    }

    // ---------------------------
    // Steward audit (Owner)
    // ---------------------------
    let auditRowsCache = [];
    function safeKey(email){ return (email || "").replaceAll("/", "_").replaceAll("\\", "_").trim(); }

    function displayStewardName(raw){
      const s = String(raw || "").trim();
      if (!s) return "Unknown";
      const at = s.indexOf("@");
      return at > 0 ? s.slice(0, at) : s;
    }

    function roleLooksLikeSteward(adminDoc){
      const role = String(adminDoc?.role || "").toLowerCase();
      return (
        role.includes("steward") ||
        role.includes("head") ||
        adminDoc?.headsteward === true ||
        adminDoc?.owner === true
      );
    }

    function ticketIdFromDocRef(docRef){
      try{ return docRef?.parent?.parent?.id || ""; }catch{ return ""; }
    }

    function renderAuditTableFromCache(){
      const metaEl = $("auditMeta");
      const wrapEl = $("auditTableWrap");
      const bodyEl = $("auditTbody");
      const onlyInactive = $("showOnlyInactive").checked === true;

      bodyEl.innerHTML = "";

      const rows = onlyInactive
        ? auditRowsCache.filter(r => r.inactive)
        : [...auditRowsCache];

      if (!rows.length){
        wrapEl.style.display = "none";
        metaEl.textContent = onlyInactive
          ? "No inactive stewards in this window ‚úÖ"
          : "No steward roster/activity data to display.";
        return;
      }

      for (const r of rows){
        const tr = document.createElement("tr");
        if (r.inactive) tr.className = "inactive";

        const last = r.lastActiveMs ? new Date(r.lastActiveMs).toLocaleString() : "‚Äî";
        const statusTxt = r.inactive ? "Non-compliant ‚Äî No steward actions logged" : "OK";

        tr.innerHTML = `
          <td class="mono">${escapeHtml(displayStewardName(r.email))}</td>
          <td><b>${r.comments}</b></td>
          <td><b>${r.reviews}</b></td>
          <td><b>${r.ticketsTouched}</b></td>
          <td>${escapeHtml(last)}</td>
          <td>${escapeHtml(statusTxt)}</td>
        `;
        bodyEl.appendChild(tr);
      }

      wrapEl.style.display = "block";
    }

    async function loadStewardAudit7d(){
      const metaEl = $("auditMeta");
      const wrapEl = $("auditTableWrap");
      const bodyEl = $("auditTbody");

      wrapEl.style.display = "none";
      bodyEl.innerHTML = "";
      metaEl.textContent = "Loading‚Ä¶";

      auditRowsCache = [];

      const now = Date.now();
      const sinceMs = now - (7 * 24 * 60 * 60 * 1000);
      const since = firebase.firestore.Timestamp.fromDate(new Date(sinceMs));

      let rosterEmails = [];
      try{
        const adminsSnap = await db.collection("admins").get();
        rosterEmails = adminsSnap.docs
          .map(d => ({ id: d.id, data: d.data() || {} }))
          .filter(x => roleLooksLikeSteward(x.data))
          .map(x => String(x.id || "").toLowerCase().trim())
          .filter(Boolean);
      }catch(e){
        console.error("Admins roster read failed:", e);
        metaEl.textContent = "Audit failed: cannot read /admins roster. This is a Firestore rules permission issue for /admins (Owner/Head Stewards must be allowed). Check console for exact error.";
        return;
      }

      const m = new Map();
      function getOrCreate(email){
        const k = safeKey(email || "unknown") || "unknown";
        if (!m.has(k)){
          m.set(k, { email: email || "unknown", comments:0, reviews:0, tickets:new Set(), lastActiveMs:0 });
        }
        return m.get(k);
      }

      let commentDocs = 0;
      let reviewDocs = 0;

      try{
        const commentsSnap = await db
          .collectionGroup("steward_comments")
          .where("createdAt", ">=", since)
          .get();

        commentDocs = commentsSnap.size;

        commentsSnap.forEach(doc => {
          const d = doc.data() || {};
          const ts = d.createdAt && d.createdAt.toDate ? d.createdAt.toDate() : null;
          if (!ts) return;

          const author = String(d.authorKey || d.stewardEmail || "unknown").trim() || "unknown";
          const s = getOrCreate(author);
          s.comments += 1;

          const ticketId = ticketIdFromDocRef(doc.ref);
          if (ticketId) s.tickets.add(ticketId);

          const tms = ts.getTime();
          if (tms > s.lastActiveMs) s.lastActiveMs = tms;
        });

        const reviewsSnap = await db
          .collectionGroup("reviews")
          .where("submittedAt", ">=", since)
          .get();

        reviewDocs = reviewsSnap.size;

        reviewsSnap.forEach(doc => {
          const d = doc.data() || {};
          const ts = d.submittedAt && d.submittedAt.toDate ? d.submittedAt.toDate() : null;
          if (!ts) return;

          const author = String(d.stewardEmail || d.authorKey || "unknown").trim() || "unknown";
          const s = getOrCreate(author);
          s.reviews += 1;

          const ticketId = ticketIdFromDocRef(doc.ref);
          if (ticketId) s.tickets.add(ticketId);

          const tms = ts.getTime();
          if (tms > s.lastActiveMs) s.lastActiveMs = tms;
        });

      }catch(e){
        console.error("Steward audit collectionGroup failed:", e);
        metaEl.textContent =
          "Audit failed. This is either:\n" +
          "‚Ä¢ Firestore rules denying collectionGroup reads for steward_comments/reviews\n" +
          "‚Ä¢ Or an index requirement.\n" +
          "Open console for the exact Firebase error (it often includes a 'create index' link).";
        return;
      }

      const rosterRows = rosterEmails.map(email => {
        const k = safeKey(email) || "unknown";
        const existing = m.get(k);
        const comments = existing ? existing.comments : 0;
        const reviews = existing ? existing.reviews : 0;
        const ticketsTouched = existing ? existing.tickets.size : 0;
        const lastActiveMs = existing ? existing.lastActiveMs : 0;
        const inactive = (comments + reviews) === 0;
        return { email, comments, reviews, ticketsTouched, lastActiveMs, inactive };
      });

      rosterRows.sort((a,b) => {
        if (a.inactive !== b.inactive) return a.inactive ? -1 : 1;
        const at = (a.comments + a.reviews);
        const bt = (b.comments + b.reviews);
        if (bt !== at) return bt - at;
        return (b.lastActiveMs || 0) - (a.lastActiveMs || 0);
      });

      auditRowsCache = rosterRows;

      const inactiveCount = rosterRows.filter(r => r.inactive).length;
      metaEl.textContent =
        `Loaded. Roster: ${rosterEmails.length} ‚Ä¢ Inactive: ${inactiveCount} ‚Ä¢ Comments scanned: ${commentDocs} ‚Ä¢ Reviews scanned: ${reviewDocs} ‚Ä¢ Window: last 7 days.`;

      renderAuditTableFromCache();
    }

    // ---------------------------
    // Main load
    // ---------------------------
    async function loadDashboard(){
      try{
        destroyCharts();

        $("pipelineHint").textContent = "Loading‚Ä¶";
        $("createdFinalisedHint").textContent = "Loading‚Ä¶";
        $("tatHint").textContent = "Loading‚Ä¶";
        $("pendingToSubmitHint").textContent = "Loading‚Ä¶";
        $("pendingTableHint").textContent = "Loading‚Ä¶";
        $("awaitingTableHint").textContent = "Loading‚Ä¶";

        renderKPIs([
          {label:"Tickets live (open)", value:"‚Äî", sub:"Loading‚Ä¶"},
          {label:"Oldest open ticket", value:"‚Äî", sub:"Loading‚Ä¶"},
          {label:"Avg age of open", value:"‚Äî", sub:"Loading‚Ä¶"},
          {label:"Pending green light", value:"‚Äî", sub:"Loading‚Ä¶"},
          {label:"Awaiting green light", value:"‚Äî", sub:"Loading‚Ä¶"},
          {label:"Avg pending ‚Üí submit", value:"‚Äî", sub:"Loading‚Ä¶"}
        ]);

        const days = parseInt($("rangeDays").value, 10) || 7;
        const nowMs = Date.now();
        const rangeStartMs = nowMs - days*24*60*60*1000;
        const range7StartMs = nowMs - 7*24*60*60*1000;

        const snap = await db.collection("tickets").limit(2000).get();
        const tickets = snap.docs.map(d => ({ id:d.id, ...(d.data()||{}) }));

        const openTickets = [];
        const finalisedTickets = [];
        const pendingGreen = [];
        const awaitingGreen = [];
        const submittedSimgrid = [];

        const createdCounts = new Map();
        const finalisedCounts = new Map();

        const tatSamplesMs = [];
        const pendingToSubmitSamplesMs = [];

        let tatUsedProxyCount = 0;

        for (const t of tickets){
          const status = (t.status || "").toString();
          const createdMs = getCreatedMs(t);
          const finalMs = getFinalisedMs(t);

          const fin = isFinalised(status);

          if (!fin) openTickets.push({ ...t, createdMs });
          if (fin) finalisedTickets.push({ ...t, createdMs, finalMs });

          if (createdMs && createdMs >= rangeStartMs){
            const k = dayKey(createdMs);
            createdCounts.set(k, (createdCounts.get(k) || 0) + 1);
          }

          if (finalMs && finalMs >= rangeStartMs){
            const k = dayKey(finalMs);
            finalisedCounts.set(k, (finalisedCounts.get(k) || 0) + 1);
          }

          const pendingFlag = t.simgridPendingGreenlit === true;
          const greenlit = t.simgridGreenlit === true;
          const submitted = t.simgridSubmitted === true;

          // Pending green light queue
          if (pendingFlag && !greenlit && !submitted){
            const pendingMs = getPendingMs(t);
            pendingGreen.push({ ...t, pendingMs });
          }

          // Awaiting green light queue (ready/awaiting but not pending, not greenlit, not submitted)
          if (!pendingFlag && isAwaitingGreenLight(t) && !greenlit && !submitted){
            const awaitingMs = getAwaitingMs(t);
            awaitingGreen.push({ ...t, awaitingMs });
          }

          if (submitted){
            const submittedMs = getSubmittedMs(t);
            submittedSimgrid.push({ ...t, submittedMs });
          }

          // Turnaround samples: finalised happened in last 7 days
          if (createdMs && finalMs && finalMs >= range7StartMs){
            const directFinal = pickFirstMs(t, [
              "finalisedAt","finalizedAt","closedAt","resolvedAt","finalisedTimestamp",
              "statusFinalisedAt","statusFinalizedAt"
            ]);
            if (!directFinal) tatUsedProxyCount++;
            tatSamplesMs.push(finalMs - createdMs);
          }

          // Pending->Submit samples (submitted in chosen range + have pending)
          const pendingMs = getPendingMs(t);
          const submittedMs = getSubmittedMs(t);
          if (pendingMs && submittedMs && submittedMs >= rangeStartMs){
            pendingToSubmitSamplesMs.push(submittedMs - pendingMs);
          }
        }

        // Open age stats
        const openAgesMs = openTickets
          .map(t => t.createdMs ? (nowMs - t.createdMs) : null)
          .filter(x => x != null && x >= 0);

        openTickets.sort((a,b) => (a.createdMs||0) - (b.createdMs||0));
        const oldestOpen = openTickets[0];

        // Pending stats
        pendingGreen.sort((a,b) => (a.pendingMs||0) - (b.pendingMs||0));

        // Awaiting stats
        awaitingGreen.sort((a,b) => (a.awaitingMs||0) - (b.awaitingMs||0));

        // Submitted in range
        const submittedInRange = submittedSimgrid.filter(t => (t.submittedMs||0) >= rangeStartMs);

        const tatAvg = avg(tatSamplesMs);
        const tatMed = median(tatSamplesMs);

        const p2sAvg = avg(pendingToSubmitSamplesMs);
        const p2sMed = median(pendingToSubmitSamplesMs);

        renderKPIs([
          {
            label:"Tickets live (open)",
            value:String(openTickets.length),
            sub: openTickets.length ? "Status not finalised" : "No open tickets üéâ"
          },
          {
            label:"Oldest open ticket",
            value: oldestOpen?.createdMs ? fmtDuration(nowMs - oldestOpen.createdMs) : "‚Äî",
            sub: oldestOpen ? `Ticket: ${oldestOpen.id}` : "‚Äî"
          },
          {
            label:"Avg age of open",
            value: openAgesMs.length ? fmtDuration(avg(openAgesMs)) : "‚Äî",
            sub: openAgesMs.length ? `Median: ${fmtDuration(median(openAgesMs))}` : "‚Äî"
          },
          {
            label:"Pending green light",
            value:String(pendingGreen.length),
            sub: pendingGreen.length ? `Oldest: ${fmtDuration(nowMs - (pendingGreen[0].pendingMs||nowMs))}` : "None pending"
          },
          {
            label:"Awaiting green light",
            value:String(awaitingGreen.length),
            sub: awaitingGreen.length ? `Oldest: ${fmtDuration(nowMs - (awaitingGreen[0].awaitingMs||nowMs))}` : "None awaiting"
          },
          {
            label:"Avg pending ‚Üí submit",
            value: p2sAvg ? fmtDuration(p2sAvg) : "‚Äî",
            sub: p2sMed ? `Median: ${fmtDuration(p2sMed)}` : "‚Äî"
          }
        ]);

        const oldestOpenRows = openTickets.slice(0, 12).map(t => ({
          id: t.id,
          status: t.status || "",
          event: t.event || "",
          accused: t.accused || "",
          reporter: t.reporter || "",
          createdMs: t.createdMs || 0,
          ageLabel: t.createdMs ? fmtDuration(nowMs - t.createdMs) : "‚Äî"
        }));
        renderOldestOpen(oldestOpenRows);

        const pendingRows = pendingGreen.slice(0, 12).map(t => ({
          id: t.id,
          pendingMs: t.pendingMs || 0,
          pendingAgeLabel: t.pendingMs ? fmtDuration(nowMs - t.pendingMs) : "‚Äî",
          event: t.event || "",
          accused: t.accused || ""
        }));
        renderPending(pendingRows);

        const awaitingRows = awaitingGreen.slice(0, 12).map(t => ({
          id: t.id,
          awaitingMs: t.awaitingMs || 0,
          awaitingAgeLabel: t.awaitingMs ? fmtDuration(nowMs - t.awaitingMs) : "‚Äî",
          event: t.event || "",
          accused: t.accused || ""
        }));
        renderAwaiting(awaitingRows);

        $("pendingTableHint").textContent = pendingGreen.length ? `Oldest: ${fmtDuration(nowMs - (pendingGreen[0].pendingMs||nowMs))}` : "‚Äî";
        $("awaitingTableHint").textContent = awaitingGreen.length ? `Oldest: ${fmtDuration(nowMs - (awaitingGreen[0].awaitingMs||nowMs))}` : "‚Äî";

        // Chart 1: created vs finalised
        const dateKeys = makeDateKeysBack(Math.min(days, 30));
        const createdSeries = dateKeys.map(k => createdCounts.get(k) || 0);
        const finalisedSeries = dateKeys.map(k => finalisedCounts.get(k) || 0);

        $("createdFinalisedHint").textContent = `Last ${Math.min(days,30)} day(s)`;

        chartDaily = new Chart($("chartDaily"), {
          type: "line",
          data: {
            labels: dateKeys,
            datasets: [
              { label: "Created", data: createdSeries, tension: 0.3 },
              { label: "Finalised", data: finalisedSeries, tension: 0.3 }
            ]
          },
          options: {
            ...baseChartOptions(),
            plugins: { ...baseChartOptions().plugins, legend: { display: true } },
            scales: { ...baseChartOptions().scales, y: { ...baseChartOptions().scales.y, beginAtZero: true, ticks: { precision: 0, font: { size: 11 } } } }
          }
        });

        // Chart 2: pipeline breakdown
        const greenlitNotSubmitted = finalisedTickets.filter(t => (t.simgridGreenlit === true && t.simgridSubmitted !== true));
        $("pipelineHint").textContent = "Counts are current; submitted is in selected range";

        chartPipeline = new Chart($("chartPipeline"), {
          type: "bar",
          data: {
            labels: ["Open", "Finalised", "Greenlit", "Pending", "Awaiting", `Submitted (${days}d)`],
            datasets: [{
              label: "Tickets",
              data: [
                openTickets.length,
                finalisedTickets.length,
                greenlitNotSubmitted.length,
                pendingGreen.length,
                awaitingGreen.length,
                submittedInRange.length
              ]
            }]
          },
          options: {
            ...baseChartOptions(),
            plugins: { ...baseChartOptions().plugins, legend: { display: false } }
          }
        });

        // Chart 3: turnaround distribution (last 7 days)
        const tatBuckets = new Map([["<2h",0],["2‚Äì6h",0],["6‚Äì12h",0],["12‚Äì24h",0],["1‚Äì2d",0],["2‚Äì4d",0],["4d+",0]]);
        for (const ms of tatSamplesMs){
          const hours = ms / (1000*60*60);
          const label = bucketHoursToLabel(hours);
          tatBuckets.set(label, (tatBuckets.get(label)||0) + 1);
        }
        const tatLabels = Array.from(tatBuckets.keys());
        const tatValues = tatLabels.map(k => tatBuckets.get(k) || 0);

        if (!tatSamplesMs.length){
          $("tatHint").textContent = "Last 7 days ‚Ä¢ No usable timestamps found (need created + finalised/greenlit/submitted timestamps)";
        } else {
          $("tatHint").textContent =
            `Last 7 days ‚Ä¢ Avg: ${fmtDuration(tatAvg)} ‚Ä¢ Median: ${fmtDuration(tatMed)}`
            + (tatUsedProxyCount ? ` ‚Ä¢ Proxy used: ${tatUsedProxyCount}/${tatSamplesMs.length}` : "");
        }

        chartTAT = new Chart($("chartTAT"), {
          type: "bar",
          data: { labels: tatLabels, datasets: [{ label: "Tickets", data: tatValues }] },
          options: {
            ...baseChartOptions(),
            plugins: { ...baseChartOptions().plugins, legend: { display: false } }
          }
        });

        // Chart 4: pending -> submit distribution (selected range)
        const p2sBuckets = new Map([["<2h",0],["2‚Äì6h",0],["6‚Äì12h",0],["12‚Äì24h",0],["1‚Äì2d",0],["2‚Äì4d",0],["4d+",0]]);
        for (const ms of pendingToSubmitSamplesMs){
          const hours = ms / (1000*60*60);
          const label = bucketHoursToLabel(hours);
          p2sBuckets.set(label, (p2sBuckets.get(label)||0) + 1);
        }
        const p2sLabels = Array.from(p2sBuckets.keys());
        const p2sValues = p2sLabels.map(k => p2sBuckets.get(k) || 0);

        $("pendingToSubmitHint").textContent = pendingToSubmitSamplesMs.length
          ? `Last ${days} days ‚Ä¢ Avg: ${fmtDuration(p2sAvg)} ‚Ä¢ Median: ${fmtDuration(p2sMed)}`
          : `Last ${days} days ‚Ä¢ No samples (need BOTH pending timestamp + submitted timestamp)`;

        chartPendingSubmit = new Chart($("chartPendingSubmit"), {
          type: "bar",
          data: { labels: p2sLabels, datasets: [{ label: "Tickets", data: p2sValues }] },
          options: {
            ...baseChartOptions(),
            plugins: { ...baseChartOptions().plugins, legend: { display: false } }
          }
        });

        toast("Dashboard loaded ‚úÖ");
      }catch(e){
        console.error(e);
        toast("Load failed:\n" + (e?.message || e));
      }
    }

    async function waitForFirebaseReady(maxMs = 8000){
      const start = Date.now();
      while (Date.now() - start < maxMs){
        if (typeof auth !== "undefined" && typeof db !== "undefined" && auth && db) return true;
        await new Promise(r => setTimeout(r, 80));
      }
      return false;
    }

    (async () => {
      const ok = await waitForFirebaseReady();
      if (!ok){
        toast("Firebase not ready.\nCheck firebase-init.js path + console.");
        return;
      }

      // Apply chart HQ defaults once Chart is present
      try{ applyChartDefaults(); }catch(e){ console.warn("Chart defaults failed:", e); }

      auth.onAuthStateChanged(async (user) => {
        try{
          if (!user){ window.location.href = "admin.html"; return; }

          const email = (user.email || "").toLowerCase().trim();
          const adminSnap = await db.collection("admins").doc(email).get();
          if (!adminSnap.exists){ await auth.signOut(); window.location.href = "admin.html"; return; }

          const data = adminSnap.data() || {};
          const roleText = String(data.role || "").toLowerCase();
          const isOwner = roleText.includes("owner") || data.owner === true;

          if (!isOwner){
            toast("Access denied (owner only).");
            await auth.signOut();
            window.location.href = "admin.html";
            return;
          }

          $("permPill").textContent = "Permissions: Owner";

          const nameGuess = (email.split("@")[0] || "").replace(/[._-]+/g, " ").trim();
          const niceName = nameGuess ? nameGuess.replace(/\b\w/g, c => c.toUpperCase()) : "Owner";

          $("welcomeLine").textContent = `Welcome, ${niceName}. This page shows live ops stats + steward accountability.`;
          $("who").textContent = `Signed in as: ${email} | role: ${data.role || "admin"}`;

          await loadStewardAudit7d();
          await loadDashboard();
        }catch(e){
          console.error(e);
          toast("Auth/load error:\n" + (e?.message || e));
        }
      });
    })();
  </script>
</body>
</html>
