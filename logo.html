<!DOCTYPE html>
<html>
<head>
  <title>IFWL Owner â€” Overview Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    body{
      font-family: Arial, sans-serif;
      margin:0;
      background:
        linear-gradient(rgba(2,6,23,0.72), rgba(2,6,23,0.72)),
        url("./ifwl_bg.webp");
      background-size:cover;
      background-position:center;
      background-attachment:fixed;
      color:#111827;
    }

    header{
      padding:14px 18px;
      background:#111827;
      color:#fff;
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
    }

    .brand{
      display:flex;
      gap:12px;
      align-items:flex-start;
      min-width:0;
    }
    .brand img{
      width:38px;height:38px;object-fit:contain;margin-top:2px;flex:0 0 auto;
      filter: drop-shadow(0 1px 1px rgba(0,0,0,0.25));
    }
    .brandText{min-width:0;}
    .brandTitle{font-weight:900; font-size:18px;}
    header .small{font-size:12px;opacity:0.85;margin-top:4px;line-height:1.2;word-break:break-word;}
    .welcomeLine{font-size:12px;opacity:0.95;margin-top:6px;line-height:1.25;}

    .wrap{padding:14px; display:grid; grid-template-columns: 1fr; gap:14px; max-width:1400px; margin:0 auto;}

    .card{
      background:rgba(255,255,255,0.92);
      border:1px solid rgba(229,231,235,0.95);
      border-radius:14px;
      padding:12px;
      box-shadow:0 10px 28px rgba(0,0,0,0.18);
    }

    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .rowBetween{display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
    .title{font-weight:900; font-size:16px; margin:0;}
    .muted{color:#6b7280; font-size:12px;}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, monospace;}

    button{padding:10px 12px; border:1px solid #d1d5db; border-radius:12px; background:#fff; cursor:pointer;}
    button.primary{background:#111827;color:#fff;border-color:#111827;}
    button:disabled{opacity:0.6;cursor:not-allowed;}

    select, input{
      padding:10px; border:1px solid #d1d5db; border-radius:12px;
      box-sizing:border-box; font-size:16px; background:#fff;
    }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:4px 10px; border-radius:999px;
      border:1px solid #e5e7eb; background:#fff;
      font-size:12px; color:#111827; white-space:nowrap;
    }
    .pill strong{font-weight:900;}

    .kpiGrid{
      display:grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap:12px;
      margin-top:10px;
    }
    .kpi{
      background:#fff;
      border:1px solid #e5e7eb;
      border-radius:14px;
      padding:12px;
      box-shadow:0 8px 18px rgba(0,0,0,0.08);
      min-height:88px;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
    }
    .kpi .label{font-size:12px; color:#6b7280; font-weight:800;}
    .kpi .value{font-size:22px; font-weight:900; margin-top:6px;}
    .kpi .sub{font-size:12px; color:#6b7280; margin-top:6px; line-height:1.25;}

    .grid2{
      display:grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap:12px;
    }
    .gridCharts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:12px;
    }

    .chartCard{
      background:#fff;
      border:1px solid #e5e7eb;
      border-radius:14px;
      padding:12px;
      box-shadow:0 8px 18px rgba(0,0,0,0.08);
    }
    .chartTitle{font-weight:900; font-size:13px;}
    canvas{width:100% !important; height:280px !important;}

    .tableWrap{
      overflow:auto;
      border:1px solid #e5e7eb;
      border-radius:12px;
      background:#fff;
      margin-top:10px;
    }
    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      min-width:980px;
    }
    th, td{
      padding:10px;
      border-bottom:1px solid #f3f4f6;
      font-size:13px;
      text-align:left;
      vertical-align:top;
    }
    th{
      position:sticky;
      top:0;
      background:#f9fafb;
      z-index:2;
      font-size:12px;
      color:#111827;
      border-bottom:1px solid #e5e7eb;
      white-space:nowrap;
    }
    tr:last-child td{border-bottom:0;}

    .tag{
      display:inline-block;
      padding:3px 10px;
      border-radius:999px;
      border:1px solid #e5e7eb;
      background:#fff;
      font-size:12px;
      font-weight:900;
      white-space:nowrap;
    }
    .tag.ok{border-color:#86efac;background:#ecfdf5;color:#065f46;}
    .tag.bad{border-color:#fca5a5;background:#fef2f2;color:#991b1b;}
    .tag.neutral{border-color:#d1d5db;background:#f9fafb;color:#111827;}

    a{color:#111827;}
    a:hover{opacity:0.85;}

    .toast{
      position:fixed; right:16px; bottom:16px;
      background:#111827; color:#fff;
      padding:10px 12px; border-radius:12px;
      opacity:0; transform: translateY(8px);
      transition: all .18s ease;
      z-index:9999;
      max-width: min(520px, calc(100vw - 32px));
      white-space: pre-wrap;
    }
    .toast.show{opacity:1; transform: translateY(0);}

    @media (max-width: 1200px){
      .kpiGrid{grid-template-columns: repeat(3, minmax(0, 1fr));}
      .grid2{grid-template-columns:1fr;}
    }
    @media (max-width: 980px){
      body{background-attachment:scroll;}
      header{flex-direction:column; align-items:stretch;}
      header .row{width:100%;}
      header button{width:100%;}
      .kpiGrid{grid-template-columns: repeat(2, minmax(0, 1fr));}
      .gridCharts{grid-template-columns:1fr;}
      canvas{height:260px !important;}
      table{min-width:860px;}
    }
  </style>
</head>

<body>
  <header>
    <div class="brand">
      <img src="./ifwl_logo.png" alt="IFWL logo">
      <div class="brandText">
        <div class="brandTitle">IFWL Owner â€” Overview Dashboard</div>
        <div class="welcomeLine" id="welcomeLine">Loading your profileâ€¦</div>
        <div class="small" id="who">Loadingâ€¦</div>
      </div>
    </div>

    <div class="row">
      <button id="backHeadBtn">Back to Head Stewards Dashboard</button>
      <button id="backClassifierBtn">Back to Classifier</button>
      <button id="logoutBtn">Sign out</button>
    </div>
  </header>

  <div class="wrap">
    <div class="card">
      <div class="rowBetween">
        <div>
          <div class="title">Operations Snapshot</div>
          <div class="muted">Live + last 7 days performance (turnaround, pending, SimGrid throughput)</div>
        </div>
        <div class="row">
          <span class="pill" id="permPill">Permissions: â€¦</span>
          <select id="rangeDays">
            <option value="7" selected>Last 7 days</option>
            <option value="14">Last 14 days</option>
            <option value="30">Last 30 days</option>
          </select>
          <button id="refreshBtn" class="primary">Refresh</button>
        </div>
      </div>

      <div class="kpiGrid" id="kpiGrid">
        <!-- KPIs injected -->
      </div>

      <div class="gridCharts">
        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Tickets created vs finalised (daily)</div>
            <span class="muted" id="createdFinalisedHint">â€”</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartDaily"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Ticket pipeline breakdown</div>
            <span class="muted" id="pipelineHint">â€”</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartPipeline"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Turnaround time distribution (open â†’ finalised)</div>
            <span class="muted" id="tatHint">â€”</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartTAT"></canvas></div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div class="chartTitle">Pending â†’ Submitted to SimGrid (time)</div>
            <span class="muted" id="pendingToSubmitHint">â€”</span>
          </div>
          <div style="margin-top:8px;"><canvas id="chartPendingSubmit"></canvas></div>
        </div>
      </div>

      <div class="grid2" style="margin-top:12px;">
        <div class="chartCard">
          <div class="rowBetween">
            <div>
              <div class="chartTitle">Oldest open tickets</div>
              <div class="muted">Helps identify backlog + long-running cases</div>
            </div>
          </div>
          <div class="tableWrap">
            <table>
              <thead>
                <tr>
                  <th>Ticket</th>
                  <th>Status</th>
                  <th>Event</th>
                  <th>Accused</th>
                  <th>Reporter</th>
                  <th>Age</th>
                  <th>Created</th>
                  <th>Open</th>
                </tr>
              </thead>
              <tbody id="tbodyOldestOpen"></tbody>
            </table>
          </div>
        </div>

        <div class="chartCard">
          <div class="rowBetween">
            <div>
              <div class="chartTitle">Oldest pending green light</div>
              <div class="muted">Tickets waiting for Head Steward confirmation</div>
            </div>
          </div>
          <div class="tableWrap">
            <table>
              <thead>
                <tr>
                  <th>Ticket</th>
                  <th>Pending since</th>
                  <th>Pending age</th>
                  <th>Event</th>
                  <th>Accused</th>
                  <th>Open</th>
                </tr>
              </thead>
              <tbody id="tbodyPending"></tbody>
            </table>
          </div>
        </div>
      </div>

      <div class="muted" style="margin-top:10px;" id="notes">
        Notes: This dashboard uses best-effort timestamps. For accurate turnaround metrics, each ticket should have a clear created timestamp
        (commonly <span class="mono">timestamp</span>) and a finalised timestamp (commonly <span class="mono">finalisedAt</span>/<span class="mono">closedAt</span>/<span class="mono">resolvedAt</span>).
        Pending uses <span class="mono">simgridPendingAt</span>, and SimGrid submit uses <span class="mono">simgridSubmittedAt</span>.
      </div>
    </div>
  </div>

  <div class="toast" id="toast">Saved</div>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <script src="./firebase-init.js"></script>

  <script>
    const $ = (id) => document.getElementById(id);

    const toastEl = $("toast");
    function toast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      setTimeout(() => toastEl.classList.remove("show"), 2200);
    }

    function escapeHtml(s){
      return (s ?? "").toString()
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
    }

    function isFinalised(status){
      const s = (status || "").trim().toUpperCase();
      return s === "FINALISED" || s === "FINALIZED" || s === "CLOSED" || s === "RESOLVED";
    }

    function msFromTs(v){
      try{
        if (!v) return 0;
        if (v.toDate) return v.toDate().getTime();
        const d = new Date(v);
        const ms = d.getTime();
        return isNaN(ms) ? 0 : ms;
      }catch{ return 0; }
    }

    function fmtDate(ms){
      if (!ms) return "â€”";
      return new Date(ms).toLocaleString();
    }

    function fmtDuration(ms){
      if (!ms || ms < 0) return "â€”";
      const sec = Math.floor(ms/1000);
      const min = Math.floor(sec/60);
      const hr = Math.floor(min/60);
      const day = Math.floor(hr/24);
      const remH = hr % 24;
      const remM = min % 60;
      if (day > 0) return `${day}d ${remH}h`;
      if (hr > 0) return `${hr}h ${remM}m`;
      if (min > 0) return `${min}m`;
      return `${sec}s`;
    }

    // Best-effort "created" timestamp:
    function getCreatedMs(x){
      return msFromTs(x.timestamp || x.createdAt || x.created || x.submittedAt || null);
    }

    // Best-effort "finalised" timestamp:
    function getFinalisedMs(x){
      return msFromTs(
        x.finalisedAt || x.finalizedAt || x.closedAt || x.resolvedAt || x.finalisedTimestamp || x.statusFinalisedAt || x.statusUpdatedAt || null
      );
    }

    // For Pending + Submit pipeline:
    function getPendingMs(x){ return msFromTs(x.simgridPendingAt || null); }
    function getSubmittedMs(x){ return msFromTs(x.simgridSubmittedAt || null); }

    // Ticket page link (works with the ticket.html you now have)
    function ticketUrl(id){ return `ticket.html?id=${encodeURIComponent(id || "")}`; }

    // ---------------------------
    // Auth / role gating
    // ---------------------------
    let currentEmail = "";
    let isOwner = false;
    let isHeadSteward = false;
    let isSimgrid = false;

    $("backHeadBtn").onclick = () => window.location.href = "https://ifwlowner.github.io/ACC-driver-classifier/headsteward.html";
    $("backClassifierBtn").onclick = () => window.location.href = "index.html";
    $("logoutBtn").onclick = async () => { await auth.signOut(); window.location.href = "admin.html"; };

    $("refreshBtn").onclick = () => loadDashboard();
    $("rangeDays").onchange = () => loadDashboard();

    // ---------------------------
    // Charts (keep references for destroy/recreate)
    // ---------------------------
    let chartDaily = null;
    let chartPipeline = null;
    let chartTAT = null;
    let chartPendingSubmit = null;

    function destroyCharts(){
      for (const ch of [chartDaily, chartPipeline, chartTAT, chartPendingSubmit]){
        if (ch && typeof ch.destroy === "function") ch.destroy();
      }
      chartDaily = chartPipeline = chartTAT = chartPendingSubmit = null;
    }

    // ---------------------------
    // Stats helpers
    // ---------------------------
    function median(arr){
      if (!arr.length) return null;
      const a = [...arr].sort((x,y)=>x-y);
      const mid = Math.floor(a.length/2);
      if (a.length % 2 === 0) return (a[mid-1] + a[mid]) / 2;
      return a[mid];
    }
    function avg(arr){
      if (!arr.length) return null;
      return arr.reduce((s,v)=>s+v,0) / arr.length;
    }

    function bucketHoursToLabel(hours){
      if (hours < 2) return "<2h";
      if (hours < 6) return "2â€“6h";
      if (hours < 12) return "6â€“12h";
      if (hours < 24) return "12â€“24h";
      if (hours < 48) return "1â€“2d";
      if (hours < 96) return "2â€“4d";
      return "4d+";
    }

    function dayKey(ms){
      const d = new Date(ms);
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,"0");
      const dd = String(d.getDate()).padStart(2,"0");
      return `${y}-${m}-${dd}`;
    }

    function makeDateKeysBack(days){
      const keys = [];
      const now = new Date();
      for (let i = days-1; i >= 0; i--){
        const d = new Date(now.getFullYear(), now.getMonth(), now.getDate() - i);
        keys.push(dayKey(d.getTime()));
      }
      return keys;
    }

    function renderKPIs(kpis){
      const grid = $("kpiGrid");
      grid.innerHTML = kpis.map(k => `
        <div class="kpi">
          <div class="label">${escapeHtml(k.label)}</div>
          <div class="value">${escapeHtml(k.value)}</div>
          <div class="sub">${escapeHtml(k.sub || "")}</div>
        </div>
      `).join("");
    }

    function renderOldestOpen(rows){
      const tbody = $("tbodyOldestOpen");
      tbody.innerHTML = "";
      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="8" class="muted">No open tickets found.</td></tr>`;
        return;
      }
      for (const r of rows){
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td class="mono">${escapeHtml(r.id)}</td>
            <td>${escapeHtml(r.status || "")}</td>
            <td>${escapeHtml(r.event || "")}</td>
            <td>${escapeHtml(r.accused || "")}</td>
            <td>${escapeHtml(r.reporter || "")}</td>
            <td><b>${escapeHtml(r.ageLabel)}</b></td>
            <td>${escapeHtml(fmtDate(r.createdMs))}</td>
            <td><a href="${ticketUrl(r.id)}" target="_blank" rel="noopener">Open</a></td>
          </tr>
        `);
      }
    }

    function renderPending(rows){
      const tbody = $("tbodyPending");
      tbody.innerHTML = "";
      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="6" class="muted">No pending green light tickets.</td></tr>`;
        return;
      }
      for (const r of rows){
        tbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td class="mono">${escapeHtml(r.id)}</td>
            <td>${escapeHtml(fmtDate(r.pendingMs))}</td>
            <td><b>${escapeHtml(r.pendingAgeLabel)}</b></td>
            <td>${escapeHtml(r.event || "")}</td>
            <td>${escapeHtml(r.accused || "")}</td>
            <td><a href="${ticketUrl(r.id)}" target="_blank" rel="noopener">Open</a></td>
          </tr>
        `);
      }
    }

    // ---------------------------
    // Main load
    // ---------------------------
    async function loadDashboard(){
      try{
        destroyCharts();
        $("pipelineHint").textContent = "Loadingâ€¦";
        $("createdFinalisedHint").textContent = "Loadingâ€¦";
        $("tatHint").textContent = "Loadingâ€¦";
        $("pendingToSubmitHint").textContent = "Loadingâ€¦";

        renderKPIs([
          {label:"Tickets live (open)", value:"â€”", sub:"Loadingâ€¦"},
          {label:"Oldest open ticket", value:"â€”", sub:"Loadingâ€¦"},
          {label:"Avg age of open", value:"â€”", sub:"Loadingâ€¦"},
          {label:"Pending green light", value:"â€”", sub:"Loadingâ€¦"},
          {label:"Submitted to SimGrid", value:"â€”", sub:"Loadingâ€¦"},
          {label:"Avg pending â†’ submit", value:"â€”", sub:"Loadingâ€¦"}
        ]);

        const days = parseInt($("rangeDays").value, 10) || 7;
        const nowMs = Date.now();
        const rangeStartMs = nowMs - days*24*60*60*1000;
        const range7StartMs = nowMs - 7*24*60*60*1000;

        // NOTE:
        // We fetch a large set and compute locally.
        // If you ever exceed ~2000 tickets, we can paginate or add a "createdAt" indexed query.
        const snap = await db.collection("tickets").limit(2000).get();

        const tickets = snap.docs.map(d => ({ id:d.id, ...(d.data()||{}) }));

        // Pipeline states
        const openTickets = [];
        const finalisedTickets = [];
        const pendingGreen = [];
        const submittedSimgrid = [];

        // For charts
        const createdCounts = new Map();
        const finalisedCounts = new Map();

        // Turnaround time samples (created -> finalised) in last 7 days (or chosen range)
        const tatSamplesMs = [];

        // Pending->submit samples (pendingAt -> submittedAt) in chosen range
        const pendingToSubmitSamplesMs = [];

        for (const t of tickets){
          const status = (t.status || "").toString();
          const createdMs = getCreatedMs(t);
          const finalMs = getFinalisedMs(t);

          const isFin = isFinalised(status);
          if (!isFin) openTickets.push({ ...t, createdMs });

          if (isFin) finalisedTickets.push({ ...t, createdMs, finalMs });

          // created daily counts (chosen range window)
          if (createdMs && createdMs >= rangeStartMs){
            const k = dayKey(createdMs);
            createdCounts.set(k, (createdCounts.get(k) || 0) + 1);
          }

          // finalised daily counts (chosen range window) - if we have finalMs, use it; else fallback to created
          if (finalMs && finalMs >= rangeStartMs){
            const k = dayKey(finalMs);
            finalisedCounts.set(k, (finalisedCounts.get(k) || 0) + 1);
          }

          // pending green light (only if pending flag true AND not greenlit AND not submitted)
          const pendingFlag = t.simgridPendingGreenlit === true;
          const greenlit = t.simgridGreenlit === true;
          const submitted = t.simgridSubmitted === true;

          if (pendingFlag && !greenlit && !submitted){
            const pendingMs = getPendingMs(t);
            pendingGreen.push({ ...t, pendingMs });
          }

          if (submitted){
            const submittedMs = getSubmittedMs(t);
            submittedSimgrid.push({ ...t, submittedMs });
          }

          // turnaround samples: created->finalised where finalised happened in last 7 days (hard requirement)
          // Your ask specifically: "turn around time for tickets from open to finalised in last 7 days"
          if (createdMs && finalMs && finalMs >= range7StartMs){
            tatSamplesMs.push(finalMs - createdMs);
          }

          // pending->submit samples: submitted in chosen range and have pendingMs
          const pendingMs = getPendingMs(t);
          const submittedMs = getSubmittedMs(t);
          if (pendingMs && submittedMs && submittedMs >= rangeStartMs){
            pendingToSubmitSamplesMs.push(submittedMs - pendingMs);
          }
        }

        // Compute open ticket age stats
        const openAgesMs = openTickets
          .map(t => t.createdMs ? (nowMs - t.createdMs) : null)
          .filter(x => x != null && x >= 0);

        openTickets.sort((a,b) => (a.createdMs||0) - (b.createdMs||0)); // oldest first
        const oldestOpen = openTickets[0];

        // Pending stats
        pendingGreen.sort((a,b) => (a.pendingMs||0) - (b.pendingMs||0));
        const pendingAgesMs = pendingGreen
          .map(t => t.pendingMs ? (nowMs - t.pendingMs) : null)
          .filter(x => x != null && x >= 0);

        // SimGrid submitted stats (chosen range)
        const submittedInRange = submittedSimgrid.filter(t => (t.submittedMs||0) >= rangeStartMs);
        submittedInRange.sort((a,b) => (b.submittedMs||0) - (a.submittedMs||0));

        // Turnaround stats last 7 days
        const tatAvg = avg(tatSamplesMs);
        const tatMed = median(tatSamplesMs);

        // Pending->Submit stats chosen range
        const p2sAvg = avg(pendingToSubmitSamplesMs);
        const p2sMed = median(pendingToSubmitSamplesMs);

        // KPIs
        renderKPIs([
          {
            label:"Tickets live (open)",
            value:String(openTickets.length),
            sub: openTickets.length ? "Status not finalised" : "No open tickets ðŸŽ‰"
          },
          {
            label:"Oldest open ticket",
            value: oldestOpen?.createdMs ? fmtDuration(nowMs - oldestOpen.createdMs) : "â€”",
            sub: oldestOpen ? `Ticket: ${oldestOpen.id}` : "â€”"
          },
          {
            label:"Avg age of open",
            value: openAgesMs.length ? fmtDuration(avg(openAgesMs)) : "â€”",
            sub: openAgesMs.length ? `Median: ${fmtDuration(median(openAgesMs))}` : "â€”"
          },
          {
            label:"Pending green light",
            value:String(pendingGreen.length),
            sub: pendingGreen.length ? `Oldest: ${fmtDuration(nowMs - (pendingGreen[0].pendingMs||nowMs))}` : "None pending"
          },
          {
            label:"Submitted to SimGrid",
            value:String(submittedInRange.length),
            sub: `In last ${days} day(s)`
          },
          {
            label:"Avg pending â†’ submit",
            value: p2sAvg ? fmtDuration(p2sAvg) : "â€”",
            sub: p2sMed ? `Median: ${fmtDuration(p2sMed)}` : "â€”"
          }
        ]);

        // Tables
        const oldestOpenRows = openTickets.slice(0, 12).map(t => ({
          id: t.id,
          status: t.status || "",
          event: t.event || "",
          accused: t.accused || "",
          reporter: t.reporter || "",
          createdMs: t.createdMs || 0,
          ageLabel: t.createdMs ? fmtDuration(nowMs - t.createdMs) : "â€”"
        }));
        renderOldestOpen(oldestOpenRows);

        const pendingRows = pendingGreen.slice(0, 12).map(t => ({
          id: t.id,
          pendingMs: t.pendingMs || 0,
          pendingAgeLabel: t.pendingMs ? fmtDuration(nowMs - t.pendingMs) : "â€”",
          event: t.event || "",
          accused: t.accused || ""
        }));
        renderPending(pendingRows);

        // CHART 1: daily created vs finalised (chosen range)
        const dateKeys = makeDateKeysBack(Math.min(days, 30)); // keep chart sane
        const createdSeries = dateKeys.map(k => createdCounts.get(k) || 0);
        const finalisedSeries = dateKeys.map(k => finalisedCounts.get(k) || 0);

        $("createdFinalisedHint").textContent = `Last ${Math.min(days,30)} day(s)`;

        chartDaily = new Chart($("chartDaily"), {
          type: "line",
          data: {
            labels: dateKeys,
            datasets: [
              { label: "Created", data: createdSeries, tension: 0.3 },
              { label: "Finalised", data: finalisedSeries, tension: 0.3 }
            ]
          },
          options: {
            responsive: true,
            plugins: { legend: { display: true } },
            scales: {
              y: { beginAtZero: true, ticks: { precision: 0 } }
            }
          }
        });

        // CHART 2: pipeline breakdown (current)
        const finalisedNotSubmitted = finalisedTickets.filter(t => (t.simgridSubmitted !== true));
        const greenlitNotSubmitted = finalisedTickets.filter(t => (t.simgridGreenlit === true && t.simgridSubmitted !== true));
        const pendingCount = pendingGreen.length;
        const openCount = openTickets.length;
        const submittedCount = submittedInRange.length;

        $("pipelineHint").textContent = "Counts are current; submitted is in range";

        chartPipeline = new Chart($("chartPipeline"), {
          type: "bar",
          data: {
            labels: ["Open", "Finalised", "Greenlit", "Pending", `Submitted (${days}d)`],
            datasets: [{
              label: "Tickets",
              data: [
                openCount,
                finalisedTickets.length,
                greenlitNotSubmitted.length,
                pendingCount,
                submittedCount
              ]
            }]
          },
          options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: {
              y: { beginAtZero: true, ticks: { precision: 0 } }
            }
          }
        });

        // CHART 3: turnaround distribution (last 7 days, per your requirement)
        const tatBuckets = new Map([["<2h",0],["2â€“6h",0],["6â€“12h",0],["12â€“24h",0],["1â€“2d",0],["2â€“4d",0],["4d+",0]]);
        for (const ms of tatSamplesMs){
          const hours = ms / (1000*60*60);
          const label = bucketHoursToLabel(hours);
          tatBuckets.set(label, (tatBuckets.get(label)||0) + 1);
        }
        const tatLabels = Array.from(tatBuckets.keys());
        const tatValues = tatLabels.map(k => tatBuckets.get(k) || 0);

        $("tatHint").textContent = tatSamplesMs.length
          ? `Last 7 days â€¢ Avg: ${fmtDuration(tatAvg)} â€¢ Median: ${fmtDuration(tatMed)}`
          : "Last 7 days â€¢ No finalised timestamps found";

        chartTAT = new Chart($("chartTAT"), {
          type: "bar",
          data: {
            labels: tatLabels,
            datasets: [{ label: "Tickets", data: tatValues }]
          },
          options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: {
              y: { beginAtZero: true, ticks: { precision: 0 } }
            }
          }
        });

        // CHART 4: pending -> submit distribution (chosen range)
        const p2sBuckets = new Map([["<2h",0],["2â€“6h",0],["6â€“12h",0],["12â€“24h",0],["1â€“2d",0],["2â€“4d",0],["4d+",0]]);
        for (const ms of pendingToSubmitSamplesMs){
          const hours = ms / (1000*60*60);
          const label = bucketHoursToLabel(hours);
          p2sBuckets.set(label, (p2sBuckets.get(label)||0) + 1);
        }
        const p2sLabels = Array.from(p2sBuckets.keys());
        const p2sValues = p2sLabels.map(k => p2sBuckets.get(k) || 0);

        $("pendingToSubmitHint").textContent = pendingToSubmitSamplesMs.length
          ? `Last ${days} days â€¢ Avg: ${fmtDuration(p2sAvg)} â€¢ Median: ${fmtDuration(p2sMed)}`
          : `Last ${days} days â€¢ No samples (need both simgridPendingAt + simgridSubmittedAt)`;

        chartPendingSubmit = new Chart($("chartPendingSubmit"), {
          type: "bar",
          data: {
            labels: p2sLabels,
            datasets: [{ label: "Tickets", data: p2sValues }]
          },
          options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: {
              y: { beginAtZero: true, ticks: { precision: 0 } }
            }
          }
        });

        toast("Dashboard loaded âœ…");
      }catch(e){
        console.error(e);
        toast("Load failed:\n" + (e?.message || e));
      }
    }

    async function waitForFirebaseReady(maxMs = 8000){
      const start = Date.now();
      while (Date.now() - start < maxMs){
        if (typeof auth !== "undefined" && typeof db !== "undefined" && auth && db) return true;
        await new Promise(r => setTimeout(r, 80));
      }
      return false;
    }

    (async () => {
      const ok = await waitForFirebaseReady();
      if (!ok){
        toast("Firebase not ready.\nCheck firebase-init.js path + console.");
        return;
      }

      auth.onAuthStateChanged(async (user) => {
        try{
          if (!user){ window.location.href = "admin.html"; return; }
          currentEmail = (user.email || "").toLowerCase().trim();

          const adminSnap = await db.collection("admins").doc(currentEmail).get();
          if (!adminSnap.exists){ await auth.signOut(); window.location.href = "admin.html"; return; }

          const data = adminSnap.data() || {};
          const roleText = String(data.role || "").toLowerCase();

          isSimgrid = roleText.includes("simgrid");
          isHeadSteward = roleText.includes("head") || data.headsteward === true;
          isOwner = roleText.includes("owner") || data.owner === true;

          // Owner only (as requested)
          if (!isOwner){
            toast("Access denied (owner only).");
            await auth.signOut();
            window.location.href = "admin.html";
            return;
          }

          const permLabel = "Owner";
          $("permPill").textContent = `Permissions: ${permLabel}`;

          const nameGuess = (currentEmail.split("@")[0] || "").replace(/[._-]+/g, " ").trim();
          const niceName = nameGuess ? nameGuess.replace(/\b\w/g, c => c.toUpperCase()) : "Owner";

          $("welcomeLine").textContent = `Welcome, ${niceName}. This page shows live ops stats + performance.`;
          $("who").textContent = `Signed in as: ${currentEmail} | role: ${data.role || "admin"}`;

          await loadDashboard();
        }catch(e){
          console.error(e);
          toast("Auth/load error:\n" + (e?.message || e));
        }
      });
    })();
  </script>
</body>
</html>
