<!DOCTYPE html>
<html>
<head>
  <title>IFWL Head Steward Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin:0;
      background:
        linear-gradient(rgba(2,6,23,0.72), rgba(2,6,23,0.72)),
        url("./ifwl_bg.webp");
      background-size:cover;
      background-position:center;
      background-attachment:fixed;
    }

    header {
      padding:14px 18px;
      background:#111827;
      color:#fff;
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
    }

    .brand {
      display:flex;
      gap:12px;
      align-items:flex-start;
      min-width:0;
    }
    .brand img {
      width:38px;
      height:38px;
      object-fit:contain;
      margin-top:2px;
      flex:0 0 auto;
      filter: drop-shadow(0 1px 1px rgba(0,0,0,0.25));
    }
    .brandText { min-width:0; }
    header .small { font-size:12px; opacity:0.85; margin-top:4px; line-height:1.2; word-break:break-word; }
    .welcomeLine { font-size:12px; opacity:0.95; margin-top:6px; line-height:1.25; }

    .wrap { display:grid; grid-template-columns: 380px 1fr; gap:14px; padding:14px; }

    .card { background:rgba(255,255,255,0.92); border:1px solid rgba(229,231,235,0.95); border-radius:12px; padding:12px; box-shadow:0 10px 28px rgba(0,0,0,0.18); }
    .title { font-weight:700; font-size:16px; margin:0 0 10px; }
    .muted { color:#6b7280; font-size:12px; }

    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    button { padding:10px 12px; border:1px solid #d1d5db; border-radius:12px; background:#fff; cursor:pointer; }
    button.primary { background:#111827; color:#fff; border-color:#111827; }
    button:disabled { opacity:0.6; cursor:not-allowed; }

    select, input, textarea { padding:10px; border:1px solid #d1d5db; border-radius:12px; width:100%; box-sizing:border-box; font-size:16px; background:#fff; }
    textarea { min-height:70px; resize:vertical; }

    .list { display:flex; flex-direction:column; gap:8px; max-height:680px; overflow:auto; -webkit-overflow-scrolling:touch; }
    .ticket { padding:12px; border:1px solid #e5e7eb; border-radius:12px; cursor:pointer; background:#fff; }
    .ticket:hover { background:#f9fafb; }
    .ticket .id { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; word-break:break-all; }
    .ticket .status { font-size:12px; color:#374151; }
    .ticket.active { border-color:#111827; box-shadow:0 0 0 2px rgba(17,24,39,0.15); }

    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .sec { border:1px solid #e5e7eb; border-radius:12px; padding:12px; background:rgba(250,250,250,0.92); margin-top:10px; }

    .sec h3 { margin:0 0 8px; font-size:14px; }
    .badge { display:inline-block; padding:4px 10px; border-radius:999px; background:#eef2ff; border:1px solid #c7d2fe; font-size:12px; }
    .ok { color:#047857; font-weight:700; }

    .workloadBox {
      border:1px solid #e5e7eb;
      border-radius:12px;
      padding:10px 12px;
      background:rgba(250,250,250,0.92);
      margin:10px 0 12px;
    }
    .workloadTop {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .workloadTitle {
      font-weight:800;
      font-size:13px;
      margin:0;
    }
    .pill {
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:4px 10px;
      border-radius:999px;
      border:1px solid #e5e7eb;
      background:#fff;
      font-size:12px;
      color:#111827;
      white-space:nowrap;
    }
    .pill strong { font-weight:800; }
    .workloadSub { margin-top:6px; font-size:12px; color:#6b7280; line-height:1.25; }

    .needTag {
      display:inline-block;
      margin-top:8px;
      padding:4px 10px;
      border-radius:999px;
      font-size:12px;
      font-weight:800;
      border:1px solid #fca5a5;
      background:#fef2f2;
      color:#991b1b;
    }

    .stmtTag {
      margin-top:8px;
      padding:8px 10px;
      border-radius:12px;
      font-size:12px;
      font-weight:900;
      line-height:1.2;
      border:1px solid #e5e7eb;
      background:#f9fafb;
      color:#111827;
    }
    .stmtOk {
      border-color:#86efac;
      background:#ecfdf5;
      color:#065f46;
    }
    .stmtBad {
      border-color:#fca5a5;
      background:#fef2f2;
      color:#991b1b;
    }
    .stmtTag small {
      display:block;
      margin-top:4px;
      font-weight:800;
      opacity:0.95;
    }

    .infoBox{
      border:1px solid #fde68a;
      background:#fffbeb;
      color:#92400e;
      border-radius:12px;
      padding:10px 12px;
      margin-top:10px;
      font-size:13px;
      line-height:1.25;
      font-weight:800;
    }
    .infoBox small{
      display:block;
      margin-top:6px;
      font-weight:700;
      opacity:0.9;
    }

    .toast { position:fixed; right:16px; bottom:16px; background:#111827; color:#fff; padding:10px 12px; border-radius:12px; opacity:0; transform: translateY(8px); transition: all .18s ease; z-index:9999; max-width: min(520px, calc(100vw - 32px)); white-space: pre-wrap; }
    .toast.show { opacity:1; transform: translateY(0); }

    code { background:#f2f2f2; padding:2px 6px; border-radius:6px; }

    a { color:#111827; }
    a:hover { opacity:0.85; }

    .videoWrap {
      position:relative;
      width:100%;
      padding-top:56.25%;
      background:#000;
      border-radius:12px;
      overflow:hidden;
      border:1px solid #e5e7eb;
      margin-top:10px;
    }
    .videoWrap iframe, .videoWrap video {
      position:absolute;
      top:0; left:0;
      width:100%;
      height:100%;
      border:0;
    }

    /* NEW: steward discussion UI (head steward sees emails) */
    .commentBox {
      border:1px solid #e5e7eb;
      border-radius:12px;
      padding:12px;
      background:#fff;
    }
    .commentMeta {
      font-size:12px;
      color:#6b7280;
      margin-top:4px;
      line-height:1.2;
      word-break: break-word;
    }

    /* --- NEW: Steward audit table --- */
    .auditBox{
      border:1px solid #e5e7eb;
      border-radius:12px;
      padding:10px 12px;
      background:rgba(250,250,250,0.92);
      margin:10px 0 12px;
    }
    .auditTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .auditTitle{
      font-weight:900;
      font-size:13px;
      margin:0;
    }
    .auditMeta{
      margin-top:6px;
      font-size:12px;
      color:#6b7280;
      line-height:1.25;
    }
    .auditTableWrap{
      margin-top:10px;
      overflow:auto;
      border:1px solid #e5e7eb;
      border-radius:12px;
      background:#fff;
    }
    table.auditTable{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      min-width:520px;
    }
    .auditTable th, .auditTable td{
      padding:10px 10px;
      border-bottom:1px solid #f3f4f6;
      font-size:13px;
      text-align:left;
      vertical-align:top;
    }
    .auditTable th{
      position:sticky;
      top:0;
      background:#f9fafb;
      z-index:2;
      font-size:12px;
      color:#111827;
      border-bottom:1px solid #e5e7eb;
    }
    .auditTable tr:last-child td{ border-bottom:0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }

    @media (max-width: 980px) {
      body { background-attachment:scroll; }
      header { flex-direction:column; align-items:stretch; }
      header .row { width:100%; }
      header button { width:100%; }
      .wrap { grid-template-columns: 1fr; }
      .list { max-height:320px; }
      .grid2 { grid-template-columns: 1fr; }
      #publishAllBtn { width:100%; }
      #refreshStatementsBtn { width:100%; }
      #refreshTicketsBtn { width:100%; }
      #filter { font-size:16px; }
      .sec { padding:12px; }
      .brand { align-items:center; }
      .brand img { width:34px; height:34px; margin-top:0; }
      #refreshDiscussionBtn { width:100%; }
      #postDiscussionBtn { width:100%; }
      #refreshAuditBtn { width:100%; }
    }
  </style>
</head>

<body>
  <header>
    <div class="brand">
      <img src="./ifwl_logo.png" alt="IFWL logo">
      <div class="brandText">
        <div style="font-weight:800; font-size:18px;">IFWL Head Steward Dashboard</div>
        <div class="welcomeLine" id="welcomeLine">Welcome ‚Äî loading your profile‚Ä¶</div>
        <div class="small" id="who">Loading‚Ä¶</div>
      </div>
    </div>

    <div class="row">
      <button id="backBtn">Back to Classifier</button>
      <button id="logoutBtn">Sign out</button>
    </div>
  </header>

  <div class="wrap">
    <!-- LEFT -->
    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div class="title" style="margin:0;">Live Workload</div>
        <button id="refreshTicketsBtn">Refresh</button>
      </div>

      <div class="workloadBox" aria-label="Workload summary">
        <div class="workloadTop">
          <div class="workloadTitle">Tickets in progress (steward team)</div>
          <div class="pill" id="workloadPill">Loading‚Ä¶</div>
        </div>
        <div class="workloadSub" id="workloadSub">
          As Head Steward, you oversee all live tickets. ‚ÄúNeeds your CAUSE input‚Äù is optional, but useful for tie-breaks.
        </div>
      </div>

      <!-- NEW: Steward Input (Last 7 Days) -->
      <div class="auditBox" aria-label="Steward input audit">
        <div class="auditTop">
          <div class="auditTitle">Steward Input (Last 7 Days)</div>
          <div class="row">
            <button id="refreshAuditBtn">Refresh</button>
          </div>
        </div>

        <div class="auditMeta" id="auditMeta">Loading‚Ä¶</div>

        <div class="auditTableWrap" id="auditTableWrap" style="display:none;">
          <table class="auditTable" aria-label="Steward input table">
            <thead>
              <tr>
                <th>Steward</th>
                <th>Comments (7d)</th>
                <th>Reviews (7d)</th>
                <th>Tickets Touched (7d)</th>
                <th>Last Active</th>
              </tr>
            </thead>
            <tbody id="auditTbody"></tbody>
          </table>
        </div>

        <div class="muted" style="margin-top:8px;">
          Counts include <code>collectionGroup</code> queries across all tickets.
        </div>
      </div>

      <div class="row" style="margin-bottom:10px;">
        <div style="flex:1; min-width:220px;">
          <label class="muted">Filter</label>
          <select id="filter">
            <option>All (non-finalised)</option>
            <option>Awaiting Review</option>
            <option>In Review</option>
            <option>Ready to Publish</option>
          </select>
        </div>
      </div>

      <div class="list" id="ticketList"></div>
      <div class="muted" style="margin-top:8px;" id="ticketHint"></div>
    </div>

    <!-- RIGHT -->
    <div>
      <div class="card">
        <div class="title" id="selTitle">Select a ticket</div>
        <div class="muted" id="selSub"></div>

        <div class="sec">
          <h3>Ticket Summary</h3>
          <div class="grid2">
            <div><div class="muted">Accused</div><div id="sumAccused">‚Äî</div></div>
            <div><div class="muted">Reporter</div><div id="sumReporter">‚Äî</div></div>
            <div><div class="muted">Competition</div><div id="sumCompetition">‚Äî</div></div>
            <div><div class="muted">Event</div><div id="sumEvent">‚Äî</div></div>
            <div><div class="muted">Rule Breach</div><div id="sumRule">‚Äî</div></div>

            <div>
              <div class="muted">Proof URL</div>
              <div id="sumProof">‚Äî</div>
            </div>
          </div>

          <div id="proofEmbed"></div>

          <div style="margin-top:10px;">
            <div class="muted">Incident</div>
            <textarea id="sumIncident" readonly></textarea>
          </div>
        </div>

        <div class="sec" id="statementsSec">
          <div class="row" style="justify-content:space-between;">
            <h3 style="margin:0;">Player Statements</h3>
            <div class="row" style="width:100%; justify-content:flex-end;">
              <button id="refreshStatementsBtn">Refresh</button>
              <button class="primary" id="publishAllBtn">Publish ALL to Discord</button>
            </div>
          </div>

          <div class="infoBox" aria-label="Head steward note">
            Head Steward view: you can publish statements to Discord and oversee steward reviews.
            <small>Submitting your own CAUSE review is optional ‚Äî but can help break tied outcomes.</small>
          </div>

          <div class="muted" id="statementsHint" style="margin-top:8px;">‚Äî</div>
          <div id="statementsList" style="margin-top:8px; display:flex; flex-direction:column; gap:8px;"></div>
        </div>

        <!-- NEW: Stewards Discussion (Head Steward can see steward email per comment) -->
        <div class="sec" id="discussionSec">
          <div class="row" style="justify-content:space-between;">
            <h3 style="margin:0;">Stewards Discussion</h3>
            <button id="refreshDiscussionBtn">Refresh</button>
          </div>

          <div class="muted" style="margin-top:6px;">
            Head Steward view: comment author email is shown for oversight.
          </div>

          <div id="discussionList" style="margin-top:10px; display:flex; flex-direction:column; gap:8px;"></div>

          <div style="margin-top:10px;">
            <label class="muted">Add a comment</label>
            <textarea id="discussionInput" placeholder="Type your steward comment‚Ä¶"></textarea>
          </div>

          <div class="row" style="justify-content:flex-end; margin-top:10px;">
            <button class="primary" id="postDiscussionBtn">Post Comment</button>
          </div>

          <div class="muted" style="margin-top:8px;">
            Writes to <code>/tickets/&lt;ticket&gt;/steward_comments</code>
          </div>
        </div>

        <div class="sec" id="aggSec">
          <div class="row" style="justify-content:space-between;">
            <h3 style="margin:0;">Aggregate CAUSE (Head Steward)</h3>
            <button id="refreshAggBtn">Refresh</button>
          </div>
          <div class="muted" id="aggHint">Select a ticket to see aggregate.</div>
          <div id="aggBox" style="margin-top:8px;"></div>
        </div>

        <div class="sec" id="reviewSec">
          <div class="row" style="justify-content:space-between;">
            <h3 style="margin:0;">My CAUSE Review (Optional)</h3>
            <div id="myReviewStatus" class="badge">Not submitted</div>
          </div>

          <div class="muted" style="margin-top:6px;">
            As Head Steward, your CAUSE review is <b>optional</b>. If submitted, it may be used as a tie-breaker when steward votes are tied.
          </div>

          <div class="grid2" style="margin-top:10px;">
            <div>
              <label class="muted">C ‚Äî Control (1‚Äì5)</label>
              <select id="cScore"></select>
              <textarea id="cText" placeholder="Has the driver got full control of the car during this incident?"></textarea>
            </div>

            <div>
              <label class="muted">A ‚Äî Awareness (1‚Äì5)</label>
              <select id="aScore"></select>
              <textarea id="aText" placeholder="Has the driver had reasonable time to see what‚Äôs around them?"></textarea>
            </div>

            <div>
              <label class="muted">U ‚Äî User Input (1‚Äì5)</label>
              <select id="uScore"></select>
              <textarea id="uText" placeholder="Do the inputs match what we‚Äôd expect?"></textarea>
            </div>

            <div>
              <label class="muted">S ‚Äî Severity (1‚Äì5)</label>
              <select id="sScore"></select>
              <textarea id="sText" placeholder="How severe was the outcome?"></textarea>
            </div>

            <div>
              <label class="muted">E ‚Äî Environment (1‚Äì5)</label>
              <select id="eScore"></select>
              <textarea id="eText" placeholder="Did conditions affect this incident?"></textarea>
            </div>

            <div>
              <label class="muted">Penalty Code (required)</label>
              <input id="penaltyCode" placeholder="e.g. AC EVO|Technical Infractions - Incorrect Pit Stop Procedure">
              <label class="muted" style="margin-top:8px; display:block;">Private Opinion (Head Steward)</label>
              <textarea id="privateOpinion" placeholder="Saved and visible to Head Steward."></textarea>
            </div>
          </div>

          <div class="row" style="justify-content:flex-end; margin-top:10px;">
            <button id="loadMyReviewBtn">Load My Review</button>
            <button class="primary" id="submitReviewBtn">Submit Review</button>
          </div>

          <div class="muted" style="margin-top:8px;">
            Submitting writes to <code>/tickets/&lt;ticket&gt;/reviews/&lt;yourEmailKey&gt;</code>.
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast">Saved</div>

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <script src="./firebase-init.js"></script>

  <script>
    // ---------- CONFIG ----------
    // UPDATED to your provided webhook
    const DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/1469289068130074675/Ic3VC8dpmNpV6bZOdIEXPSGSwdAauQ1WMcEy8YAimcYraAHcivJYK3e10GR5iR-3FJJP";

    // ---------- helpers ----------
    const $ = (id) => document.getElementById(id);
    const toastEl = $("toast");
    function toast(msg) {
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      setTimeout(() => toastEl.classList.remove("show"), 2200);
    }

    // Show JS errors as toast so you instantly see what's wrong if anything breaks
    window.addEventListener("error", (e) => {
      const msg = (e?.message || "Unknown JS error") + (e?.filename ? `\n${e.filename}:${e.lineno || 0}` : "");
      console.error("JS error:", e);
      toast("JS ERROR:\n" + msg);
    });
    window.addEventListener("unhandledrejection", (e) => {
      console.error("Promise rejection:", e);
      toast("PROMISE ERROR:\n" + (e?.reason?.message || e?.reason || "Unknown"));
    });

    function safeKey(email) { return (email || "").replaceAll("/", "_").replaceAll("\\", "_").trim(); }

    // NEW: mask email for Discord audit output (keeps your UI unchanged)
    function maskEmail(email) {
      const e = String(email || "").trim();
      if (!e) return "";
      const at = e.indexOf("@");
      if (at <= 0) return e;
      return e.slice(0, at); // only local part
    }

    function optionList() {
      return [
        {v:1, t:"1 ‚Äî minimal / none"},
        {v:2, t:"2 ‚Äî low"},
        {v:3, t:"3 ‚Äî moderate"},
        {v:4, t:"4 ‚Äî high"},
        {v:5, t:"5 ‚Äî extreme"},
      ];
    }
    function fillScores() {
      for (const id of ["cScore","aScore","uScore","sScore","eScore"]) {
        const sel = $(id);
        sel.innerHTML = "";
        for (const o of optionList()) {
          const opt = document.createElement("option");
          opt.value = o.v;
          opt.textContent = o.t;
          sel.appendChild(opt);
        }
        sel.value = "1";
      }
    }
    fillScores();

    function escapeHtml(s) {
      return (s || "").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
    }

    function clampScore(v) {
      const n = parseInt(v || 1, 10);
      return Math.min(5, Math.max(1, isNaN(n) ? 1 : n));
    }

    // --- U reverse mapping ---
    function reverseScore(v) { return 6 - clampScore(v); }
    function unreverseScore(v) { return 6 - clampScore(v); }

    function avg(nums) {
      const xs = nums.filter(x => x > 0);
      if (!xs.length) return 0;
      const v = xs.reduce((a,b)=>a+b,0) / xs.length;
      return Math.round(v * 100) / 100;
    }

    function suggestTier(total) {
      if (total <= 0) return "No data";
      if (total < 2.0) return "Racing Incident / No Action";
      if (total < 3.0) return "Minor Penalty / Warning";
      if (total < 3.7) return "Moderate Penalty";
      if (total < 4.4) return "Severe Penalty";
      return "Extreme / Disqualification Consideration";
    }

    function isFinalised(status) {
      const s = (status || "").trim().toLowerCase();
      return s === "finalised";
    }

    function getUserInputScoreForAggregate(review) {
      const stored = clampScore(review?.CAUSE?.userInput?.score || 0);
      if (!stored) return 0;

      const reversedFlag = review?.CAUSE?.userInput?.reversed === true;
      const schema2 = (review?.schemaVersion || 0) >= 2;

      // New schema: stored already reversed => use as-is
      if (reversedFlag || schema2) return stored;

      // Legacy: stored was UI scale => reverse for scoring
      return reverseScore(stored);
    }

    function normalizeUrl(u) {
      const s = (u || "").trim();
      if (!s) return "";
      if (!/^https?:\/\//i.test(s) && !s.startsWith("mailto:")) return "https://" + s;
      return s;
    }

    function youtubeIdFromUrl(url) {
      try {
        const u = new URL(url);
        const host = u.hostname.toLowerCase();
        if (host === "youtu.be") return (u.pathname || "").replace("/", "").trim();
        if (host.includes("youtube.com")) {
          if (u.pathname.startsWith("/watch")) return (u.searchParams.get("v") || "").trim();
          if (u.pathname.startsWith("/shorts/")) return (u.pathname.split("/shorts/")[1] || "").split(/[/?#]/)[0].trim();
          if (u.pathname.startsWith("/embed/")) return (u.pathname.split("/embed/")[1] || "").split(/[/?#]/)[0].trim();
        }
      } catch {}
      return "";
    }

    function renderProof(proofUrl) {
      const proofEl = $("sumProof");
      const embedEl = $("proofEmbed");
      embedEl.innerHTML = "";

      const url = normalizeUrl(proofUrl);
      if (!url) { proofEl.textContent = "‚Äî"; return; }

      proofEl.innerHTML = `<a href="${escapeHtml(url)}" target="_blank" rel="noopener">Open proof link</a>`;

      const yt = youtubeIdFromUrl(url);
      if (yt) {
        embedEl.innerHTML = `
          <div class="videoWrap" aria-label="Proof video">
            <iframe
              src="https://www.youtube.com/embed/${encodeURIComponent(yt)}"
              title="Proof video"
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
              allowfullscreen></iframe>
          </div>
        `;
        return;
      }

      if (/\.(mp4|webm|ogg)(\?|#|$)/i.test(url)) {
        embedEl.innerHTML = `
          <div class="videoWrap" aria-label="Proof video">
            <video controls src="${escapeHtml(url)}"></video>
          </div>
        `;
      }
    }

    async function doesMyReviewExist(ticketId, email) {
      try {
        const reviewId = safeKey(email);
        if (!reviewId) return false;
        const ref = db.collection("tickets").doc(ticketId).collection("reviews").doc(reviewId);
        const snap = await ref.get();
        return snap.exists;
      } catch (e) {
        console.warn("Review check failed:", ticketId, e);
        return false;
      }
    }

    // statement status (accused + reporter only)
    const statementStatusCache = new Map();
    async function getAccusedReporterStatementStatus(ticketId) {
      if (statementStatusCache.has(ticketId)) return statementStatusCache.get(ticketId);

      const col = db.collection("tickets").doc(ticketId).collection("player_statements");

      try {
        const snap = await col.where("role", "in", ["accused", "reporter"]).get();
        let accused = false, reporter = false;
        snap.forEach(doc => {
          const d = doc.data() || {};
          const role = String(d.role || "").toLowerCase().trim();
          const statement = String(d.statement || "").trim();
          if (!statement) return;
          if (role === "accused") accused = true;
          if (role === "reporter") reporter = true;
        });
        const res = { accused, reporter };
        statementStatusCache.set(ticketId, res);
        return res;
      } catch {
        const snap = await col.get();
        let accused = false, reporter = false;
        snap.forEach(doc => {
          const d = doc.data() || {};
          const role = String(d.role || "").toLowerCase().trim();
          const statement = String(d.statement || "").trim();
          if (!statement) return;
          if (role === "accused") accused = true;
          if (role === "reporter") reporter = true;
        });
        const res = { accused, reporter };
        statementStatusCache.set(ticketId, res);
        return res;
      }
    }

    function renderStatementTag(el, st) {
      const accusedOk = !!st?.accused;
      const reporterOk = !!st?.reporter;

      if (accusedOk && reporterOk) {
        el.className = "stmtTag stmtOk";
        el.innerHTML = `Statements: ‚úÖ Accused + Reporter<br><small>Ready for review</small>`;
        return;
      }

      const missing = [];
      if (!accusedOk) missing.push("Accused");
      if (!reporterOk) missing.push("Reporter");

      el.className = "stmtTag stmtBad";
      el.innerHTML = `Statements: ‚ùå Missing ${missing.join(" + ")}<br><small>Awaiting required statements</small>`;
    }

    // ---------- NEW: Patreon Audit (Discord webhook post) ----------
    async function discordPost(content) {
      if (!DISCORD_WEBHOOK_URL.startsWith("https://discord.com/api/webhooks/")) {
        throw new Error("Webhook invalid");
      }
      const resp = await fetch(DISCORD_WEBHOOK_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ content })
      });
      if (!resp.ok) {
        const txt = await resp.text();
        throw new Error(`Discord publish failed: ${resp.status} ${resp.statusText} ${txt}`);
      }
    }

    function splitDiscordMessages(fullText, maxLen = 1900) {
      // keep a bit under 2000 to be safe
      const lines = String(fullText || "").split("\n");
      const chunks = [];
      let cur = "";
      for (const line of lines) {
        const add = (cur ? "\n" : "") + line;
        if ((cur.length + add.length) > maxLen) {
          if (cur.trim()) chunks.push(cur);
          cur = line;
        } else {
          cur += add;
        }
      }
      if (cur.trim()) chunks.push(cur);
      return chunks.length ? chunks : [fullText.slice(0, maxLen)];
    }

    async function computeAggregateForTicket(ticketId) {
      const col = db.collection("tickets").doc(ticketId).collection("reviews");
      const snap = await col.get();
      if (snap.empty) return null;

      const reviews = snap.docs.map(d => d.data() || {});
      const scores = (key) => reviews.map(r => clampScore(r?.CAUSE?.[key]?.score || 0));

      const avgC = avg(scores("control"));
      const avgA = avg(scores("awareness"));
      const avgU = avg(reviews.map(r => getUserInputScoreForAggregate(r)));
      const avgS = avg(scores("severity"));
      const avgE = avg(scores("environment"));

      const total = avg([avgC, avgA, avgU, avgS, avgE]);
      const tier = suggestTier(total);

      return { reviewsCount: reviews.length, avgC, avgA, avgU, avgS, avgE, total, tier };
    }

    async function fetchStewardComments(ticketId) {
      const col = db.collection("tickets").doc(ticketId).collection("steward_comments");
      const snap = await col.orderBy("createdAt", "asc").limit(250).get();
      if (snap.empty) return [];

      const rows = [];
      snap.forEach(doc => {
        const d = doc.data() || {};
        const text = String(d.text || "").trim();
        if (!text) return;

        const ts = d.createdAt && d.createdAt.toDate ? d.createdAt.toDate() : null;
        const when = ts ? ts.toLocaleString() : "‚Äî";
        const author = String(d.authorKey || d.stewardEmail || "unknown").trim() || "unknown";

        rows.push({ when, author, text });
      });
      return rows;
    }

    async function postPatreonAudit(ticketId) {
      toast("Building Patreon audit‚Ä¶");

      const ticketSnap = await db.collection("tickets").doc(ticketId).get();
      if (!ticketSnap.exists) throw new Error("Ticket not found");

      const t = ticketSnap.data() || {};
      const status = (t.status || "Under Review");
      const event = (t.event || "‚Äî");
      const accused = (t.accused || "‚Äî");
      const reporter = (t.reporter || "‚Äî");

      const agg = await computeAggregateForTicket(ticketId);
      const comments = await fetchStewardComments(ticketId);

      const header =
`üßæ **IFWL Patreon Audit**
**Ticket:** \`${ticketId}\`
**Status:** ${status}
**Event:** ${event}
**Accused:** ${accused}
**Reporter:** ${reporter}`;

      const aggBlock = agg
        ? `\n\nüéØ **CAUSE Aggregate** (reviews: ${agg.reviewsCount})
**Total:** ${agg.total}  ‚Äî  *${agg.tier}*
C:${agg.avgC}  A:${agg.avgA}  U:${agg.avgU}  S:${agg.avgS}  E:${agg.avgE}`
        : `\n\nüéØ **CAUSE Aggregate**
No reviews submitted yet.`;

      const commentsHeader = `\n\nüí¨ **Steward Comments** (${comments.length})`;
      const commentLines = comments.length
        ? comments.map(c => {
            const who = maskEmail(c.author);
            // keep each comment reasonably sized (Discord is strict)
            const text = String(c.text || "").replace(/\s+/g, " ").trim();
            const clipped = text.length > 350 ? text.slice(0, 350) + "‚Ä¶" : text;
            return `- [${c.when}] ${who}: ${clipped}`;
          }).join("\n")
        : `- None`;

      const full = header + aggBlock + commentsHeader + "\n" + commentLines;

      const chunks = splitDiscordMessages(full, 1900);
      for (let i = 0; i < chunks.length; i++) {
        const prefix = chunks.length > 1 ? `(${i+1}/${chunks.length}) ` : "";
        await discordPost(prefix + chunks[i]);
      }
    }

    // ---------- state ----------
    let currentUser = null;
    let currentEmail = "";
    let isHead = false;
    let selectedTicketId = "";
    let selectedTicketSnap = null;

    // ---------- UI refs ----------
    const ticketListEl = $("ticketList");
    const ticketHintEl = $("ticketHint");
    const filterEl = $("filter");
    const submitReviewBtn = $("submitReviewBtn");
    const loadMyReviewBtn = $("loadMyReviewBtn");
    const publishAllBtn = $("publishAllBtn");
    const workloadPillEl = $("workloadPill");
    const workloadSubEl = $("workloadSub");
    const welcomeLineEl = $("welcomeLine");

    // NEW: discussion UI refs
    const refreshDiscussionBtn = $("refreshDiscussionBtn");
    const postDiscussionBtn = $("postDiscussionBtn");

    // ---------- navigation ----------
    $("backBtn").onclick = () => window.location.href = "index.html";
    $("logoutBtn").onclick = async () => { await auth.signOut(); window.location.href = "admin.html"; };
    $("refreshTicketsBtn").onclick = () => loadTickets();
    $("refreshStatementsBtn").onclick = () => loadStatements();
    $("refreshAggBtn").onclick = () => refreshAggregate();
    if (refreshDiscussionBtn) refreshDiscussionBtn.onclick = () => loadDiscussion();
    $("refreshAuditBtn").onclick = () => loadStewardAudit7d();
    filterEl.onchange = () => loadTickets();
    loadMyReviewBtn.onclick = () => loadMyReview();
    submitReviewBtn.onclick = () => submitMyReview();
    publishAllBtn.onclick = () => publishAllStatements();
    if (postDiscussionBtn) postDiscussionBtn.onclick = () => postDiscussion();

    function passesFilter(status) {
      const f = filterEl.value;
      const s = (status || "").trim().toLowerCase();
      if (f === "All (non-finalised)") return s !== "finalised";
      if (f === "Awaiting Review") return s === "" || s === "under review" || s === "awaiting review";
      if (f === "In Review") return s === "in review";
      if (f === "Ready to Publish") return s === "ready to publish";
      return true;
    }

    async function loadTickets() {
      ticketListEl.innerHTML = "";
      ticketHintEl.textContent = "Loading tickets‚Ä¶";
      workloadPillEl.textContent = "Loading‚Ä¶";
      workloadSubEl.textContent = "As Head Steward, you oversee all live tickets. ‚ÄúNeeds your CAUSE input‚Äù is optional, but useful for tie-breaks.";

      statementStatusCache.clear();

      const snap = await db.collection("tickets").limit(200).get();
      const tickets = snap.docs.map(d => {
        const data = d.data() || {};
        const status = (data.status || "").trim();
        return { id: d.id, data, status };
      });

      const liveTickets = tickets.filter(t => !isFinalised(t.status));
      const liveCount = liveTickets.length;

      const myReviewResults = await Promise.all(
        liveTickets.map(async (t) => ({ id: t.id, hasMine: await doesMyReviewExist(t.id, currentEmail) }))
      );
      const myReviewMap = new Map(myReviewResults.map(x => [x.id, x.hasMine]));
      const needsMyInputCount = liveTickets.filter(t => !myReviewMap.get(t.id)).length;

      workloadPillEl.innerHTML = `Live: <strong>${liveCount}</strong> ‚Ä¢ Needs your input: <strong>${needsMyInputCount}</strong>`;

      if (liveCount === 0) workloadSubEl.textContent = "No live tickets found. You're all caught up ‚úÖ";
      else if (needsMyInputCount === 0) workloadSubEl.textContent = "All live tickets already have your optional Head Steward review ‚úÖ";
      else workloadSubEl.textContent = "‚ÄúNeeds your CAUSE input‚Äù means you haven't submitted your optional Head Steward review.";

      let shown = 0;

      for (const t of tickets) {
        if (!passesFilter(t.status)) continue;

        const needsMyInput = (!isFinalised(t.status)) && !myReviewMap.get(t.id);

        const div = document.createElement("div");
        div.className = "ticket" + (t.id === selectedTicketId ? " active" : "");
        div.innerHTML = `
          <div class="id">${escapeHtml(t.id)}</div>
          <div class="status"><b>Status:</b> ${escapeHtml(t.status || "Under Review")}</div>
          <div class="muted" style="margin-top:4px;">
            ${t.data.event ? `<b>Event:</b> ${escapeHtml(t.data.event)}` : ""}
            ${t.data.accused ? ` | <b>Accused:</b> ${escapeHtml(t.data.accused)}` : ""}
          </div>
          <div class="stmtTag" id="stmt_${escapeHtml(t.id)}">Statements: Checking‚Ä¶<small>Accused + Reporter</small></div>
          ${needsMyInput ? `<div class="needTag">Needs your CAUSE input (optional)</div>` : ""}

          <!-- NEW: Patreon Audit button on every ticket -->
          <div class="row" style="justify-content:flex-end; margin-top:10px;">
            <button class="primary patreonAuditBtn" data-ticket="${escapeHtml(t.id)}">Patreon Audit</button>
          </div>
        `;

        div.onclick = async () => {
          selectedTicketId = t.id;
          await selectTicket(t.id);
          [...ticketListEl.querySelectorAll(".ticket")].forEach(x => x.classList.remove("active"));
          div.classList.add("active");
        };

        // Wire Patreon Audit button (stop it triggering ticket select)
        const auditBtn = div.querySelector(".patreonAuditBtn");
        if (auditBtn) {
          auditBtn.addEventListener("click", async (ev) => {
            ev.preventDefault();
            ev.stopPropagation();

            const ticketId = auditBtn.getAttribute("data-ticket");
            if (!ticketId) return;

            auditBtn.disabled = true;
            const original = auditBtn.textContent;
            auditBtn.textContent = "Posting‚Ä¶";
            try {
              await postPatreonAudit(ticketId);
              toast("Patreon audit posted ‚úÖ");
            } catch (e) {
              console.error("Patreon audit failed:", e);
              toast("Audit failed:\n" + (e?.message || e));
            } finally {
              auditBtn.textContent = original;
              auditBtn.disabled = false;
            }
          });
        }

        ticketListEl.appendChild(div);
        shown++;

        (async () => {
          const tagEl = div.querySelector(`[id="stmt_${CSS.escape(t.id)}"]`);
          if (!tagEl) return;
          const st = await getAccusedReporterStatementStatus(t.id);
          renderStatementTag(tagEl, st);
        })().catch(() => {});
      }

      ticketHintEl.textContent = `Showing ${shown} ticket(s). (Max 200 fetched).`;
    }

    async function selectTicket(ticketId) {
      $("selTitle").textContent = `Ticket: ${ticketId}`;
      $("selSub").textContent = "";
      $("myReviewStatus").textContent = "Not submitted";
      $("myReviewStatus").className = "badge";

      $("aggHint").textContent = "Loading aggregate‚Ä¶";
      $("aggBox").innerHTML = "";
      $("statementsHint").textContent = "Loading statements‚Ä¶";
      $("statementsList").innerHTML = "";

      // NEW: reset discussion UI
      $("discussionList").innerHTML = `<div class="muted">Loading comments‚Ä¶</div>`;
      $("discussionInput").value = "";

      const ref = db.collection("tickets").doc(ticketId);
      selectedTicketSnap = await ref.get();
      if (!selectedTicketSnap.exists) { toast("Ticket not found"); return; }

      const t = selectedTicketSnap.data() || {};
      $("sumAccused").textContent = t.accused || "‚Äî";
      $("sumReporter").textContent = t.reporter || "‚Äî";
      $("sumCompetition").textContent = t.competition || "‚Äî";
      $("sumEvent").textContent = t.event || "‚Äî";
      $("sumRule").textContent = t.ruleBreach || "‚Äî";
      renderProof(t.proofUrl || "");
      $("sumIncident").value = t.fullIncident || "";
      $("selSub").textContent = `Accused: ${t.accused || "-"} | Event: ${t.event || "-"}`;

      await loadStatements();
      await loadDiscussion();
      await loadMyReview();
      await refreshAggregate();
    }

    async function loadStatements() {
      if (!selectedTicketId) { $("statementsHint").textContent = "Select a ticket to view statements."; return; }
      $("statementsList").innerHTML = "";
      $("statementsHint").textContent = "Loading statements‚Ä¶";

      const col = db.collection("tickets").doc(selectedTicketId).collection("player_statements");
      const snap = await col.get();

      if (snap.empty) { $("statementsHint").textContent = "No player statements submitted yet."; return; }

      const rows = snap.docs.map(d => {
        const x = d.data() || {};
        const role = (x.role || "").trim();
        const name = (x.name || "").trim();
        const statement = (x.statement || "").trim();
        const ts = x.submittedAt && x.submittedAt.toDate ? x.submittedAt.toDate() : null;
        const when = ts ? ts.toLocaleString() : "";
        return { role, name, statement, when };
      }).filter(r => r.statement);

      const order = { accused:1, reporter:2, witness:3 };
      rows.sort((a,b) => (order[a.role?.toLowerCase()]||99)-(order[b.role?.toLowerCase()]||99));

      for (const r of rows) {
        const box = document.createElement("div");
        box.style.border = "1px solid #e5e7eb";
        box.style.borderRadius = "12px";
        box.style.padding = "12px";
        box.style.background = "#fff";

        const publishBtn = document.createElement("button");
        publishBtn.textContent = "Publish";
        publishBtn.style.minWidth = "110px";
        publishBtn.onclick = async () => {
          publishBtn.disabled = true;
          const original = publishBtn.textContent;
          publishBtn.textContent = "Publishing‚Ä¶";
          try {
            await publishStatementToDiscord(selectedTicketId, r);
            $("statementsHint").textContent = `Published ‚úÖ (${(r.role||"").toUpperCase()})`;
          } catch (e) {
            $("statementsHint").textContent = "Publish failed: " + (e?.message || e);
          } finally {
            publishBtn.textContent = original;
            publishBtn.disabled = false;
          }
        };

        const top = document.createElement("div");
        top.className = "row";
        top.style.justifyContent = "space-between";

        const left = document.createElement("div");
        left.innerHTML = `<b>${escapeHtml((r.role||"").toUpperCase())} ‚Äî ${escapeHtml(r.name || "")}</b><div class="muted" style="margin-top:4px;">${escapeHtml(r.when || "")}</div>`;

        const right = document.createElement("div");
        right.className = "row";
        right.appendChild(publishBtn);

        top.appendChild(left);
        top.appendChild(right);

        const body = document.createElement("div");
        body.style.marginTop = "10px";
        body.style.whiteSpace = "pre-wrap";
        body.textContent = r.statement;

        box.appendChild(top);
        box.appendChild(body);
        $("statementsList").appendChild(box);
      }

      $("statementsHint").textContent = `Loaded ${rows.length} statement(s).`;
    }

    async function publishAllStatements() {
      if (!selectedTicketId) { toast("Select a ticket first"); return; }

      const btn = publishAllBtn;
      btn.disabled = true;
      const original = btn.textContent;
      btn.textContent = "Publishing‚Ä¶";
      $("statementsHint").textContent = "Publishing all‚Ä¶";

      try {
        const col = db.collection("tickets").doc(selectedTicketId).collection("player_statements");
        const snap = await col.get();
        const rows = snap.docs.map(d => d.data() || {}).map(x => ({
          role: (x.role||"").trim(),
          name: (x.name||"").trim(),
          statement: (x.statement||"").trim(),
          when: x.submittedAt && x.submittedAt.toDate ? x.submittedAt.toDate().toLocaleString() : ""
        })).filter(x => x.statement);

        for (const r of rows) await publishStatementToDiscord(selectedTicketId, r);

        $("statementsHint").textContent = "Published all statements ‚úÖ";
        toast("Published all ‚úÖ");
        await loadTickets();
      } catch (e) {
        $("statementsHint").textContent = "Publish failed: " + (e?.message || e);
        toast("Publish failed");
      } finally {
        btn.textContent = original;
        btn.disabled = false;
      }
    }

    async function publishStatementToDiscord(ticketId, row) {
      if (!DISCORD_WEBHOOK_URL.startsWith("https://discord.com/api/webhooks/")) {
        throw new Error("Webhook invalid");
      }

      const role = (row.role || "").slice(0, 40);
      const name = (row.name || "").slice(0, 120);
      const statement = (row.statement || "").slice(0, 1500);

      const content =
`üìÑ **Player Statement**
**Ticket:** \`${ticketId}\`
**Role:** **${role}**
**Name:** ${name}
**Submitted:** ${row.when || ""}

> ${statement}`;

      const resp = await fetch(DISCORD_WEBHOOK_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ content })
      });

      if (!resp.ok) {
        const txt = await resp.text();
        throw new Error(`Discord publish failed: ${resp.status} ${resp.statusText} ${txt}`);
      }
    }

    // ---------- NEW: steward discussion (head steward sees author email) ----------
    async function loadDiscussion() {
      const list = $("discussionList");

      if (!selectedTicketId) {
        list.innerHTML = `<div class="muted">Select a ticket to view steward comments.</div>`;
        return;
      }

      list.innerHTML = `<div class="muted">Loading comments‚Ä¶</div>`;

      try {
        const col = db.collection("tickets").doc(selectedTicketId).collection("steward_comments");
        const snap = await col.orderBy("createdAt", "asc").limit(250).get();

        if (snap.empty) {
          list.innerHTML = `<div class="muted">No steward comments yet.</div>`;
          return;
        }

        list.innerHTML = "";
        snap.forEach(doc => {
          const d = doc.data() || {};
          const text = String(d.text || "").trim();
          if (!text) return;

          const ts = d.createdAt && d.createdAt.toDate ? d.createdAt.toDate() : null;
          const when = ts ? ts.toLocaleString() : "‚Äî";

          // Head steward can see who posted (authorKey or stewardEmail fallback)
          const author = String(d.authorKey || d.stewardEmail || "unknown").trim();

          const box = document.createElement("div");
          box.className = "commentBox";
          box.innerHTML = `
            <div><b>Stewards comment</b></div>
            <div class="commentMeta">${escapeHtml(when)}${author ? ` ‚Ä¢ <b>${escapeHtml(author)}</b>` : ""}</div>
          `;

          const body = document.createElement("div");
          body.style.marginTop = "10px";
          body.style.whiteSpace = "pre-wrap";
          body.textContent = text;

          box.appendChild(body);
          list.appendChild(box);
        });
      } catch (e) {
        console.error("loadDiscussion failed:", e);
        list.innerHTML = `<div class="muted">Failed to load comments (check console).</div>`;
      }
    }

    async function postDiscussion() {
      if (!selectedTicketId) { toast("Select a ticket first"); return; }

      const input = $("discussionInput");
      const text = (input.value || "").trim();
      if (!text) { toast("Type a comment first"); return; }

      postDiscussionBtn.disabled = true;
      const original = postDiscussionBtn.textContent;
      postDiscussionBtn.textContent = "Posting‚Ä¶";

      try {
        const col = db.collection("tickets").doc(selectedTicketId).collection("steward_comments");

        // Store authorKey for oversight/audit (head steward view shows this)
        const authorKey = safeKey(currentEmail);

        await col.add({
          text,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          authorKey
        });

        input.value = "";
        toast("Comment posted ‚úÖ");
        await loadDiscussion();
      } catch (e) {
        toast("Post failed: " + (e?.message || e));
      } finally {
        postDiscussionBtn.textContent = original;
        postDiscussionBtn.disabled = false;
      }
    }

    // ---------- NEW: Steward Input Audit (Last 7 Days) ----------
    async function loadStewardAudit7d() {
      const metaEl = $("auditMeta");
      const wrapEl = $("auditTableWrap");
      const bodyEl = $("auditTbody");

      wrapEl.style.display = "none";
      bodyEl.innerHTML = "";
      metaEl.textContent = "Loading steward input‚Ä¶";

      const now = Date.now();
      const sinceMs = now - (7 * 24 * 60 * 60 * 1000);
      const since = firebase.firestore.Timestamp.fromDate(new Date(sinceMs));

      // Map: key -> stats
      const m = new Map();
      function getOrCreate(key, label) {
        if (!m.has(key)) {
          m.set(key, {
            key,
            label: label || key,
            comments: 0,
            reviews: 0,
            tickets: new Set(),
            lastActiveMs: 0
          });
        }
        return m.get(key);
      }

      // Extract ticketId from /tickets/<ticketId>/<subcollection>/<docId>
      function ticketIdFromDocRef(docRef) {
        try {
          return docRef?.parent?.parent?.id || "";
        } catch {
          return "";
        }
      }

      let commentDocs = 0;
      let reviewDocs = 0;

      try {
        // Comments (7 days) ‚Äî collectionGroup
        const commentsSnap = await db
          .collectionGroup("steward_comments")
          .where("createdAt", ">=", since)
          .get();

        commentDocs = commentsSnap.size;

        commentsSnap.forEach(doc => {
          const d = doc.data() || {};
          const ts = d.createdAt && d.createdAt.toDate ? d.createdAt.toDate() : null;
          if (!ts) return;

          const author = String(d.authorKey || d.stewardEmail || "unknown").trim() || "unknown";
          const key = safeKey(author) || "unknown";
          const ticketId = ticketIdFromDocRef(doc.ref);

          const s = getOrCreate(key, author);
          s.comments += 1;
          if (ticketId) s.tickets.add(ticketId);

          const tms = ts.getTime();
          if (tms > s.lastActiveMs) s.lastActiveMs = tms;
        });

        // Reviews (7 days)
        const reviewsSnap = await db
          .collectionGroup("reviews")
          .where("submittedAt", ">=", since)
          .get();

        reviewDocs = reviewsSnap.size;

        reviewsSnap.forEach(doc => {
          const d = doc.data() || {};
          const ts = d.submittedAt && d.submittedAt.toDate ? d.submittedAt.toDate() : null;
          if (!ts) return;

          const author = String(d.stewardEmail || d.authorKey || "unknown").trim() || "unknown";
          const key = safeKey(author) || "unknown";
          const ticketId = ticketIdFromDocRef(doc.ref);

          const s = getOrCreate(key, author);
          s.reviews += 1;
          if (ticketId) s.tickets.add(ticketId);

          const tms = ts.getTime();
          if (tms > s.lastActiveMs) s.lastActiveMs = tms;
        });

        const rows = [...m.values()]
          .filter(x => (x.comments + x.reviews) > 0)
          .sort((a,b) => ((b.comments + b.reviews) - (a.comments + a.reviews)) || (b.lastActiveMs - a.lastActiveMs));

        if (!rows.length) {
          metaEl.textContent = "No steward activity in the last 7 days.";
          return;
        }

        for (const r of rows) {
          const tr = document.createElement("tr");
          const last = r.lastActiveMs ? new Date(r.lastActiveMs).toLocaleString() : "‚Äî";
          const ticketsTouched = r.tickets.size;

          tr.innerHTML = `
            <td class="mono">${escapeHtml(r.label)}</td>
            <td><b>${r.comments}</b></td>
            <td><b>${r.reviews}</b></td>
            <td><b>${ticketsTouched}</b></td>
            <td>${escapeHtml(last)}</td>
          `;
          bodyEl.appendChild(tr);
        }

        wrapEl.style.display = "block";
        metaEl.textContent = `Loaded. Comments scanned: ${commentDocs} ‚Ä¢ Reviews scanned: ${reviewDocs} ‚Ä¢ Window: last 7 days.`;
      } catch (e) {
        console.error("loadStewardAudit7d failed:", e);
        metaEl.textContent = "Audit failed. Likely missing Firestore index for collectionGroup query, or rules deny access. Check console for the exact Firebase error (it often includes a 'create index' link).";
      }
    }

    async function loadMyReview() {
      if (!selectedTicketId) return;

      const reviewId = safeKey(currentEmail);
      const ref = db.collection("tickets").doc(selectedTicketId).collection("reviews").doc(reviewId);
      const snap = await ref.get();

      if (!snap.exists) {
        $("myReviewStatus").textContent = "Not submitted";
        $("myReviewStatus").className = "badge";
        return;
      }

      const d = snap.data() || {};
      const cause = d.CAUSE || {};

      $("cScore").value = String(clampScore(cause.control?.score));
      $("cText").value = cause.control?.text || "";

      $("aScore").value = String(clampScore(cause.awareness?.score));
      $("aText").value = cause.awareness?.text || "";

      const uObj = cause.userInput || {};
      const uStored = clampScore(uObj.score);
      const isReversed = (uObj.reversed === true) || ((d.schemaVersion || 0) >= 2);
      $("uScore").value = String(isReversed ? unreverseScore(uStored) : uStored);
      $("uText").value = uObj.text || "";

      $("sScore").value = String(clampScore(cause.severity?.score));
      $("sText").value = cause.severity?.text || "";

      $("eScore").value = String(clampScore(cause.environment?.score));
      $("eText").value = cause.environment?.text || "";

      $("penaltyCode").value = d.penaltyCode || "";
      $("privateOpinion").value = d.privateOpinion || "";

      $("myReviewStatus").textContent = "Submitted ‚úÖ";
      $("myReviewStatus").className = "badge ok";
      toast("Loaded your review");
    }

    async function submitMyReview() {
      if (!selectedTicketId) { toast("Select a ticket first"); return; }

      const pen = ($("penaltyCode").value || "").trim();
      if (!pen) { toast("Penalty code required"); return; }

      submitReviewBtn.disabled = true;
      const original = submitReviewBtn.textContent;
      submitReviewBtn.textContent = "Submitting‚Ä¶";

      try {
        const reviewId = safeKey(currentEmail);
        const ref = db.collection("tickets").doc(selectedTicketId).collection("reviews").doc(reviewId);

        const uUi = Number($("uScore").value);
        const uStored = reverseScore(uUi);

        const review = {
          stewardEmail: currentEmail,
          submittedAt: firebase.firestore.Timestamp.fromDate(new Date()),
          isFinal: true,
          schemaVersion: 2,
          CAUSE: {
            control:      { score: Number($("cScore").value), text: ($("cText").value||"").trim() },
            awareness:    { score: Number($("aScore").value), text: ($("aText").value||"").trim() },
            userInput:    { score: uStored, text: ($("uText").value||"").trim(), reversed: true },
            severity:     { score: Number($("sScore").value), text: ($("sText").value||"").trim() },
            environment:  { score: Number($("eScore").value), text: ($("eText").value||"").trim() },
          },
          penaltyCode: pen,
          privateOpinion: ($("privateOpinion").value || "").trim()
        };

        await ref.set(review, { merge: true });

        $("myReviewStatus").textContent = "Submitted ‚úÖ";
        $("myReviewStatus").className = "badge ok";

        toast(`Review submitted ‚úÖ (U stored: ${uStored})`);
        await loadTickets();
        await refreshAggregate();
      } catch (e) {
        toast("Submit failed: " + (e?.message || e));
      } finally {
        submitReviewBtn.textContent = original;
        submitReviewBtn.disabled = false;
      }
    }

    async function refreshAggregate() {
      if (!selectedTicketId) return;

      $("aggHint").textContent = "Calculating‚Ä¶";
      $("aggBox").innerHTML = "";

      try {
        const col = db.collection("tickets").doc(selectedTicketId).collection("reviews");
        const snap = await col.get();

        if (snap.empty) { $("aggHint").textContent = "No reviews submitted yet."; return; }

        const reviews = snap.docs.map(d => d.data() || {});
        const scores = (key) => reviews.map(r => clampScore(r?.CAUSE?.[key]?.score || 0));

        const avgC = avg(scores("control"));
        const avgA = avg(scores("awareness"));
        const avgU = avg(reviews.map(r => getUserInputScoreForAggregate(r)));
        const avgS = avg(scores("severity"));
        const avgE = avg(scores("environment"));

        const total = avg([avgC, avgA, avgU, avgS, avgE]);
        const tier = suggestTier(total);

        $("aggHint").textContent = `Reviews: ${reviews.length} | CAUSE Total: ${total} | Suggested: ${tier}`;
        $("aggBox").innerHTML = `
          <div class="grid2">
            <div><b>C</b> (Control): ${avgC}</div>
            <div><b>A</b> (Awareness): ${avgA}</div>
            <div><b>U</b> (User Input): ${avgU}</div>
            <div><b>S</b> (Severity): ${avgS}</div>
            <div><b>E</b> (Environment): ${avgE}</div>
          </div>
          <div class="muted" style="margin-top:8px;">
            U is scored on a reversed scale for CAUSE (legacy reviews auto-corrected).
          </div>
        `;
      } catch (e) {
        $("aggHint").textContent = "Aggregate failed: " + (e?.message || e);
      }
    }

    // ---------- STARTUP ----------
    async function waitForFirebaseReady(maxMs = 8000) {
      const start = Date.now();
      while (Date.now() - start < maxMs) {
        if (typeof auth !== "undefined" && typeof db !== "undefined" && auth && db) return true;
        await new Promise(r => setTimeout(r, 80));
      }
      return false;
    }

    (async () => {
      const ok = await waitForFirebaseReady();
      if (!ok) {
        toast("Firebase not ready.\nCheck firebase-init.js path + console.");
        return;
      }

      auth.onAuthStateChanged(async (user) => {
        try {
          if (!user) { window.location.href = "admin.html"; return; }
          currentUser = user;
          currentEmail = (user.email || "").toLowerCase().trim();

          const adminSnap = await db.collection("admins").doc(currentEmail).get();
          if (!adminSnap.exists) { await auth.signOut(); window.location.href = "admin.html"; return; }

          const data = adminSnap.data() || {};
          const roleRaw = (data.role || "").toLowerCase();
          isHead = roleRaw.includes("head") || data.headsteward === true || data.owner === true;

          if (!isHead) { window.location.href = "steward.html"; return; }

          const nameGuess = (currentEmail.split("@")[0] || "").replace(/[._-]+/g, " ").trim();
          const niceName = nameGuess ? nameGuess.replace(/\b\w/g, c => c.toUpperCase()) : "Head Steward";
          welcomeLineEl.textContent = `Welcome, ${niceName}. You oversee all live tickets ‚Äî publish statements, monitor aggregate CAUSE, and guide steward outcomes.`;

          $("who").textContent = `Signed in as: ${currentEmail} | role: ${data.role || "headsteward"}`;

          await loadTickets();
          await loadStewardAudit7d(); // NEW: auto-load audit panel
        } catch (e) {
          toast("Auth/load error: " + (e?.message || e));
        }
      });
    })();
  </script>
</body>
</html>
