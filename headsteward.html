<!DOCTYPE html>
<html>
<head>
  <title>IFWL Head Steward Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin:0;
      background:
        linear-gradient(rgba(2,6,23,0.72), rgba(2,6,23,0.72)),
        url("./ifwl_bg.webp");
      background-size:cover;
      background-position:center;
      background-attachment:fixed;
    }

    header {
      padding:14px 18px;
      background:#111827;
      color:#fff;
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
    }

    .brand {
      display:flex;
      gap:12px;
      align-items:flex-start;
      min-width:0;
    }
    .brand img {
      width:38px;
      height:38px;
      object-fit:contain;
      margin-top:2px;
      flex:0 0 auto;
      filter: drop-shadow(0 1px 1px rgba(0,0,0,0.25));
    }
    .brandText { min-width:0; }
    header .small { font-size:12px; opacity:0.85; margin-top:4px; line-height:1.2; word-break:break-word; }
    .welcomeLine { font-size:12px; opacity:0.95; margin-top:6px; line-height:1.25; }

    .wrap { display:grid; grid-template-columns: 380px 1fr; gap:14px; padding:14px; }

    .card { background:rgba(255,255,255,0.92); border:1px solid rgba(229,231,235,0.95); border-radius:12px; padding:12px; box-shadow:0 10px 28px rgba(0,0,0,0.18); }
    .title { font-weight:700; font-size:16px; margin:0 0 10px; }
    .muted { color:#6b7280; font-size:12px; }

    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    button { padding:10px 12px; border:1px solid #d1d5db; border-radius:12px; background:#fff; cursor:pointer; }
    button.primary { background:#111827; color:#fff; border-color:#111827; }
    button:disabled { opacity:0.6; cursor:not-allowed; }

    select, input, textarea { padding:10px; border:1px solid #d1d5db; border-radius:12px; width:100%; box-sizing:border-box; font-size:16px; background:#fff; }
    textarea { min-height:70px; resize:vertical; }

    .list { display:flex; flex-direction:column; gap:8px; max-height:680px; overflow:auto; -webkit-overflow-scrolling:touch; }
    .ticket { padding:12px; border:1px solid #e5e7eb; border-radius:12px; cursor:pointer; background:#fff; }
    .ticket:hover { background:#f9fafb; }
    .ticket .id { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; word-break:break-all; }
    .ticket .status { font-size:12px; color:#374151; }
    .ticket.active { border-color:#111827; box-shadow:0 0 0 2px rgba(17,24,39,0.15); }

    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .sec { border:1px solid #e5e7eb; border-radius:12px; padding:12px; background:rgba(250,250,250,0.92); margin-top:10px; }

    .sec h3 { margin:0 0 8px; font-size:14px; }
    .badge { display:inline-block; padding:4px 10px; border-radius:999px; background:#eef2ff; border:1px solid #c7d2fe; font-size:12px; }
    .ok { color:#047857; font-weight:700; }

    .workloadBox {
      border:1px solid #e5e7eb;
      border-radius:12px;
      padding:10px 12px;
      background:rgba(250,250,250,0.92);
      margin:10px 0 12px;
    }
    .workloadTop {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .workloadTitle {
      font-weight:800;
      font-size:13px;
      margin:0;
    }
    .pill {
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:4px 10px;
      border-radius:999px;
      border:1px solid #e5e7eb;
      background:#fff;
      font-size:12px;
      color:#111827;
      white-space:nowrap;
    }
    .pill strong { font-weight:800; }
    .workloadSub { margin-top:6px; font-size:12px; color:#6b7280; line-height:1.25; }

    .needTag {
      display:inline-block;
      margin-top:8px;
      padding:4px 10px;
      border-radius:999px;
      font-size:12px;
      font-weight:800;
      border:1px solid #fca5a5;
      background:#fef2f2;
      color:#991b1b;
    }

    .stmtTag {
      margin-top:8px;
      padding:8px 10px;
      border-radius:12px;
      font-size:12px;
      font-weight:900;
      line-height:1.2;
      border:1px solid #e5e7eb;
      background:#f9fafb;
      color:#111827;
    }
    .stmtOk {
      border-color:#86efac;
      background:#ecfdf5;
      color:#065f46;
    }
    .stmtBad {
      border-color:#fca5a5;
      background:#fef2f2;
      color:#991b1b;
    }
    .stmtTag small {
      display:block;
      margin-top:4px;
      font-weight:800;
      opacity:0.95;
    }

    .infoBox{
      border:1px solid #fde68a;
      background:#fffbeb;
      color:#92400e;
      border-radius:12px;
      padding:10px 12px;
      margin-top:10px;
      font-size:13px;
      line-height:1.25;
      font-weight:800;
    }
    .infoBox small{
      display:block;
      margin-top:6px;
      font-weight:700;
      opacity:0.9;
    }

    .toast { position:fixed; right:16px; bottom:16px; background:#111827; color:#fff; padding:10px 12px; border-radius:12px; opacity:0; transform: translateY(8px); transition: all .18s ease; z-index:9999; max-width: min(520px, calc(100vw - 32px)); white-space: pre-wrap; }
    .toast.show { opacity:1; transform: translateY(0); }

    code { background:#f2f2f2; padding:2px 6px; border-radius:6px; }

    a { color:#111827; }
    a:hover { opacity:0.85; }

    .videoWrap {
      position:relative;
      width:100%;
      padding-top:56.25%;
      background:#000;
      border-radius:12px;
      overflow:hidden;
      border:1px solid #e5e7eb;
      margin-top:10px;
    }
    .videoWrap iframe, .videoWrap video {
      position:absolute;
      top:0; left:0;
      width:100%;
      height:100%;
      border:0;
    }

    /* NEW: steward discussion UI (head steward sees emails) */
    .commentBox {
      border:1px solid #e5e7eb;
      border-radius:12px;
      padding:12px;
      background:#fff;
    }
    .commentMeta {
      font-size:12px;
      color:#6b7280;
      margin-top:4px;
      line-height:1.2;
      word-break: break-word;
    }

    /* --- NEW: Steward audit table --- */
    .auditBox{
      border:1px solid #e5e7eb;
      border-radius:12px;
      padding:10px 12px;
      background:rgba(250,250,250,0.92);
      margin:10px 0 12px;
    }
    .auditTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .auditTitle{
      font-weight:900;
      font-size:13px;
      margin:0;
    }
    .auditMeta{
      margin-top:6px;
      font-size:12px;
      color:#6b7280;
      line-height:1.25;
    }
    .auditTableWrap{
      margin-top:10px;
      overflow:auto;
      border:1px solid #e5e7eb;
      border-radius:12px;
      background:#fff;
    }
    table.auditTable{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      min-width:520px;
    }
    .auditTable th, .auditTable td{
      padding:10px 10px;
      border-bottom:1px solid #f3f4f6;
      font-size:13px;
      text-align:left;
      vertical-align:top;
    }
    .auditTable th{
      position:sticky;
      top:0;
      background:#f9fafb;
      z-index:2;
      font-size:12px;
      color:#111827;
      border-bottom:1px solid #e5e7eb;
    }
    .auditTable tr:last-child td{ border-bottom:0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }

    /* NEW: penalty preview cards */
    .penPreview {
      margin-top:10px;
      border:1px solid #e5e7eb;
      background:#fff;
      border-radius:12px;
      padding:10px 12px;
      display:none;
    }
    .mutedLine { margin-top:6px; font-size:12px; color:#6b7280; line-height:1.25; }
    .k { font-weight:800; color:#111827; }
    pre { white-space:pre-wrap; margin:8px 0 0; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; }

    /* ==========================================================
       NEW: CAUSE + EFFECT UI (Head Steward)
       ========================================================== */
    .effectHeader{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
      padding-top:10px;
      border-top:1px solid #e5e7eb;
    }
    .effectTitle{
      font-weight:900;
      font-size:14px;
      margin:0;
      color:#111827;
    }
    .effectSub{
      font-size:12px;
      color:#6b7280;
      line-height:1.25;
      margin-top:6px;
      max-width:820px;
    }

    .effectTotalsRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .effectPill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid #e5e7eb;
      background:#fff;
      font-size:12px;
      color:#111827;
      white-space:nowrap;
      font-weight:900;
    }
    .effectPill small{
      font-weight:800;
      opacity:.9;
    }

    .effectGroups{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .effectGroup{
      border:1px solid #e5e7eb;
      border-radius:12px;
      background:#fff;
      padding:10px;
    }
    .effectGroupTitle{
      font-weight:900;
      font-size:13px;
      margin:0 0 8px;
      color:#111827;
    }
    .effectList{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .effectItem{
      display:flex;
      align-items:flex-start;
      gap:10px;
      border:1px solid #e5e7eb;
      background:#f9fafb;
      border-radius:12px;
      padding:10px;
      cursor:pointer;
      user-select:none;
    }
    .effectItem:hover{ background:#f3f4f6; }
    .effectItem input{
      width:auto !important;
      margin-top:2px;
      transform: scale(1.2);
    }
    .effectText{
      flex:1;
      min-width:0;
      color:#111827;
      font-size:13px;
      line-height:1.25;
      font-weight:900;
    }
    .effectText small{
      display:block;
      margin-top:4px;
      color:#6b7280;
      font-weight:800;
      opacity:.95;
    }
    .effectDelta{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size:12px;
      font-weight:900;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid #e5e7eb;
      background:#fff;
      white-space:nowrap;
      margin-top:1px;
    }
    .effectDelta.add{ border-color:#fecaca; background:#fef2f2; color:#991b1b; }
    .effectDelta.sub{ border-color:#bbf7d0; background:#ecfdf5; color:#065f46; }

    /* First lap incident special red box */
    .effectItem.effectDanger{
      border-color:#fca5a5;
      background:#fef2f2;
    }
    .effectItem.effectDanger .effectText{
      color:#991b1b;
    }
    .effectItem.effectDanger .effectText small{
      color:#991b1b;
      opacity:.9;
    }

    .calcBox{
      margin-top:10px;
      border:1px solid #e5e7eb;
      border-radius:12px;
      background:#fff;
      padding:10px 12px;
      font-size:13px;
      line-height:1.25;
      color:#111827;
    }
    .calcBox .muted{
      margin-top:6px;
    }

    @media (max-width: 980px) {
      body { background-attachment:scroll; }
      header { flex-direction:column; align-items:stretch; }
      header .row { width:100%; }
      header button { width:100%; }
      .wrap { grid-template-columns: 1fr; }
      .list { max-height:320px; }
      .grid2 { grid-template-columns: 1fr; }
      #publishAllBtn { width:100%; }
      #refreshStatementsBtn { width:100%; }
      #refreshTicketsBtn { width:100%; }
      #filter { font-size:16px; }
      .sec { padding:12px; }
      .brand { align-items:center; }
      .brand img { width:34px; height:34px; margin-top:0; }
      #refreshDiscussionBtn { width:100%; }
      #postDiscussionBtn { width:100%; }
      #refreshAuditBtn { width:100%; }
      #postPenaltyOpinionBtn { width:100%; }
      .effectGroups{ grid-template-columns:1fr; }
    }
  </style>
</head>

<body>
  <header>
    <div class="brand">
      <img src="./ifwl_logo.png" alt="IFWL logo">
      <div class="brandText">
        <div style="font-weight:800; font-size:18px;">IFWL Head Steward Dashboard</div>
        <div class="welcomeLine" id="welcomeLine">Welcome — loading your profile…</div>
        <div class="small" id="who">Loading…</div>
      </div>
    </div>

    <div class="row">
      <button id="backBtn">Back to Classifier</button>
      <!-- NEW: direct link to SimGrid Overview -->
      <button id="overviewBtn">SimGrid Overview</button>
      <button id="logoutBtn">Sign out</button>
    </div>
  </header>

  <div class="wrap">
    <!-- LEFT -->
    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div class="title" style="margin:0;">Live Workload</div>
        <button id="refreshTicketsBtn">Refresh</button>
      </div>

      <div class="workloadBox" aria-label="Workload summary">
        <div class="workloadTop">
          <div class="workloadTitle">Tickets in progress (steward team)</div>
          <div class="pill" id="workloadPill">Loading…</div>
        </div>
        <div class="workloadSub" id="workloadSub">
          As Head Steward, you oversee all live tickets. “Needs your CAUSE input” is optional, but useful for tie-breaks.
        </div>
      </div>

      <!-- NEW: Steward Input (Last 7 Days) -->
      <div class="auditBox" aria-label="Steward input audit">
        <div class="auditTop">
          <div class="auditTitle">Steward Input (Last 7 Days)</div>
          <div class="row">
            <button id="refreshAuditBtn">Refresh</button>
          </div>
        </div>

        <div class="auditMeta" id="auditMeta">Loading…</div>

        <div class="auditTableWrap" id="auditTableWrap" style="display:none;">
          <table class="auditTable" aria-label="Steward input table">
            <thead>
              <tr>
                <th>Steward</th>
                <th>Comments (7d)</th>
                <th>Reviews (7d)</th>
                <th>Tickets Touched (7d)</th>
                <th>Last Active</th>
              </tr>
            </thead>
            <tbody id="auditTbody"></tbody>
          </table>
        </div>

        <div class="muted" style="margin-top:8px;">
          Counts include <code>collectionGroup</code> queries across all tickets.
        </div>
      </div>

      <div class="row" style="margin-bottom:10px;">
        <div style="flex:1; min-width:220px;">
          <label class="muted">Filter</label>
          <select id="filter">
            <option>All (non-finalised)</option>
            <option>Awaiting Review</option>
            <option>In Review</option>
            <option>Ready to Publish</option>
          </select>
        </div>
      </div>

      <div class="list" id="ticketList"></div>
      <div class="muted" style="margin-top:8px;" id="ticketHint"></div>
    </div>

    <!-- RIGHT -->
    <div>
      <div class="card">
        <div class="title" id="selTitle">Select a ticket</div>
        <div class="muted" id="selSub"></div>

        <div class="sec">
          <h3>Ticket Summary</h3>
          <div class="grid2">
            <div><div class="muted">Accused</div><div id="sumAccused">—</div></div>
            <div><div class="muted">Reporter</div><div id="sumReporter">—</div></div>
            <div><div class="muted">Competition</div><div id="sumCompetition">—</div></div>
            <div><div class="muted">Event</div><div id="sumEvent">—</div></div>
            <div><div class="muted">Rule Breach</div><div id="sumRule">—</div></div>

            <div>
              <div class="muted">Proof URL</div>
              <div id="sumProof">—</div>
            </div>
          </div>

          <div id="proofEmbed"></div>

          <div style="margin-top:10px;">
            <div class="muted">Incident</div>
            <textarea id="sumIncident" readonly></textarea>
          </div>
        </div>

        <div class="sec" id="statementsSec">
          <div class="row" style="justify-content:space-between;">
            <h3 style="margin:0;">Player Statements</h3>
            <div class="row" style="width:100%; justify-content:flex-end;">
              <button id="refreshStatementsBtn">Refresh</button>
              <button class="primary" id="publishAllBtn">Publish ALL to Discord</button>
            </div>
          </div>

          <div class="infoBox" aria-label="Head steward note">
            Head Steward view: you can publish statements to Discord and oversee steward reviews.
            <small>Submitting your own CAUSE+EFFECT review is optional — but can help break tied outcomes.</small>
          </div>

          <div class="muted" id="statementsHint" style="margin-top:8px;">—</div>
          <div id="statementsList" style="margin-top:8px; display:flex; flex-direction:column; gap:8px;"></div>
        </div>

        <!-- NEW: Stewards Discussion (Head Steward can see steward email per comment) -->
        <div class="sec" id="discussionSec">
          <div class="row" style="justify-content:space-between;">
            <h3 style="margin:0;">Stewards Discussion</h3>
            <button id="refreshDiscussionBtn">Refresh</button>
          </div>

          <div class="muted" style="margin-top:6px;">
            Head Steward view: comment author email is shown for oversight.
          </div>

          <!-- NEW: Penalty opinion (posts to discussion so all stewards see it) -->
          <div style="margin-top:10px;">
            <label class="muted">Penalty opinion (posts to stewards discussion)</label>
            <select id="discussionPenaltyCode"></select>

            <div class="penPreview" id="discussionPenaltyPreview">
              <div><span class="k">Penalty:</span> <span id="dppPenalty">—</span></div>
              <div class="mutedLine"><span class="k">Who:</span> <span id="dppWho">—</span></div>
              <pre id="dppDesc"></pre>
              <pre id="dppExample"></pre>
            </div>

            <div class="row" style="justify-content:flex-end; margin-top:10px;">
              <button class="primary" id="postPenaltyOpinionBtn">Submit Penalty Opinion to Chat</button>
            </div>

            <div class="muted" style="margin-top:6px;">
              This posts into the discussion thread so all stewards can see your suggested outcome.
            </div>
          </div>

          <div id="discussionList" style="margin-top:10px; display:flex; flex-direction:column; gap:8px;"></div>

          <div style="margin-top:10px;">
            <label class="muted">Add a comment</label>
            <textarea id="discussionInput" placeholder="Type your steward comment…"></textarea>
          </div>

          <div class="row" style="justify-content:flex-end; margin-top:10px;">
            <button class="primary" id="postDiscussionBtn">Post Comment</button>
          </div>

          <div class="muted" style="margin-top:8px;">
            Writes to <code>/tickets&lt;ticket&gt;/steward_comments</code>
          </div>
        </div>

        <div class="sec" id="aggSec">
          <div class="row" style="justify-content:space-between;">
            <h3 style="margin:0;">Aggregate CAUSE+EFFECT (Head Steward)</h3>
            <button id="refreshAggBtn">Refresh</button>
          </div>
          <div class="muted" id="aggHint">Select a ticket to see aggregate.</div>
          <div id="aggBox" style="margin-top:8px;"></div>

          <!-- NEW: Aggregate calculation box -->
          <div class="calcBox" id="aggCalcBox" style="display:none;"></div>

          <!-- NEW: Most common effects -->
          <div class="calcBox" id="aggEffectsBox" style="display:none;"></div>
        </div>

        <div class="sec" id="reviewSec">
          <div class="row" style="justify-content:space-between;">
            <h3 style="margin:0;">My CAUSE+EFFECT Review (Optional)</h3>
            <div id="myReviewStatus" class="badge">Not submitted</div>
          </div>

          <div class="muted" style="margin-top:6px;">
            As Head Steward, your CAUSE+EFFECT review is <b>optional</b>. If submitted, it may be used as a tie-breaker when steward outcomes are tied.
          </div>

          <div class="grid2" style="margin-top:10px;">
            <div>
              <label class="muted">C — Control (1–5)</label>
              <select id="cScore"></select>
              <textarea id="cText" placeholder="Has the driver got full control of the car during this incident?"></textarea>
            </div>

            <div>
              <label class="muted">A — Awareness (1–5)</label>
              <select id="aScore"></select>
              <textarea id="aText" placeholder="Has the driver had reasonable time to see what’s around them?"></textarea>
            </div>

            <div>
              <label class="muted">U — User Input (1–5)</label>
              <select id="uScore"></select>
              <textarea id="uText" placeholder="Do the inputs match what we’d expect?"></textarea>
            </div>

            <div>
              <label class="muted">S — Severity (1–5)</label>
              <select id="sScore"></select>
              <textarea id="sText" placeholder="How severe was the outcome?"></textarea>
            </div>

            <div>
              <label class="muted">E — Environment (1–5)</label>
              <select id="eScore"></select>
              <textarea id="eText" placeholder="Did conditions affect this incident?"></textarea>
            </div>

            <div>
              <label class="muted">Penalty Code (required)</label>
              <!-- CHANGED: input -> select (populated from steward_rules.json) -->
              <select id="penaltyCode"></select>

              <!-- NEW: Penalty preview for Head Steward CAUSE selection -->
              <div class="penPreview" id="penaltyPreview">
                <div><span class="k">Penalty:</span> <span id="ppPenalty">—</span></div>
                <div class="mutedLine"><span class="k">Who:</span> <span id="ppWho">—</span></div>
                <pre id="ppDesc"></pre>
                <pre id="ppExample"></pre>
              </div>

              <label class="muted" style="margin-top:8px; display:block;">Private Opinion (Head Steward)</label>
              <textarea id="privateOpinion" placeholder="Saved and visible to Head Steward."></textarea>
            </div>
          </div>

          <!-- ==========================================================
               NEW: EFFECT (tick all that apply)
               ========================================================== -->
          <div class="effectHeader">
            <div style="min-width:260px; flex:1;">
              <div class="effectTitle">EFFECT (tick all that apply)</div>
              <div class="effectSub">
                Effects stack using micro-values. Your total EFFECT is clamped to <b>-1.00</b> to <b>+1.00</b>.
                EFFECT modifies the aggregated CAUSE total (RAW score) to produce a final CAUSE+EFFECT score.
              </div>
            </div>
            <div class="effectTotalsRow" style="flex:0 0 auto;">
              <div class="effectPill" id="effectRawPill">RAW: —</div>
              <div class="effectPill" id="effectTotalPill">EFFECT: —</div>
              <div class="effectPill" id="effectFinalPill">FINAL: —</div>
            </div>
          </div>

          <div class="effectGroups" aria-label="Effect checklists">
            <div class="effectGroup">
              <div class="effectGroupTitle">Aggravating (adds)</div>
              <div class="effectList" id="effectAdds"></div>
            </div>
            <div class="effectGroup">
              <div class="effectGroupTitle">Mitigating (reduces)</div>
              <div class="effectList" id="effectSubs"></div>
            </div>
          </div>

          <div class="calcBox" id="effectCalcBox" style="display:none;"></div>

          <div class="row" style="justify-content:flex-end; margin-top:10px;">
            <button id="loadMyReviewBtn">Load My Review</button>
            <button class="primary" id="submitReviewBtn">Submit Review</button>
          </div>

          <div class="muted" style="margin-top:8px;">
            Submitting writes to <code>/tickets/&lt;ticket&gt;/reviews/&lt;yourEmailKey&gt;</code>.
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast">Saved</div>

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <script src="./firebase-init.js"></script>

  <script>
    // ---------- CONFIG ----------
    // UPDATED to your provided webhook
    const DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/1469289068130074675/Ic3VC8dpmNpV6bZOdIEXPSGSwdAauQ1WMcEy8YAimcYraAHcivJYK3e10GR5iR-3FJJP";

    // ==========================================================
    // NEW: EFFECT OPTIONS (micro-values, stacks, clamped -1..+1)
    // ==========================================================
    // Notes:
    // - group "add" increases severity (+)
    // - group "sub" mitigates (-)
    // - first_lap_incident is a checkbox AND it enforces FINAL >= 4.0 (automatic severe)
    const EFFECT_OPTIONS = [
      // Aggravating (adds)
      { key:"first_lap_incident", label:"First corner incident (AUTOMATICALLY SEVERE)", delta:+0.40, group:"add", note:"First corner context: final score is clamped to >= 4.0 when selected" },
      { key:"avoidable_contact_clear_space", label:"Avoidable contact with clear space available", delta:+0.12, group:"add", note:"Driver had clear room/time to avoid but did not" },
      { key:"divebomb_low_probability", label:"Low-probability dive (late move / unrealistic lunge)", delta:+0.12, group:"add", note:"Move required other driver to 'disappear' to work" },
      { key:"no_attempt_to_avoid", label:"No meaningful attempt to avoid (committed through contact)", delta:+0.10, group:"add", note:"Little/no lift, brake or steering change despite visible risk" },
      { key:"repeat_offender_context", label:"Pattern of behaviour in the same race (repeated poor judgement)", delta:+0.10, group:"add", note:"Multiple similar contacts or recurring recklessness in same event" },
      { key:"unsafe_defence_block", label:"Unsafe defence (reactive block / moving under braking)", delta:+0.12, group:"add", note:"Creates unavoidable contact risk for following car" },
      { key:"rejoin_created_risk", label:"Rejoin created immediate risk (without full control)", delta:+0.14, group:"add", note:"Not the 'unsafe rejoin lock' – just added risk during rejoin" },
      { key:"track_limits_gain", label:"Gained advantage off-track / failed to concede", delta:+0.10, group:"add", note:"Used off-track to keep position or gain time without giving back" },
      { key:"ignored_blue_flags", label:"Ignored blue flags / interfered with leaders", delta:+0.10, group:"add", note:"Significant interference when being lapped" },
      { key:"poor_visibility_not_accounted", label:"Did not account for known visibility limitations (spray / night)", delta:+0.08, group:"add", note:"Chose a move or approach inappropriate for conditions" },

      // Mitigating (reduces)
      { key:"racing_room_given", label:"Racing room given (attempted to leave space)", delta:-0.08, group:"sub", note:"Evidence shows intent to leave room / avoid squeezing" },
      { key:"partial_fault_shared", label:"Shared fault / contributory actions by other driver", delta:-0.10, group:"sub", note:"Other driver materially contributed to the incident outcome" },
      { key:"contact_minor_outcome", label:"Minor contact outcome (very low impact / no meaningful time loss)", delta:-0.08, group:"sub", note:"Contact occurred but consequences were limited" },
      { key:"chain_reaction", label:"Chain reaction (triggered by earlier contact or accordion)", delta:-0.10, group:"sub", note:"Incident largely caused by upstream events beyond control" },
      { key:"loss_of_control_from_contact", label:"Loss of control caused by being hit first", delta:-0.10, group:"sub", note:"Driver became passenger after initial hit" },
      { key:"genuine_blindspot", label:"Genuine blind spot / reasonable expectation of clearance", delta:-0.08, group:"sub", note:"Camera/angles support that awareness was reasonably limited" },
      { key:"mechanical_or_netcode", label:"Mechanical failure / clear netcode anomaly", delta:-0.14, group:"sub", note:"Evidence supports failure/anomaly as primary driver" },
      { key:"took_immediate_avoiding_action", label:"Took immediate avoiding action (brake/lift/steer) but still contact", delta:-0.08, group:"sub", note:"Attempted mitigation is visible and credible" },
      { key:"position_returned", label:"Position/time advantage returned immediately", delta:-0.08, group:"sub", note:"Driver clearly gave back advantage without being forced" },
      { key:"self_penalised", label:"Driver self-penalised (waited / served voluntary slowdown)", delta:-0.10, group:"sub", note:"Clear voluntary action to neutralise incident impact" }
    ];

    // ---------- helpers ----------
    const $ = (id) => document.getElementById(id);
    const toastEl = $("toast");
    function toast(msg) {
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      setTimeout(() => toastEl.classList.remove("show"), 2200);
    }

    // Show JS errors as toast so you instantly see what's wrong if anything breaks
    window.addEventListener("error", (e) => {
      const msg = (e?.message || "Unknown JS error") + (e?.filename ? `\n${e.filename}:${e.lineno || 0}` : "");
      console.error("JS error:", e);
      toast("JS ERROR:\n" + msg);
    });
    window.addEventListener("unhandledrejection", (e) => {
      console.error("Promise rejection:", e);
      toast("PROMISE ERROR:\n" + (e?.reason?.message || e?.reason || "Unknown"));
    });

    function safeKey(email) { return (email || "").replaceAll("/", "_").replaceAll("\\", "_").trim(); }

    // NEW: mask email for Discord audit output (keeps your UI unchanged)
    function maskEmail(email) {
      const e = String(email || "").trim();
      if (!e) return "";
      const at = e.indexOf("@");
      if (at <= 0) return e;
      return e.slice(0, at); // only local part
    }

    function optionList() {
      return [
        {v:1, t:"1 — minimal / none"},
        {v:2, t:"2 — low"},
        {v:3, t:"3 — moderate"},
        {v:4, t:"4 — high"},
        {v:5, t:"5 — extreme"},
      ];
    }
    function fillScores() {
      for (const id of ["cScore","aScore","uScore","sScore","eScore"]) {
        const sel = $(id);
        sel.innerHTML = "";
        for (const o of optionList()) {
          const opt = document.createElement("option");
          opt.value = o.v;
          opt.textContent = o.t;
          sel.appendChild(opt);
        }
        sel.value = "1";
      }
    }
    fillScores();

    function escapeHtml(s) {
      return (s || "").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
    }

    function clampScore(v) {
      const n = parseInt(v || 1, 10);
      return Math.min(5, Math.max(1, isNaN(n) ? 1 : n));
    }

    // --- U reverse mapping ---
    function reverseScore(v) { return 6 - clampScore(v); }
    function unreverseScore(v) { return 6 - clampScore(v); }

    function avg(nums) {
      const xs = nums.filter(x => x > 0);
      if (!xs.length) return 0;
      const v = xs.reduce((a,b)=>a+b,0) / xs.length;
      return Math.round(v * 100) / 100;
    }

    function clamp(n, lo, hi) {
      const x = Number(n);
      if (isNaN(x)) return lo;
      return Math.max(lo, Math.min(hi, x));
    }

    function suggestTier(total) {
      if (total <= 0) return "No data";
      if (total < 2.0) return "Racing Incident / No Action";
      if (total < 3.0) return "Minor Penalty / Warning";
      if (total < 3.7) return "Moderate Penalty";
      if (total < 4.4) return "Severe Penalty";
      return "Extreme / Disqualification Consideration";
    }

    function isFinalised(status) {
      const s = (status || "").trim().toLowerCase();
      return s === "finalised";
    }

    function getUserInputScoreForAggregate(review) {
      const stored = clampScore(review?.CAUSE?.userInput?.score || 0);
      if (!stored) return 0;

      const reversedFlag = review?.CAUSE?.userInput?.reversed === true;
      const schema2 = (review?.schemaVersion || 0) >= 2;

      // New schema: stored already reversed => use as-is
      if (reversedFlag || schema2) return stored;

      // Legacy: stored was UI scale => reverse for scoring
      return reverseScore(stored);
    }

    // ==========================================================
    // NEW: EFFECT state + UI
    // ==========================================================
    const effectSelected = new Set(); // keys

    function findEffectByKey(k){
      return EFFECT_OPTIONS.find(x => x.key === k) || null;
    }

    function computeEffectTotalFromKeys(keys){
      let sum = 0;
      const picked = new Set(keys || []);
      for (const ef of EFFECT_OPTIONS){
        if (picked.has(ef.key)) sum += Number(ef.delta || 0);
      }
      const clamped = clamp(sum, -1, +1);
      return { sumRaw: Math.round(sum * 100) / 100, sumClamped: Math.round(clamped * 100) / 100 };
    }

    function anyFirstLapSelected(keys){
      return (keys || []).includes("first_lap_incident");
    }

    function getRawCauseTotalFromCurrentUI(){
      const c = Number($("cScore").value);
      const a = Number($("aScore").value);
      const uUi = Number($("uScore").value);
      const uStored = reverseScore(uUi); // stored on reversed scale
      const s = Number($("sScore").value);
      const e = Number($("eScore").value);
      const raw = avg([c,a,uStored,s,e]); // raw CAUSE total using stored U
      return Math.round(raw * 100) / 100;
    }

    function updateEffectPreview(){
      const raw = getRawCauseTotalFromCurrentUI();
      const { sumRaw, sumClamped } = computeEffectTotalFromKeys([...effectSelected]);

      let final = clamp(raw + sumClamped, 1, 5);

      const firstLap = anyFirstLapSelected([...effectSelected]);
      if (firstLap) final = Math.max(final, 4.0);

      final = Math.round(final * 100) / 100;

      const rawPill = $("effectRawPill");
      const effPill = $("effectTotalPill");
      const finPill = $("effectFinalPill");
      const calcBox = $("effectCalcBox");

      if (rawPill) rawPill.innerHTML = `RAW: <small>${raw.toFixed(2)}</small>`;
      if (effPill) effPill.innerHTML = `EFFECT: <small>${sumClamped >= 0 ? "+" : ""}${sumClamped.toFixed(2)}</small>`;
      if (finPill) finPill.innerHTML = `FINAL: <small>${final.toFixed(2)}</small>`;

      if (calcBox){
        calcBox.style.display = "block";
        const clampNote = (sumRaw !== sumClamped) ? ` (clamped from ${sumRaw >= 0 ? "+" : ""}${sumRaw.toFixed(2)})` : "";
        const lockNote = firstLap ? `\nLock: First corner incident -> FINAL >= 4.00 applied` : "";
        calcBox.innerHTML = `
          <div><b>Calculation</b></div>
          <div style="margin-top:6px;" class="mono">
            RAW ${raw.toFixed(2)} + EFFECT ${sumClamped >= 0 ? "+" : ""}${sumClamped.toFixed(2)}${clampNote} = FINAL ${final.toFixed(2)}
          </div>
          <div class="muted" style="margin-top:6px;">
            EFFECT is a micro-adjustment layer. It is intended to swing outcomes when context is clearly present in the evidence.${lockNote ? "<br><br><b>" + escapeHtml(lockNote).replaceAll("\n","<br>") + "</b>" : ""}
          </div>
        `;
      }
    }

    function clearEffectSelection(){
      effectSelected.clear();
      // uncheck UI
      for (const ef of EFFECT_OPTIONS){
        const cb = document.getElementById("ef_" + ef.key);
        if (cb) cb.checked = false;
      }
      updateEffectPreview();
    }

    function setEffectSelection(keys){
      effectSelected.clear();
      const arr = Array.isArray(keys) ? keys : [];
      for (const k of arr) effectSelected.add(String(k || "").trim());

      for (const ef of EFFECT_OPTIONS){
        const cb = document.getElementById("ef_" + ef.key);
        if (cb) cb.checked = effectSelected.has(ef.key);
      }
      updateEffectPreview();
    }

    function renderEffectsUI(){
      const adds = $("effectAdds");
      const subs = $("effectSubs");
      if (!adds || !subs) return;

      adds.innerHTML = "";
      subs.innerHTML = "";

      function makeItem(ef){
        const lab = document.createElement("label");
        lab.className = "effectItem";
        lab.htmlFor = "ef_" + ef.key;
        lab.dataset.effectKey = ef.key;

        if (ef.key === "first_lap_incident") {
          lab.classList.add("effectDanger");
        }

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.id = "ef_" + ef.key;

        cb.addEventListener("change", () => {
          if (cb.checked) effectSelected.add(ef.key);
          else effectSelected.delete(ef.key);
          updateEffectPreview();
        });

        const txt = document.createElement("div");
        txt.className = "effectText";
        txt.textContent = ef.label;
        const sm = document.createElement("small");
        sm.textContent = ef.note || "";
        txt.appendChild(sm);

        const delta = document.createElement("div");
        delta.className = "effectDelta " + (ef.group === "add" ? "add" : "sub");
        const d = Number(ef.delta || 0);
        delta.textContent = (d >= 0 ? "+" : "") + d.toFixed(2);

        lab.appendChild(cb);
        lab.appendChild(txt);
        lab.appendChild(delta);
        return lab;
      }

      for (const ef of EFFECT_OPTIONS){
        const item = makeItem(ef);
        if (ef.group === "add") adds.appendChild(item);
        else subs.appendChild(item);
      }

      // Keep preview updated if CAUSE numbers change
      for (const id of ["cScore","aScore","uScore","sScore","eScore"]) {
        const el = $(id);
        if (el) el.addEventListener("change", () => updateEffectPreview());
      }

      updateEffectPreview();
    }

    // ---------- URLs / Proof helpers ----------
    function normalizeUrl(u) {
      const s = (u || "").trim();
      if (!s) return "";
      if (!/^https?:\/\//i.test(s) && !s.startsWith("mailto:")) return "https://" + s;
      return s;
    }

    function youtubeIdFromUrl(url) {
      try {
        const u = new URL(url);
        const host = u.hostname.toLowerCase();
        if (host === "youtu.be") return (u.pathname || "").replace("/", "").trim();
        if (host.includes("youtube.com")) {
          if (u.pathname.startsWith("/watch")) return (u.searchParams.get("v") || "").trim();
          if (u.pathname.startsWith("/shorts/")) return (u.pathname.split("/shorts/")[1] || "").split(/[/?#]/)[0].trim();
          if (u.pathname.startsWith("/embed/")) return (u.pathname.split("/embed/")[1] || "").split(/[/?#]/)[0].trim();
        }
      } catch {}
      return "";
    }

    function renderProof(proofUrl) {
      const proofEl = $("sumProof");
      const embedEl = $("proofEmbed");
      embedEl.innerHTML = "";

      const url = normalizeUrl(proofUrl);
      if (!url) { proofEl.textContent = "—"; return; }

      proofEl.innerHTML = `<a href="${escapeHtml(url)}" target="_blank" rel="noopener">Open proof link</a>`;

      const yt = youtubeIdFromUrl(url);
      if (yt) {
        embedEl.innerHTML = `
          <div class="videoWrap" aria-label="Proof video">
            <iframe
              src="https://www.youtube.com/embed/${encodeURIComponent(yt)}"
              title="Proof video"
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
              allowfullscreen></iframe>
          </div>
        `;
        return;
      }

      if (/\.(mp4|webm|ogg)(\?|#|$)/i.test(url)) {
        embedEl.innerHTML = `
          <div class="videoWrap" aria-label="Proof video">
            <video controls src="${escapeHtml(url)}"></video>
          </div>
        `;
      }
    }

    async function doesMyReviewExist(ticketId, email) {
      try {
        const reviewId = safeKey(email);
        if (!reviewId) return false;
        const ref = db.collection("tickets").doc(ticketId).collection("reviews").doc(reviewId);
        const snap = await ref.get();
        return snap.exists;
      } catch (e) {
        console.warn("Review check failed:", ticketId, e);
        return false;
      }
    }

    // statement status (accused + reporter only)
    const statementStatusCache = new Map();
    async function getAccusedReporterStatementStatus(ticketId) {
      if (statementStatusCache.has(ticketId)) return statementStatusCache.get(ticketId);

      const col = db.collection("tickets").doc(ticketId).collection("player_statements");

      try {
        const snap = await col.where("role", "in", ["accused", "reporter"]).get();
        let accused = false, reporter = false;
        snap.forEach(doc => {
          const d = doc.data() || {};
          const role = String(d.role || "").toLowerCase().trim();
          const statement = String(d.statement || "").trim();
          if (!statement) return;
          if (role === "accused") accused = true;
          if (role === "reporter") reporter = true;
        });
        const res = { accused, reporter };
        statementStatusCache.set(ticketId, res);
        return res;
      } catch {
        const snap = await col.get();
        let accused = false, reporter = false;
        snap.forEach(doc => {
          const d = doc.data() || {};
          const role = String(d.role || "").toLowerCase().trim();
          const statement = String(d.statement || "").trim();
          if (!statement) return;
          if (role === "accused") accused = true;
          if (role === "reporter") reporter = true;
        });
        const res = { accused, reporter };
        statementStatusCache.set(ticketId, res);
        return res;
      }
    }

    function renderStatementTag(el, st) {
      const accusedOk = !!st?.accused;
      const reporterOk = !!st?.reporter;

      if (accusedOk && reporterOk) {
        el.className = "stmtTag stmtOk";
        el.innerHTML = `Statements: ✅ Accused + Reporter<br><small>Ready for review</small>`;
        return;
      }

      const missing = [];
      if (!accusedOk) missing.push("Accused");
      if (!reporterOk) missing.push("Reporter");

      el.className = "stmtTag stmtBad";
      el.innerHTML = `Statements: ❌ Missing ${missing.join(" + ")}<br><small>Awaiting required statements</small>`;
    }

    // ---------- NEW: penalty previews ----------
    function setPenaltyPreviewFromSelected() {
      const sel = $("penaltyCode");
      const box = $("penaltyPreview");
      if (!sel || !box) return;

      const opt = sel.selectedOptions && sel.selectedOptions[0] ? sel.selectedOptions[0] : null;
      if (!opt || !opt.value) { box.style.display = "none"; return; }

      const pen = (opt.dataset.penalty || "").trim();
      const who = (opt.dataset.who || "").trim();
      const desc = (opt.dataset.desc || "").trim();
      const ex = (opt.dataset.example || "").trim();

      $("ppPenalty").textContent = pen || "—";
      $("ppWho").textContent = who || "—";
      $("ppDesc").textContent = desc ? `Description:\n${desc}` : "";
      $("ppExample").textContent = ex ? `\nExample:\n${ex}` : "";

      box.style.display = "block";
    }

    function setDiscussionPenaltyPreviewFromSelected() {
      const sel = $("discussionPenaltyCode");
      const box = $("discussionPenaltyPreview");
      if (!sel || !box) return;

      const opt = sel.selectedOptions && sel.selectedOptions[0] ? sel.selectedOptions[0] : null;
      if (!opt || !opt.value) { box.style.display = "none"; return; }

      const pen = (opt.dataset.penalty || "").trim();
      const who = (opt.dataset.who || "").trim();
      const desc = (opt.dataset.desc || "").trim();
      const ex = (opt.dataset.example || "").trim();

      $("dppPenalty").textContent = pen || "—";
      $("dppWho").textContent = who || "—";
      $("dppDesc").textContent = desc ? `Description:\n${desc}` : "";
      $("dppExample").textContent = ex ? `\nExample:\n${ex}` : "";

      box.style.display = "block";
    }

    // ---------- penalty codes (Head Steward: CAUSE dropdown + Discussion dropdown) ----------
    async function loadPenaltyCodes() {
      async function fillSelect(selectId) {
        const sel = $(selectId);
        if (!sel) return;

        sel.innerHTML = "";
        const ph = document.createElement("option");
        ph.value = "";
        ph.textContent = "Select a penalty code…";
        ph.disabled = true;
        ph.selected = true;
        sel.appendChild(ph);

        const res = await fetch("./steward_rules.json", { cache: "no-store" });
        if (!res.ok) throw new Error(`Could not load steward_rules.json (${res.status})`);

        const rules = await res.json();
        if (!Array.isArray(rules)) throw new Error("steward_rules.json is not a JSON array");

        let added = 0;

        for (const r of rules) {
          if (!r || typeof r !== "object") continue;

          const code = String((r.Code ?? r.code ?? "")).trim();
          const title = String((r.Title ?? r.title ?? "")).trim();
          const group = String((r.Group ?? r.group ?? "")).trim();
          const pen = String((r.Penalty ?? r.penalty ?? "")).trim();

          const desc = String((r.Description ?? r.description ?? "")).trim();
          const example = String((r.Example ?? r.example ?? "")).trim();
          const who = String((r.Who ?? r.who ?? "")).trim();

          if (!code && !title) continue;

          const value = `${code}${title ? " — " + title : ""}${pen ? " (" + pen + ")" : ""}`.trim();
          const label = `${code}${title ? " — " + title : ""}`.trim();

          const opt = document.createElement("option");
          opt.value = value;
          opt.textContent = label;

          opt.dataset.group = group;
          opt.dataset.penalty = pen;
          opt.dataset.desc = desc;
          opt.dataset.example = example;
          opt.dataset.who = who;
          opt.dataset.code = code;
          opt.dataset.title = title;

          sel.appendChild(opt);
          added++;
        }

        if (!added) {
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "No valid penalty codes found (check JSON).";
          opt.disabled = true;
          sel.appendChild(opt);
        }
      }

      try {
        await fillSelect("penaltyCode");             // CAUSE dropdown (Head Steward)
        await fillSelect("discussionPenaltyCode");   // Discussion dropdown (Head Steward)
      } catch (e) {
        console.error("Penalty code load failed:", e);

        for (const id of ["penaltyCode", "discussionPenaltyCode"]) {
          const sel = $(id);
          if (!sel) continue;
          sel.innerHTML = "";
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "Failed to load penalty codes (open console).";
          opt.disabled = true;
          sel.appendChild(opt);
        }
      }
    }

    // ---------- NEW: Patreon Audit (Discord webhook post) ----------
    async function discordPost(content) {
      if (!DISCORD_WEBHOOK_URL.startsWith("https://discord.com/api/webhooks/")) {
        throw new Error("Webhook invalid");
      }
      const resp = await fetch(DISCORD_WEBHOOK_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ content })
      });
      if (!resp.ok) {
        const txt = await resp.text();
        throw new Error(`Discord publish failed: ${resp.status} ${resp.statusText} ${txt}`);
      }
    }

    function splitDiscordMessages(fullText, maxLen = 1900) {
      // keep a bit under 2000 to be safe
      const lines = String(fullText || "").split("\n");
      const chunks = [];
      let cur = "";
      for (const line of lines) {
        const add = (cur ? "\n" : "") + line;
        if ((cur.length + add.length) > maxLen) {
          if (cur.trim()) chunks.push(cur);
          cur = line;
        } else {
          cur += add;
        }
      }
      if (cur.trim()) chunks.push(cur);
      return chunks.length ? chunks : [fullText.slice(0, maxLen)];
    }

    async function computeAggregateForTicket(ticketId) {
      const col = db.collection("tickets").doc(ticketId).collection("reviews");
      const snap = await col.get();
      if (snap.empty) return null;

      const reviews = snap.docs.map(d => d.data() || {});
      const scores = (key) => reviews.map(r => clampScore(r?.CAUSE?.[key]?.score || 0));

      const avgC = avg(scores("control"));
      const avgA = avg(scores("awareness"));
      const avgU = avg(reviews.map(r => getUserInputScoreForAggregate(r)));
      const avgS = avg(scores("severity"));
      const avgE = avg(scores("environment"));

      const rawCause = avg([avgC, avgA, avgU, avgS, avgE]);

      // NEW: effect aggregation
      const effectTotals = reviews.map(r => {
        const keys = Array.isArray(r?.EFFECT?.keys) ? r.EFFECT.keys : [];
        return computeEffectTotalFromKeys(keys).sumClamped;
      });

      const avgEffect = avg(effectTotals);

      // Final = raw + avgEffect (clamp 1..5)
      let final = clamp(rawCause + avgEffect, 1, 5);

      // Lock: if ANY review has first_lap_incident selected -> final >= 4.0
      const anyFirstLap = reviews.some(r => anyFirstLapSelected(Array.isArray(r?.EFFECT?.keys) ? r.EFFECT.keys : []));
      if (anyFirstLap) final = Math.max(final, 4.0);

      final = Math.round(final * 100) / 100;

      const tier = suggestTier(final);

      return {
        reviewsCount: reviews.length,
        avgC, avgA, avgU, avgS, avgE,
        rawCause: Math.round(rawCause * 100) / 100,
        avgEffect: Math.round(avgEffect * 100) / 100,
        final,
        tier,
        anyFirstLap,
        reviews
      };
    }

    async function fetchStewardComments(ticketId) {
      const col = db.collection("tickets").doc(ticketId).collection("steward_comments");
      const snap = await col.orderBy("createdAt", "asc").limit(250).get();
      if (snap.empty) return [];

      const rows = [];
      snap.forEach(doc => {
        const d = doc.data() || {};
        const text = String(d.text || "").trim();
        if (!text) return;

        const ts = d.createdAt && d.createdAt.toDate ? d.createdAt.toDate() : null;
        const when = ts ? ts.toLocaleString() : "—";
        const author = String(d.authorKey || d.stewardEmail || "unknown").trim() || "unknown";

        rows.push({ when, author, text });
      });
      return rows;
    }

    async function postPatreonAudit(ticketId) {
      toast("Building Patreon audit…");

      const ticketSnap = await db.collection("tickets").doc(ticketId).get();
      if (!ticketSnap.exists) throw new Error("Ticket not found");

      const t = ticketSnap.data() || {};
      const status = (t.status || "Under Review");
      const event = (t.event || "—");
      const accused = (t.accused || "—");
      const reporter = (t.reporter || "—");

      const agg = await computeAggregateForTicket(ticketId);
      const comments = await fetchStewardComments(ticketId);

      const header =
`🧾 **IFWL Patreon Audit**
**Ticket:** \`${ticketId}\`
**Status:** ${status}
**Event:** ${event}
**Accused:** ${accused}
**Reporter:** ${reporter}`;

      const aggBlock = agg
        ? `\n\n🎯 **CAUSE+EFFECT Aggregate** (reviews: ${agg.reviewsCount})
**RAW CAUSE:** ${agg.rawCause.toFixed(2)}
**AVG EFFECT:** ${agg.avgEffect >= 0 ? "+" : ""}${agg.avgEffect.toFixed(2)}
**FINAL:** ${agg.final.toFixed(2)}  —  *${agg.tier}*
C:${agg.avgC}  A:${agg.avgA}  U:${agg.avgU}  S:${agg.avgS}  E:${agg.avgE}${agg.anyFirstLap ? `\nLock: First corner incident -> FINAL >= 4.00 applied` : ""}`
        : `\n\n🎯 **CAUSE+EFFECT Aggregate**
No reviews submitted yet.`;

      const commentsHeader = `\n\n💬 **Steward Comments** (${comments.length})`;
      const commentLines = comments.length
        ? comments.map(c => {
            const who = maskEmail(c.author);
            const text = String(c.text || "").replace(/\s+/g, " ").trim();
            const clipped = text.length > 350 ? text.slice(0, 350) + "…" : text;
            return `- [${c.when}] ${who}: ${clipped}`;
          }).join("\n")
        : `- None`;

      const full = header + aggBlock + commentsHeader + "\n" + commentLines;

      const chunks = splitDiscordMessages(full, 1900);
      for (let i = 0; i < chunks.length; i++) {
        const prefix = chunks.length > 1 ? `(${i+1}/${chunks.length}) ` : "";
        await discordPost(prefix + chunks[i]);
      }
    }

    // ---------- state ----------
    let currentUser = null;
    let currentEmail = "";
    let isHead = false;
    let selectedTicketId = "";
    let selectedTicketSnap = null;

    // ---------- UI refs ----------
    const ticketListEl = $("ticketList");
    const ticketHintEl = $("ticketHint");
    const filterEl = $("filter");
    const submitReviewBtn = $("submitReviewBtn");
    const loadMyReviewBtn = $("loadMyReviewBtn");
    const publishAllBtn = $("publishAllBtn");
    const workloadPillEl = $("workloadPill");
    const workloadSubEl = $("workloadSub");
    const welcomeLineEl = $("welcomeLine");

    // NEW: discussion UI refs
    const refreshDiscussionBtn = $("refreshDiscussionBtn");
    const postDiscussionBtn = $("postDiscussionBtn");
    const postPenaltyOpinionBtn = $("postPenaltyOpinionBtn");

    // ---------- navigation ----------
    $("backBtn").onclick = () => window.location.href = "index.html";
    // NEW: SimGrid Overview button
    $("overviewBtn").onclick = () => window.location.href = "overview.html";
    $("logoutBtn").onclick = async () => { await auth.signOut(); window.location.href = "admin.html"; };
    $("refreshTicketsBtn").onclick = () => loadTickets();
    $("refreshStatementsBtn").onclick = () => loadStatements();
    $("refreshAggBtn").onclick = () => refreshAggregate();
    if (refreshDiscussionBtn) refreshDiscussionBtn.onclick = () => loadDiscussion();
    $("refreshAuditBtn").onclick = () => loadStewardAudit7d();
    filterEl.onchange = () => loadTickets();
    loadMyReviewBtn.onclick = () => loadMyReview();
    submitReviewBtn.onclick = () => submitMyReview();
    publishAllBtn.onclick = () => publishAllStatements();
    if (postDiscussionBtn) postDiscussionBtn.onclick = () => postDiscussion();
    if (postPenaltyOpinionBtn) postPenaltyOpinionBtn.onclick = () => postPenaltyOpinion();

    function passesFilter(status) {
      const f = filterEl.value;
      const s = (status || "").trim().toLowerCase();
      if (f === "All (non-finalised)") return s !== "finalised";
      if (f === "Awaiting Review") return s === "" || s === "under review" || s === "awaiting review";
      if (f === "In Review") return s === "in review";
      if (f === "Ready to Publish") return s === "ready to publish";
      return true;
    }

    async function loadTickets() {
      ticketListEl.innerHTML = "";
      ticketHintEl.textContent = "Loading tickets…";
      workloadPillEl.textContent = "Loading…";
      workloadSubEl.textContent = "As Head Steward, you oversee all live tickets. “Needs your CAUSE input” is optional, but useful for tie-breaks.";

      statementStatusCache.clear();

      const snap = await db.collection("tickets").limit(400).get();
      const tickets = snap.docs.map(d => {
        const data = d.data() || {};
        const status = (data.status || "").trim();
        return { id: d.id, data, status };
      });

      const liveTickets = tickets.filter(t => !isFinalised(t.status));
      const liveCount = liveTickets.length;

      const myReviewResults = await Promise.all(
        liveTickets.map(async (t) => ({ id: t.id, hasMine: await doesMyReviewExist(t.id, currentEmail) }))
      );
      const myReviewMap = new Map(myReviewResults.map(x => [x.id, x.hasMine]));
      const needsMyInputCount = liveTickets.filter(t => !myReviewMap.get(t.id)).length;

      workloadPillEl.innerHTML = `Live: <strong>${liveCount}</strong> • Needs your input: <strong>${needsMyInputCount}</strong>`;

      if (liveCount === 0) workloadSubEl.textContent = "No live tickets found. You're all caught up ✅";
      else if (needsMyInputCount === 0) workloadSubEl.textContent = "All live tickets already have your optional Head Steward review ✅";
      else workloadSubEl.textContent = "“Needs your CAUSE input” means you haven't submitted your optional Head Steward review.";

      let shown = 0;

      for (const t of tickets) {
        if (!passesFilter(t.status)) continue;

        const needsMyInput = (!isFinalised(t.status)) && !myReviewMap.get(t.id);

        const div = document.createElement("div");
        div.className = "ticket" + (t.id === selectedTicketId ? " active" : "");
        div.innerHTML = `
          <div class="id">${escapeHtml(t.id)}</div>
          <div class="status"><b>Status:</b> ${escapeHtml(t.status || "Under Review")}</div>
          <div class="muted" style="margin-top:4px;">
            ${t.data.event ? `<b>Event:</b> ${escapeHtml(t.data.event)}` : ""}
            ${t.data.accused ? ` | <b>Accused:</b> ${escapeHtml(t.data.accused)}` : ""}
          </div>
          <div class="stmtTag" id="stmt_${escapeHtml(t.id)}">Statements: Checking…<small>Accused + Reporter</small></div>
          ${needsMyInput ? `<div class="needTag">Needs your CAUSE input (optional)</div>` : ""}

          <!-- NEW: Patreon Audit button on every ticket -->
          <div class="row" style="justify-content:flex-end; margin-top:10px;">
            <button class="primary patreonAuditBtn" data-ticket="${escapeHtml(t.id)}">Patreon Audit</button>
          </div>
        `;

        div.onclick = async () => {
          selectedTicketId = t.id;
          await selectTicket(t.id);
          [...ticketListEl.querySelectorAll(".ticket")].forEach(x => x.classList.remove("active"));
          div.classList.add("active");
        };

        // Wire Patreon Audit button (stop it triggering ticket select)
        const auditBtn = div.querySelector(".patreonAuditBtn");
        if (auditBtn) {
          auditBtn.addEventListener("click", async (ev) => {
            ev.preventDefault();
            ev.stopPropagation();

            const ticketId = auditBtn.getAttribute("data-ticket");
            if (!ticketId) return;

            auditBtn.disabled = true;
            const original = auditBtn.textContent;
            auditBtn.textContent = "Posting…";
            try {
              await postPatreonAudit(ticketId);
              toast("Patreon audit posted ✅");
            } catch (e) {
              console.error("Patreon audit failed:", e);
              toast("Audit failed:\n" + (e?.message || e));
            } finally {
              auditBtn.textContent = original;
              auditBtn.disabled = false;
            }
          });
        }

        ticketListEl.appendChild(div);
        shown++;

        (async () => {
          const tagEl = div.querySelector(`[id="stmt_${CSS.escape(t.id)}"]`);
          if (!tagEl) return;
          const st = await getAccusedReporterStatementStatus(t.id);
          renderStatementTag(tagEl, st);
        })().catch(() => {});
      }

      ticketHintEl.textContent = `Showing ${shown} ticket(s). (Max 400 fetched).`;
    }

    async function selectTicket(ticketId) {
      $("selTitle").textContent = `Ticket: ${ticketId}`;
      $("selSub").textContent = "";
      $("myReviewStatus").textContent = "Not submitted";
      $("myReviewStatus").className = "badge";

      $("aggHint").textContent = "Loading aggregate…";
      $("aggBox").innerHTML = "";
      $("aggCalcBox").style.display = "none";
      $("aggCalcBox").innerHTML = "";
      $("aggEffectsBox").style.display = "none";
      $("aggEffectsBox").innerHTML = "";

      $("statementsHint").textContent = "Loading statements…";
      $("statementsList").innerHTML = "";

      // reset discussion UI
      $("discussionList").innerHTML = `<div class="muted">Loading comments…</div>`;
      $("discussionInput").value = "";
      setDiscussionPenaltyPreviewFromSelected();

      // reset effect UI
      clearEffectSelection();

      const ref = db.collection("tickets").doc(ticketId);
      selectedTicketSnap = await ref.get();
      if (!selectedTicketSnap.exists) { toast("Ticket not found"); return; }

      const t = selectedTicketSnap.data() || {};
      $("sumAccused").textContent = t.accused || "—";
      $("sumReporter").textContent = t.reporter || "—";
      $("sumCompetition").textContent = t.competition || "—";
      $("sumEvent").textContent = t.event || "—";
      $("sumRule").textContent = t.ruleBreach || "—";
      renderProof(t.proofUrl || "");
      $("sumIncident").value = t.fullIncident || "";
      $("selSub").textContent = `Accused: ${t.accused || "-"} | Event: ${t.event || "-"}`;

      await loadStatements();
      await loadDiscussion();
      await loadMyReview();
      await refreshAggregate();
    }

    async function loadStatements() {
      if (!selectedTicketId) { $("statementsHint").textContent = "Select a ticket to view statements."; return; }
      $("statementsList").innerHTML = "";
      $("statementsHint").textContent = "Loading statements…";

      const col = db.collection("tickets").doc(selectedTicketId).collection("player_statements");
      const snap = await col.get();

      if (snap.empty) { $("statementsHint").textContent = "No player statements submitted yet."; return; }

      const rows = snap.docs.map(d => {
        const x = d.data() || {};
        const role = (x.role || "").trim();
        const name = (x.name || "").trim();
        const statement = (x.statement || "").trim();
        const ts = x.submittedAt && x.submittedAt.toDate ? x.submittedAt.toDate() : null;
        const when = ts ? ts.toLocaleString() : "";
        return { role, name, statement, when };
      }).filter(r => r.statement);

      const order = { accused:1, reporter:2, witness:3 };
      rows.sort((a,b) => (order[a.role?.toLowerCase()]||99)-(order[b.role?.toLowerCase()]||99));

      for (const r of rows) {
        const box = document.createElement("div");
        box.style.border = "1px solid #e5e7eb";
        box.style.borderRadius = "12px";
        box.style.padding = "12px";
        box.style.background = "#fff";

        const publishBtn = document.createElement("button");
        publishBtn.textContent = "Publish";
        publishBtn.style.minWidth = "110px";
        publishBtn.onclick = async () => {
          publishBtn.disabled = true;
          const original = publishBtn.textContent;
          publishBtn.textContent = "Publishing…";
          try {
            await publishStatementToDiscord(selectedTicketId, r);
            $("statementsHint").textContent = `Published ✅ (${(r.role||"").toUpperCase()})`;
          } catch (e) {
            $("statementsHint").textContent = "Publish failed: " + (e?.message || e);
          } finally {
            publishBtn.textContent = original;
            publishBtn.disabled = false;
          }
        };

        const top = document.createElement("div");
        top.className = "row";
        top.style.justifyContent = "space-between";

        const left = document.createElement("div");
        left.innerHTML = `<b>${escapeHtml((r.role||"").toUpperCase())} — ${escapeHtml(r.name || "")}</b><div class="muted" style="margin-top:4px;">${escapeHtml(r.when || "")}</div>`;

        const right = document.createElement("div");
        right.className = "row";
        right.appendChild(publishBtn);

        top.appendChild(left);
        top.appendChild(right);

        const body = document.createElement("div");
        body.style.marginTop = "10px";
        body.style.whiteSpace = "pre-wrap";
        body.textContent = r.statement;

        box.appendChild(top);
        box.appendChild(body);
        $("statementsList").appendChild(box);
      }

      $("statementsHint").textContent = `Loaded ${rows.length} statement(s).`;
    }

    async function publishAllStatements() {
      if (!selectedTicketId) { toast("Select a ticket first"); return; }

      const btn = publishAllBtn;
      btn.disabled = true;
      const original = btn.textContent;
      btn.textContent = "Publishing…";
      $("statementsHint").textContent = "Publishing all…";

      try {
        const col = db.collection("tickets").doc(selectedTicketId).collection("player_statements");
        const snap = await col.get();
        const rows = snap.docs.map(d => d.data() || {}).map(x => ({
          role: (x.role||"").trim(),
          name: (x.name||"").trim(),
          statement: (x.statement||"").trim(),
          when: x.submittedAt && x.submittedAt.toDate ? x.submittedAt.toDate().toLocaleString() : ""
        })).filter(x => x.statement);

        for (const r of rows) await publishStatementToDiscord(selectedTicketId, r);

        $("statementsHint").textContent = "Published all statements ✅";
        toast("Published all ✅");
        await loadTickets();
      } catch (e) {
        $("statementsHint").textContent = "Publish failed: " + (e?.message || e);
        toast("Publish failed");
      } finally {
        btn.textContent = original;
        btn.disabled = false;
      }
    }

    async function publishStatementToDiscord(ticketId, row) {
      if (!DISCORD_WEBHOOK_URL.startsWith("https://discord.com/api/webhooks/")) {
        throw new Error("Webhook invalid");
      }

      const role = (row.role || "").slice(0, 40);
      const name = (row.name || "").slice(0, 120);
      const statement = (row.statement || "").slice(0, 1500);

      const content =
`📄 **Player Statement**
**Ticket:** \`${ticketId}\`
**Role:** **${role}**
**Name:** ${name}
**Submitted:** ${row.when || ""}

> ${statement}`;

      const resp = await fetch(DISCORD_WEBHOOK_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ content })
      });

      if (!resp.ok) {
        const txt = await resp.text();
        throw new Error(`Discord publish failed: ${resp.status} ${resp.statusText} ${txt}`);
      }
    }

    // ---------- NEW: steward discussion (head steward sees author email) ----------
    async function loadDiscussion() {
      const list = $("discussionList");

      if (!selectedTicketId) {
        list.innerHTML = `<div class="muted">Select a ticket to view steward comments.</div>`;
        return;
      }

      list.innerHTML = `<div class="muted">Loading comments…</div>`;

      try {
        const col = db.collection("tickets").doc(selectedTicketId).collection("steward_comments");
        const snap = await col.orderBy("createdAt", "asc").limit(250).get();

        if (snap.empty) {
          list.innerHTML = `<div class="muted">No steward comments yet.</div>`;
          return;
        }

        list.innerHTML = "";
        snap.forEach(doc => {
          const d = doc.data() || {};
          const text = String(d.text || "").trim();
          if (!text) return;

          const ts = d.createdAt && d.createdAt.toDate ? d.createdAt.toDate() : null;
          const when = ts ? ts.toLocaleString() : "—";

          // Head steward can see who posted (authorKey or stewardEmail fallback)
          const author = String(d.authorKey || d.stewardEmail || "unknown").trim();

          const box = document.createElement("div");
          box.className = "commentBox";
          box.innerHTML = `
            <div><b>Stewards comment</b></div>
            <div class="commentMeta">${escapeHtml(when)}${author ? ` • <b>${escapeHtml(author)}</b>` : ""}</div>
          `;

          const body = document.createElement("div");
          body.style.marginTop = "10px";
          body.style.whiteSpace = "pre-wrap";
          body.textContent = text;

          box.appendChild(body);
          list.appendChild(box);
        });
      } catch (e) {
        console.error("loadDiscussion failed:", e);
        list.innerHTML = `<div class="muted">Failed to load comments (check console).</div>`;
      }
    }

    async function postDiscussion() {
      if (!selectedTicketId) { toast("Select a ticket first"); return; }

      const input = $("discussionInput");
      const text = (input.value || "").trim();
      if (!text) { toast("Type a comment first"); return; }

      postDiscussionBtn.disabled = true;
      const original = postDiscussionBtn.textContent;
      postDiscussionBtn.textContent = "Posting…";

      try {
        const col = db.collection("tickets").doc(selectedTicketId).collection("steward_comments");

        // Store authorKey for oversight/audit (head steward view shows this)
        const authorKey = safeKey(currentEmail);

        await col.add({
          text,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          authorKey
        });

        input.value = "";
        toast("Comment posted ✅");
        await loadDiscussion();
      } catch (e) {
        toast("Post failed: " + (e?.message || e));
      } finally {
        postDiscussionBtn.textContent = original;
        postDiscussionBtn.disabled = false;
      }
    }

    // ---------- NEW: penalty opinion poster (Head Steward) ----------
    async function postPenaltyOpinion() {
      if (!selectedTicketId) { toast("Select a ticket first"); return; }

      const sel = $("discussionPenaltyCode");
      if (!sel) { toast("Penalty opinion dropdown missing"); return; }

      const opt = sel.selectedOptions && sel.selectedOptions[0] ? sel.selectedOptions[0] : null;
      const value = (sel.value || "").trim();
      if (!opt || !value) { toast("Select a penalty code first"); return; }

      const code = (opt.dataset.code || "").trim();
      const title = (opt.dataset.title || "").trim();
      const pen = (opt.dataset.penalty || "").trim();
      const who = (opt.dataset.who || "").trim();
      const desc = (opt.dataset.desc || "").trim();
      const ex = (opt.dataset.example || "").trim();

      const note = ($("discussionInput")?.value || "").trim();

      const msg =
`🧾 PENALTY OPINION (HEAD STEWARD)
Code: ${code}${title ? " — " + title : ""}
Penalty: ${pen || "—"}
Who: ${who || "—"}${desc ? "\n\nDescription:\n" + desc : ""}${ex ? "\n\nExample:\n" + ex : ""}${note ? "\n\nHead Steward note:\n" + note : ""}`;

      const btn = $("postPenaltyOpinionBtn");
      if (btn) {
        btn.disabled = true;
        var original = btn.textContent;
        btn.textContent = "Posting…";
      }

      try {
        const col = db.collection("tickets").doc(selectedTicketId).collection("steward_comments");
        const authorKey = safeKey(currentEmail);

        await col.add({
          text: msg,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          authorKey,
          kind: "penalty_opinion",
          penaltyCode: value
        });

        toast("Penalty opinion posted ✅");
        await loadDiscussion();
      } catch (e) {
        toast("Post failed: " + (e?.message || e));
      } finally {
        if (btn) {
          btn.textContent = original || "Submit Penalty Opinion to Chat";
          btn.disabled = false;
        }
      }
    }

    // ---------- NEW: Steward Input Audit (Last 7 Days) ----------
    async function loadStewardAudit7d() {
      const metaEl = $("auditMeta");
      const wrapEl = $("auditTableWrap");
      const bodyEl = $("auditTbody");

      wrapEl.style.display = "none";
      bodyEl.innerHTML = "";
      metaEl.textContent = "Loading steward input…";

      const now = Date.now();
      const sinceMs = now - (7 * 24 * 60 * 60 * 1000);
      const since = firebase.firestore.Timestamp.fromDate(new Date(sinceMs));

      // Map: key -> stats
      const m = new Map();
      function getOrCreate(key, label) {
        if (!m.has(key)) {
          m.set(key, {
            key,
            label: label || key,
            comments: 0,
            reviews: 0,
            tickets: new Set(),
            lastActiveMs: 0
          });
        }
        return m.get(key);
      }

      // Extract ticketId from /tickets/<ticketId>/<subcollection>/<docId>
      function ticketIdFromDocRef(docRef) {
        try {
          return docRef?.parent?.parent?.id || "";
        } catch {
          return "";
        }
      }

      let commentDocs = 0;
      let reviewDocs = 0;

      try {
        // Comments (7 days) — collectionGroup
        const commentsSnap = await db
          .collectionGroup("steward_comments")
          .where("createdAt", ">=", since)
          .get();

        commentDocs = commentsSnap.size;

        commentsSnap.forEach(doc => {
          const d = doc.data() || {};
          const ts = d.createdAt && d.createdAt.toDate ? d.createdAt.toDate() : null;
          if (!ts) return;

          const author = String(d.authorKey || d.stewardEmail || "unknown").trim() || "unknown";
          const key = safeKey(author) || "unknown";
          const ticketId = ticketIdFromDocRef(doc.ref);

          const s = getOrCreate(key, author);
          s.comments += 1;
          if (ticketId) s.tickets.add(ticketId);

          const tms = ts.getTime();
          if (tms > s.lastActiveMs) s.lastActiveMs = tms;
        });

        // Reviews (7 days)
        const reviewsSnap = await db
          .collectionGroup("reviews")
          .where("submittedAt", ">=", since)
          .get();

        reviewDocs = reviewsSnap.size;

        reviewsSnap.forEach(doc => {
          const d = doc.data() || {};
          const ts = d.submittedAt && d.submittedAt.toDate ? d.submittedAt.toDate() : null;
          if (!ts) return;

          const author = String(d.stewardEmail || d.authorKey || "unknown").trim() || "unknown";
          const key = safeKey(author) || "unknown";
          const ticketId = ticketIdFromDocRef(doc.ref);

          const s = getOrCreate(key, author);
          s.reviews += 1;
          if (ticketId) s.tickets.add(ticketId);

          const tms = ts.getTime();
          if (tms > s.lastActiveMs) s.lastActiveMs = tms;
        });

        const rows = [...m.values()]
          .filter(x => (x.comments + x.reviews) > 0)
          .sort((a,b) => ((b.comments + b.reviews) - (a.comments + a.reviews)) || (b.lastActiveMs - a.lastActiveMs));

        if (!rows.length) {
          metaEl.textContent = "No steward activity in the last 7 days.";
          return;
        }

        for (const r of rows) {
          const tr = document.createElement("tr");
          const last = r.lastActiveMs ? new Date(r.lastActiveMs).toLocaleString() : "—";
          const ticketsTouched = r.tickets.size;

          tr.innerHTML = `
            <td class="mono">${escapeHtml(r.label)}</td>
            <td><b>${r.comments}</b></td>
            <td><b>${r.reviews}</b></td>
            <td><b>${ticketsTouched}</b></td>
            <td>${escapeHtml(last)}</td>
          `;
          bodyEl.appendChild(tr);
        }

        wrapEl.style.display = "block";
        metaEl.textContent = `Loaded. Comments scanned: ${commentDocs} • Reviews scanned: ${reviewDocs} • Window: last 7 days.`;
      } catch (e) {
        console.error("loadStewardAudit7d failed:", e);
        metaEl.textContent = "Audit failed. Likely missing Firestore index for collectionGroup query, or rules deny access. Check console for the exact Firebase error (it often includes a 'create index' link).";
      }
    }

    async function loadMyReview() {
      if (!selectedTicketId) return;

      const reviewId = safeKey(currentEmail);
      const ref = db.collection("tickets").doc(selectedTicketId).collection("reviews").doc(reviewId);
      const snap = await ref.get();

      if (!snap.exists) {
        $("myReviewStatus").textContent = "Not submitted";
        $("myReviewStatus").className = "badge";
        clearEffectSelection();
        updateEffectPreview();
        return;
      }

      const d = snap.data() || {};
      const cause = d.CAUSE || {};

      $("cScore").value = String(clampScore(cause.control?.score));
      $("cText").value = cause.control?.text || "";

      $("aScore").value = String(clampScore(cause.awareness?.score));
      $("aText").value = cause.awareness?.text || "";

      const uObj = cause.userInput || {};
      const uStored = clampScore(uObj.score);
      const isReversed = (uObj.reversed === true) || ((d.schemaVersion || 0) >= 2);
      $("uScore").value = String(isReversed ? unreverseScore(uStored) : uStored);
      $("uText").value = uObj.text || "";

      $("sScore").value = String(clampScore(cause.severity?.score));
      $("sText").value = cause.severity?.text || "";

      $("eScore").value = String(clampScore(cause.environment?.score));
      $("eText").value = cause.environment?.text || "";

      $("penaltyCode").value = d.penaltyCode || "";
      $("privateOpinion").value = d.privateOpinion || "";

      // NEW: Load EFFECT
      const keys = Array.isArray(d?.EFFECT?.keys) ? d.EFFECT.keys : [];
      setEffectSelection(keys);

      // keep preview in sync when loading saved review
      setPenaltyPreviewFromSelected();

      $("myReviewStatus").textContent = "Submitted ✅";
      $("myReviewStatus").className = "badge ok";
      toast("Loaded your review");
    }

    async function submitMyReview() {
      if (!selectedTicketId) { toast("Select a ticket first"); return; }

      const pen = ($("penaltyCode").value || "").trim();
      if (!pen) { toast("Penalty code required"); return; }

      submitReviewBtn.disabled = true;
      const original = submitReviewBtn.textContent;
      submitReviewBtn.textContent = "Submitting…";

      try {
        const reviewId = safeKey(currentEmail);
        const ref = db.collection("tickets").doc(selectedTicketId).collection("reviews").doc(reviewId);

        const uUi = Number($("uScore").value);
        const uStored = reverseScore(uUi);

        // NEW: EFFECT payload
        const effKeys = [...effectSelected];
        const eff = computeEffectTotalFromKeys(effKeys);

        const rawCause = avg([
          Number($("cScore").value),
          Number($("aScore").value),
          uStored,
          Number($("sScore").value),
          Number($("eScore").value),
        ]);
        let final = clamp(rawCause + eff.sumClamped, 1, 5);
        const firstLap = anyFirstLapSelected(effKeys);
        if (firstLap) final = Math.max(final, 4.0);

        const review = {
          stewardEmail: currentEmail,
          submittedAt: firebase.firestore.Timestamp.fromDate(new Date()),
          isFinal: true,
          schemaVersion: 3,
          CAUSE: {
            control:      { score: Number($("cScore").value), text: ($("cText").value||"").trim() },
            awareness:    { score: Number($("aScore").value), text: ($("aText").value||"").trim() },
            userInput:    { score: uStored, text: ($("uText").value||"").trim(), reversed: true },
            severity:     { score: Number($("sScore").value), text: ($("sText").value||"").trim() },
            environment:  { score: Number($("eScore").value), text: ($("eText").value||"").trim() },
          },
          EFFECT: {
            keys: effKeys,
            sumRaw: eff.sumRaw,
            sumClamped: eff.sumClamped,
            clampMin: -1,
            clampMax: +1,
            hasFirstLapLock: firstLap === true
          },
          // Stored for transparency/debug
          computed: {
            rawCause: Math.round(rawCause * 100) / 100,
            finalCauseEffect: Math.round(final * 100) / 100
          },
          penaltyCode: pen,
          privateOpinion: ($("privateOpinion").value || "").trim()
        };

        await ref.set(review, { merge: true });

        $("myReviewStatus").textContent = "Submitted ✅";
        $("myReviewStatus").className = "badge ok";

        updateEffectPreview();

        toast(`Review submitted ✅`);
        await loadTickets();
        await refreshAggregate();
      } catch (e) {
        toast("Submit failed: " + (e?.message || e));
      } finally {
        submitReviewBtn.textContent = original;
        submitReviewBtn.disabled = false;
      }
    }

    async function refreshAggregate() {
      if (!selectedTicketId) return;

      $("aggHint").textContent = "Calculating…";
      $("aggBox").innerHTML = "";
      $("aggCalcBox").style.display = "none";
      $("aggCalcBox").innerHTML = "";
      $("aggEffectsBox").style.display = "none";
      $("aggEffectsBox").innerHTML = "";

      try {
        const agg = await computeAggregateForTicket(selectedTicketId);
        if (!agg) { $("aggHint").textContent = "No reviews submitted yet."; return; }

        $("aggHint").textContent =
          `Reviews: ${agg.reviewsCount} | FINAL: ${agg.final.toFixed(2)} | Suggested: ${agg.tier}`;

        $("aggBox").innerHTML = `
          <div class="grid2">
            <div><b>C</b> (Control): ${agg.avgC}</div>
            <div><b>A</b> (Awareness): ${agg.avgA}</div>
            <div><b>U</b> (User Input): ${agg.avgU}</div>
            <div><b>S</b> (Severity): ${agg.avgS}</div>
            <div><b>E</b> (Environment): ${agg.avgE}</div>
          </div>
          <div class="muted" style="margin-top:8px;">
            U is scored on a reversed scale for CAUSE (legacy reviews auto-corrected).
          </div>
        `;

        // Calculation explanation
        const calc = $("aggCalcBox");
        if (calc){
          calc.style.display = "block";
          const lockLine = agg.anyFirstLap ? `<div style="margin-top:6px;"><b>Lock applied:</b> First corner incident -> FINAL >= 4.00</div>` : "";
          calc.innerHTML = `
            <div><b>CAUSE+EFFECT Calculation</b></div>
            <div style="margin-top:6px;" class="mono">
              RAW CAUSE ${agg.rawCause.toFixed(2)} + AVG EFFECT ${agg.avgEffect >= 0 ? "+" : ""}${agg.avgEffect.toFixed(2)} = FINAL ${agg.final.toFixed(2)}
            </div>
            ${lockLine}
            <div class="muted" style="margin-top:6px;">
              RAW CAUSE is the average of the five CAUSE category averages. AVG EFFECT is the average of each steward’s clamped EFFECT total (-1.00..+1.00).
            </div>
          `;
        }

        // Most common effects (by count)
        const counts = new Map(); // key -> count
        for (const r of agg.reviews){
          const ks = Array.isArray(r?.EFFECT?.keys) ? r.EFFECT.keys : [];
          for (const k of ks){
            const kk = String(k || "").trim();
            if (!kk) continue;
            counts.set(kk, (counts.get(kk) || 0) + 1);
          }
        }

        const sorted = [...counts.entries()].sort((a,b)=>b[1]-a[1]).slice(0, 12);
        const effBox = $("aggEffectsBox");
        if (effBox){
          effBox.style.display = "block";
          if (!sorted.length){
            effBox.innerHTML = `<div><b>Effects selected (team)</b></div><div class="muted" style="margin-top:6px;">No effects selected in submitted reviews yet.</div>`;
          } else {
            const lines = sorted.map(([k,c]) => {
              const ef = findEffectByKey(k);
              const name = ef ? ef.label : k;
              const delta = ef ? (Number(ef.delta || 0)) : 0;
              const dTxt = (delta >= 0 ? "+" : "") + delta.toFixed(2);
              return `• ${name} (${dTxt}) — selected by ${c}/${agg.reviewsCount}`;
            }).join("<br>");
            effBox.innerHTML = `
              <div><b>Effects selected (team)</b></div>
              <div style="margin-top:6px;">${lines}</div>
              <div class="muted" style="margin-top:6px;">
                Display shows the most common effect checkboxes across submitted reviews.
              </div>
            `;
          }
        }

      } catch (e) {
        $("aggHint").textContent = "Aggregate failed: " + (e?.message || e);
      }
    }

    // ---------- STARTUP ----------
    async function waitForFirebaseReady(maxMs = 8000) {
      const start = Date.now();
      while (Date.now() - start < maxMs) {
        if (typeof auth !== "undefined" && typeof db !== "undefined" && auth && db) return true;
        await new Promise(r => setTimeout(r, 80));
      }
      return false;
    }

    (async () => {
      const ok = await waitForFirebaseReady();
      if (!ok) {
        toast("Firebase not ready.\nCheck firebase-init.js path + console.");
        return;
      }

      auth.onAuthStateChanged(async (user) => {
        try {
          if (!user) { window.location.href = "admin.html"; return; }
          currentUser = user;
          currentEmail = (user.email || "").toLowerCase().trim();

          const adminSnap = await db.collection("admins").doc(currentEmail).get();
          if (!adminSnap.exists) { await auth.signOut(); window.location.href = "admin.html"; return; }

          const data = adminSnap.data() || {};
          const roleRaw = (data.role || "").toLowerCase();
          isHead = roleRaw.includes("head") || data.headsteward === true || data.owner === true;

          if (!isHead) { window.location.href = "steward.html"; return; }

          const nameGuess = (currentEmail.split("@")[0] || "").replace(/[._-]+/g, " ").trim();
          const niceName = nameGuess ? nameGuess.replace(/\b\w/g, c => c.toUpperCase()) : "Head Steward";
          welcomeLineEl.textContent = `Welcome, ${niceName}. You oversee all live tickets — publish statements, monitor aggregate CAUSE+EFFECT, and guide steward outcomes.`;

          $("who").textContent = `Signed in as: ${currentEmail} | role: ${data.role || "headsteward"}`;

          // Load penalty codes for Head Steward CAUSE + discussion dropdowns
          await loadPenaltyCodes();

          // Wire previews
          const causeSel = $("penaltyCode");
          if (causeSel) causeSel.onchange = () => setPenaltyPreviewFromSelected();
          setPenaltyPreviewFromSelected();

          const dSel = $("discussionPenaltyCode");
          if (dSel) dSel.onchange = () => setDiscussionPenaltyPreviewFromSelected();
          setDiscussionPenaltyPreviewFromSelected();

          // NEW: render Effect UI
          renderEffectsUI();

          await loadTickets();
          await loadStewardAudit7d(); // auto-load audit panel
        } catch (e) {
          toast("Auth/load error: " + (e?.message || e));
        }
      });
    })();
  </script>
</body>
</html>
