<!DOCTYPE html>
<html>
<head>
  <title>IFWL SimGrid — Finalised Tickets</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body{
      font-family: Arial, sans-serif;
      margin:0;
      background:
        linear-gradient(rgba(2,6,23,0.72), rgba(2,6,23,0.72)),
        url("./ifwl_bg.webp");
      background-size:cover;
      background-position:center;
      background-attachment:fixed;
    }

    header{
      padding:14px 18px;
      background:#111827;
      color:#fff;
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
    }

    .brand{
      display:flex;
      gap:12px;
      align-items:flex-start;
      min-width:0;
    }
    .brand img{
      width:38px;height:38px;object-fit:contain;margin-top:2px;flex:0 0 auto;
      filter: drop-shadow(0 1px 1px rgba(0,0,0,0.25));
    }
    .brandText{min-width:0;}
    header .small{font-size:12px;opacity:0.85;margin-top:4px;line-height:1.2;word-break:break-word;}
    .welcomeLine{font-size:12px;opacity:0.95;margin-top:6px;line-height:1.25;}

    .wrap{padding:14px; display:grid; grid-template-columns: 1fr; gap:14px;}

    .card{
      background:rgba(255,255,255,0.92);
      border:1px solid rgba(229,231,235,0.95);
      border-radius:12px;
      padding:12px;
      box-shadow:0 10px 28px rgba(0,0,0,0.18);
    }

    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .title{font-weight:800; font-size:16px; margin:0;}
    .muted{color:#6b7280; font-size:12px;}

    button{padding:10px 12px; border:1px solid #d1d5db; border-radius:12px; background:#fff; cursor:pointer;}
    button.primary{background:#111827;color:#fff;border-color:#111827;}
    button.danger{background:#991b1b;color:#fff;border-color:#991b1b;}
    button:disabled{opacity:0.6;cursor:not-allowed;}

    select, input{
      padding:10px; border:1px solid #d1d5db; border-radius:12px;
      box-sizing:border-box; font-size:16px; background:#fff;
    }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:4px 10px; border-radius:999px;
      border:1px solid #e5e7eb; background:#fff;
      font-size:12px; color:#111827; white-space:nowrap;
    }
    .pill strong{font-weight:900;}

    .tableWrap{
      overflow:auto;
      border:1px solid #e5e7eb;
      border-radius:12px;
      background:#fff;
      margin-top:10px;
    }
    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      min-width:1280px; /* slightly wider due to new columns */
    }
    th, td{
      padding:10px;
      border-bottom:1px solid #f3f4f6;
      font-size:13px;
      text-align:left;
      vertical-align:top;
    }
    th{
      position:sticky;
      top:0;
      background:#f9fafb;
      z-index:2;
      font-size:12px;
      color:#111827;
      border-bottom:1px solid #e5e7eb;
      white-space:nowrap;
    }
    tr:last-child td{border-bottom:0;}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, monospace;}
    a{color:#111827;}
    a:hover{opacity:0.85;}

    .tag{
      display:inline-block;
      padding:3px 10px;
      border-radius:999px;
      border:1px solid #e5e7eb;
      background:#fff;
      font-size:12px;
      font-weight:800;
      white-space:nowrap;
    }
    .tag.ok{border-color:#86efac;background:#ecfdf5;color:#065f46;}
    .tag.bad{border-color:#fca5a5;background:#fef2f2;color:#991b1b;}
    .tag.neutral{border-color:#d1d5db;background:#f9fafb;color:#111827;}

    .toast{
      position:fixed; right:16px; bottom:16px;
      background:#111827; color:#fff;
      padding:10px 12px; border-radius:12px;
      opacity:0; transform: translateY(8px);
      transition: all .18s ease;
      z-index:9999;
      max-width: min(520px, calc(100vw - 32px));
      white-space: pre-wrap;
    }
    .toast.show{opacity:1; transform: translateY(0);}

    /* Modal */
    .modalOverlay{
      position:fixed;
      inset:0;
      background:rgba(2,6,23,0.72);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:9998;
    }
    .modalOverlay.show{display:flex;}
    .modal{
      width:min(560px, 100%);
      background:#fff;
      border-radius:16px;
      border:1px solid #e5e7eb;
      box-shadow:0 18px 48px rgba(0,0,0,0.30);
      overflow:hidden;
    }
    .modalHeader{
      padding:12px 14px;
      background:#111827;
      color:#fff;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
    }
    .modalTitle{
      font-weight:900;
      font-size:14px;
      line-height:1.2;
      margin:0;
    }
    .modalBody{padding:14px;}
    .modalBody p{margin:0 0 10px 0; font-size:13px; color:#111827;}
    .modalBody .muted{font-size:12px;}
    .modalFooter{
      padding:12px 14px;
      background:#f9fafb;
      border-top:1px solid #e5e7eb;
      display:flex;
      justify-content:flex-end;
      gap:10px;
      flex-wrap:wrap;
    }
    .miniGrid{
      display:grid;
      grid-template-columns: 140px 1fr;
      gap:8px 10px;
      margin-top:10px;
      font-size:13px;
    }
    .miniGrid .k{color:#6b7280; font-size:12px;}
    .miniGrid .v{color:#111827;}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size:12px;
      border:1px solid #e5e7eb;
      background:#f9fafb;
      padding:2px 6px;
      border-radius:6px;
      white-space:nowrap;
    }

    @media (max-width: 980px){
      body{background-attachment:scroll;}
      header{flex-direction:column; align-items:stretch;}
      header .row{width:100%;}
      header button{width:100%;}
      table{min-width:1120px;}
    }
  </style>
</head>

<body>
  <header>
    <div class="brand">
      <img src="./ifwl_logo.png" alt="IFWL logo">
      <div class="brandText">
        <div style="font-weight:800; font-size:18px;">IFWL SimGrid — Finalised Tickets</div>
        <div class="welcomeLine" id="welcomeLine">Loading your profile…</div>
        <div class="small" id="who">Loading…</div>
      </div>
    </div>

    <div class="row">
      <button id="backBtn">Back to Classifier</button>
      <button id="logoutBtn">Sign out</button>
    </div>
  </header>

  <div class="wrap">
    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div class="title">Publish Queue</div>
        <div class="row">
          <button id="refreshBtn">Refresh</button>
        </div>
      </div>

      <div class="row" style="margin-top:10px; justify-content:space-between;">
        <div class="row">
          <span class="pill" id="countPill">Loading…</span>
          <span class="pill" id="modePill">Mode: …</span>
          <span class="pill" id="permPill">Permissions: …</span>
        </div>

        <div class="row">
          <label class="muted" style="margin-right:6px;">Show</label>
          <select id="viewMode">
            <option value="greenlit" selected>Greenlit only</option>
            <option value="pending">Pending green light</option>
            <option value="all">All finalised</option>
          </select>

          <input id="search" placeholder="Search ticket / accused / reporter / event…" style="min-width:280px;">
        </div>
      </div>

      <div class="muted" style="margin-top:8px;">
        Shows finalised tickets. Greenlit means Head Steward has approved it for publishing.
        Pending green light means it is awaiting Head Steward confirmation.
        Submitted to SimGrid means SimGrid has processed it and it’s now completed (hidden from the greenlit queue).
        <span id="headHint"></span>
      </div>

      <div class="tableWrap">
        <table aria-label="Finalised tickets table">
          <thead>
            <tr>
              <th>Greenlit</th>
              <th>Actions</th>
              <th>Audit</th>
              <th>Ticket</th>
              <th>Status</th>
              <th>Event</th>
              <th>Competition</th>
              <th>Accused</th>
              <th>Reporter</th>
              <th>Track</th>
              <th>Penalty</th>
              <th>Decision</th>
              <th>Timestamp</th>
              <th>Proof</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>

      <div class="muted" style="margin-top:8px;" id="hint">—</div>
    </div>
  </div>

  <div class="toast" id="toast">Saved</div>

  <!-- Confirmation Modal -->
  <div class="modalOverlay" id="modalOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div class="modalHeader">
        <div>
          <div class="modalTitle" id="modalTitle">Confirm action</div>
          <div class="muted" id="modalSubtitle" style="color:rgba(255,255,255,0.85); margin-top:4px;"></div>
        </div>
        <button id="modalCloseBtn" aria-label="Close">✕</button>
      </div>

      <div class="modalBody">
        <p id="modalBodyText">—</p>

        <div class="miniGrid" id="modalMeta">
          <!-- filled dynamically -->
        </div>

        <div class="muted" style="margin-top:10px;">
          Tip: press <span class="kbd">Esc</span> to cancel.
        </div>
      </div>

      <div class="modalFooter">
        <button id="modalCancelBtn">Cancel</button>
        <button id="modalConfirmBtn" class="primary">Confirm</button>
      </div>
    </div>
  </div>

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <script src="./firebase-init.js"></script>

  <script>
    const $ = (id) => document.getElementById(id);

    const toastEl = $("toast");
    function toast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      setTimeout(() => toastEl.classList.remove("show"), 2200);
    }

    function safeKey(email){ return (email || "").replaceAll("/", "_").replaceAll("\\", "_").trim(); }
    function escapeHtml(s){ return (s || "").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;"); }

    function isFinalised(status){
      const s = (status || "").trim().toUpperCase();
      return s === "FINALISED" || s === "FINALIZED" || s === "CLOSED" || s === "RESOLVED";
    }

    // RP code -> penalty fallback (only used if no (15s) present)
    const rpPenaltyMap = {
      "RP1MI":"10s","RP1ST":"30s","RP1SE":"SG30",
      "RP2MI":"10s","RP2ST":"30s","RP2SE":"SG30",
      "RP3MI":"5s","RP3ST":"15s","RP3SE":"SG30",
      "RP4MI":"30s","RP4ST":"SG30","RP4SE":"DQ",
      "RP5MI":"5s","RP5ST":"15s","RP5SE":"30s",
      "RP6MI":"5s","RP6ST":"30s","RP6SE":"SG30",
      "RP7MI":"10s","RP7ST":"30s","RP7SE":"SG30",
      "RP8MI":"5s","RP8ST":"15s","RP8SE":"SG30",
      "RP9MI":"5s","RP9ST":"15s","RP9SE":"SG30",
      "RP10MI":"10s","RP10ST":"10s","RP10SE":"10s",
      "RP11MI":"DQ","RP11ST":"DQ","RP11SE":"DQ",
      "RP12MI":"10s","RP12ST":"20s","RP12SV":"30s",
      "RP13MI":"10s","RP13ST":"30s","RP13SV":"DQ"
    };

    function parsePenaltyFromText(text){
      const src = String(text || "").trim();
      if (!src) return "-";

      const up = src.toUpperCase();

      // Explicit outcomes
      if (up.includes("NFA")) return "NFA";
      // If the text itself contains DQ anywhere, respect it
      if (up.includes("DQ")) return "DQ";

      // Seconds in brackets: (15s) / (15 s) / (15sec)
      const mSec = src.match(/\((\s*\d+\s*)(s|sec|secs|seconds)?\s*\)/i);
      if (mSec && mSec[1]) {
        const n = parseInt(String(mSec[1]).replace(/\D/g,""), 10);
        if (!isNaN(n) && n > 0) return `${n}s`;
      }

      // RP code fallback
      const mRp = src.match(/\b(RP[0-9A-Z]+)\b/i);
      if (mRp && mRp[1]) {
        const code = String(mRp[1]).toUpperCase();
        if (rpPenaltyMap[code]) return rpPenaltyMap[code];
        return code;
      }

      return src.slice(0, 80);
    }

    function ticketPenalty(ticket){
      // prefer postRaceCode, fallback ruleBreach
      const prc = ticket.postRaceCode || "";
      const rb  = ticket.ruleBreach || "";
      return parsePenaltyFromText(prc || rb);
    }

    function formatTimestamp(v){
      try{
        if (!v) return "";
        if (v.toDate) return v.toDate().toLocaleString();
        const d = new Date(v);
        if (!isNaN(d.getTime())) return d.toLocaleString();
      }catch{}
      return "";
    }

    function timestampMs(v){
      try{
        if (!v) return 0;
        if (v.toDate) return v.toDate().getTime();
        const d = new Date(v);
        const ms = d.getTime();
        return isNaN(ms) ? 0 : ms;
      }catch{
        return 0;
      }
    }

    // auth state
    let currentEmail = "";
    let roleText = "";
    let isHeadSteward = false;
    let isSimgrid = false;
    let isSimgridOnly = false; // ONLY simgrid users get "Submitted to SimGrid"

    $("backBtn").onclick = () => window.location.href = "index.html";
    $("logoutBtn").onclick = async () => { await auth.signOut(); window.location.href = "admin.html"; };

    $("refreshBtn").onclick = () => loadFinalised();
    $("viewMode").onchange = () => loadFinalised();
    $("search").oninput = () => renderFiltered();

    let allRows = []; // cached ticket objects
    let busyIds = new Set(); // disable buttons while updating

    function matchesSearch(t, q){
      if (!q) return true;
      const s = q.toLowerCase().trim();
      const hay = [
        t.id, t.status, t.event, t.competition, t.accused, t.reporter, t.track,
        t.stewardDecision, t.postRaceCode, t.ruleBreach,
        t.simgridGreenlitBy, t.simgridRevokedBy, t.simgridPendingBy,
        t.simgridSubmittedBy
      ].map(x => String(x || "").toLowerCase()).join(" | ");
      return hay.includes(s);
    }

    /* ---------------------------
       Modal helpers
    ---------------------------- */
    const modal = {
      overlay: $("modalOverlay"),
      title: $("modalTitle"),
      subtitle: $("modalSubtitle"),
      body: $("modalBodyText"),
      meta: $("modalMeta"),
      cancelBtn: $("modalCancelBtn"),
      confirmBtn: $("modalConfirmBtn"),
      closeBtn: $("modalCloseBtn"),
      pending: null
    };

    function closeModal(){
      modal.pending = null;
      modal.overlay.classList.remove("show");
      modal.overlay.setAttribute("aria-hidden", "true");
      modal.confirmBtn.disabled = false;
      modal.confirmBtn.classList.remove("danger");
      modal.confirmBtn.classList.add("primary");
      modal.confirmBtn.textContent = "Confirm";
    }

    function openModal({ title, subtitle, body, confirmText, confirmStyle, metaRows, onConfirm }){
      modal.title.textContent = title || "Confirm action";
      modal.subtitle.textContent = subtitle || "";
      modal.body.textContent = body || "";
      modal.meta.innerHTML = (metaRows || []).map(r => `
        <div class="k">${escapeHtml(r.k)}</div>
        <div class="v">${r.v}</div>
      `).join("");

      modal.confirmBtn.textContent = confirmText || "Confirm";
      modal.confirmBtn.classList.remove("primary","danger");
      modal.confirmBtn.classList.add(confirmStyle === "danger" ? "danger" : "primary");

      modal.pending = onConfirm;

      modal.overlay.classList.add("show");
      modal.overlay.setAttribute("aria-hidden", "false");
      modal.cancelBtn.focus();
    }

    modal.cancelBtn.onclick = closeModal;
    modal.closeBtn.onclick = closeModal;
    modal.overlay.addEventListener("click", (e) => {
      if (e.target === modal.overlay) closeModal();
    });
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && modal.overlay.classList.contains("show")) closeModal();
    });
    modal.confirmBtn.onclick = async () => {
      if (!modal.pending) return closeModal();
      try{
        modal.confirmBtn.disabled = true;
        await modal.pending();
        closeModal();
      }catch(err){
        console.error(err);
        toast("Action failed:\n" + (err?.message || err));
        modal.confirmBtn.disabled = false;
      }
    };

    /* ---------------------------
       Firestore update helpers
    ---------------------------- */
    function serverNow(){
      // Firestore server timestamp via compat:
      return firebase.firestore.FieldValue.serverTimestamp();
    }

    async function setPendingGreenlight(ticketId, makePending){
      if (!isHeadSteward){
        toast("Only Head Stewards can set pending green light.");
        return;
      }
      if (!ticketId) return;

      if (busyIds.has(ticketId)) return;
      busyIds.add(ticketId);
      renderFiltered();

      try{
        const ref = db.collection("tickets").doc(ticketId);

        if (makePending){
          await ref.update({
            simgridPendingGreenlit: true,
            simgridPendingBy: currentEmail,
            simgridPendingAt: serverNow()
          });
          toast("Marked as Pending ✅");
        } else {
          await ref.update({
            simgridPendingGreenlit: false,
            simgridPendingBy: firebase.firestore.FieldValue.delete(),
            simgridPendingAt: firebase.firestore.FieldValue.delete()
          });
          toast("Pending cleared ✅");
        }

        await loadFinalised();
      } finally {
        busyIds.delete(ticketId);
        renderFiltered();
      }
    }

    async function setGreenlight(ticketId, makeGreenlit){
      if (!isHeadSteward){
        toast("Only Head Stewards can greenlight/revoke.");
        return;
      }
      if (!ticketId) return;

      if (busyIds.has(ticketId)) return;
      busyIds.add(ticketId);
      renderFiltered(); // refresh disables

      try{
        const ref = db.collection("tickets").doc(ticketId);
        if (makeGreenlit){
          await ref.update({
            simgridGreenlit: true,
            simgridGreenlitBy: currentEmail,
            simgridGreenlitAt: serverNow(),

            // clear pending (since it is now confirmed)
            simgridPendingGreenlit: false,
            simgridPendingBy: firebase.firestore.FieldValue.delete(),
            simgridPendingAt: firebase.firestore.FieldValue.delete(),

            // clear revoke audit fields (optional)
            simgridRevokedBy: firebase.firestore.FieldValue.delete(),
            simgridRevokedAt: firebase.firestore.FieldValue.delete()
          });
          toast("Greenlit ✅");
        } else {
          await ref.update({
            simgridGreenlit: false,

            // clear pending when revoking to avoid confusion
            simgridPendingGreenlit: false,
            simgridPendingBy: firebase.firestore.FieldValue.delete(),
            simgridPendingAt: firebase.firestore.FieldValue.delete(),

            simgridRevokedBy: currentEmail,
            simgridRevokedAt: serverNow()
          });
          toast("Revoked ✅");
        }

        await loadFinalised(); // reload fresh server values
      } finally {
        busyIds.delete(ticketId);
        renderFiltered();
      }
    }

    async function setSubmittedToSimgrid(ticketId){
      if (!isSimgridOnly){
        toast("Only SimGrid users can submit tickets to SimGrid.");
        return;
      }
      if (!ticketId) return;

      if (busyIds.has(ticketId)) return;
      busyIds.add(ticketId);
      renderFiltered();

      try{
        const ref = db.collection("tickets").doc(ticketId);

        // IMPORTANT: This is the completion flag the UI reads (simgridSubmitted)
        await ref.update({
          simgridSubmitted: true,
          simgridSubmittedBy: currentEmail,
          simgridSubmittedAt: serverNow(),

          // ensure it cannot remain pending
          simgridPendingGreenlit: false,
          simgridPendingBy: firebase.firestore.FieldValue.delete(),
          simgridPendingAt: firebase.firestore.FieldValue.delete()
        });

        toast("Published to SimGrid ✅ (Completed)");
        await loadFinalised();
      } finally {
        busyIds.delete(ticketId);
        renderFiltered();
      }
    }

    function auditText(t){
      const submitted = !!t.simgridSubmitted;
      const green = !!t.simgridGreenlit;
      const pending = !!t.simgridPendingGreenlit && !green;

      if (submitted){
        const who = t.simgridSubmittedBy ? escapeHtml(t.simgridSubmittedBy) : "—";
        const when = t.simgridSubmittedAt ? escapeHtml(formatTimestamp(t.simgridSubmittedAt)) : "—";
        return `
          <span class="tag ok">Published</span>
          <div class="muted" style="margin-top:4px;">By: ${who}</div>
          <div class="muted">At: ${when}</div>
        `;
      }

      if (green){
        const who = t.simgridGreenlitBy ? escapeHtml(t.simgridGreenlitBy) : "—";
        const when = t.simgridGreenlitAt ? escapeHtml(formatTimestamp(t.simgridGreenlitAt)) : "—";
        return `
          <span class="tag ok">Approved</span>
          <div class="muted" style="margin-top:4px;">By: ${who}</div>
          <div class="muted">At: ${when}</div>
        `;
      }

      if (pending){
        const who = t.simgridPendingBy ? escapeHtml(t.simgridPendingBy) : "—";
        const when = t.simgridPendingAt ? escapeHtml(formatTimestamp(t.simgridPendingAt)) : "—";
        return `
          <span class="tag neutral">Pending</span>
          <div class="muted" style="margin-top:4px;">By: ${who}</div>
          <div class="muted">At: ${when}</div>
          <div class="muted" style="margin-top:4px;">Awaiting Head Steward confirmation.</div>
        `;
      }

      // not greenlit:
      const revokedBy = t.simgridRevokedBy ? escapeHtml(t.simgridRevokedBy) : "";
      const revokedAt = t.simgridRevokedAt ? escapeHtml(formatTimestamp(t.simgridRevokedAt)) : "";
      if (revokedBy || revokedAt){
        return `
          <span class="tag bad">Revoked</span>
          <div class="muted" style="margin-top:4px;">By: ${revokedBy || "—"}</div>
          <div class="muted">At: ${revokedAt || "—"}</div>
        `;
      }
      return `<span class="tag neutral">No audit</span><div class="muted" style="margin-top:4px;">Not yet approved.</div>`;
    }

    function renderFiltered(){
      const tbody = $("tbody");
      tbody.innerHTML = "";

      const mode = $("viewMode").value;
      const q = ($("search").value || "").trim();

      // Key rule change:
      // - "Greenlit only" should NOT include submitted/completed tickets
      // - "All finalised" SHOULD include submitted tickets (so you can still see them)
      const filtered = allRows
        .filter(t => isFinalised(t.status))
        .filter(t => {
          if (mode === "greenlit") return (!!t.simgridGreenlit && !t.simgridSubmitted);
          if (mode === "pending") return (!!t.simgridPendingGreenlit && !t.simgridGreenlit && !t.simgridSubmitted);
          // all finalised = show everything, including submitted
          return true;
        })
        .filter(t => matchesSearch(t, q));

      $("countPill").innerHTML = `Tickets: <strong>${filtered.length}</strong>`;
      $("modePill").textContent =
        `Mode: ${
          mode === "all" ? "All finalised" :
          mode === "pending" ? "Pending green light" :
          "Greenlit only"
        }`;

      const permLabel =
        isHeadSteward ? "Head Steward" :
        isSimgridOnly ? "SimGrid" :
        "Read-only";
      $("permPill").textContent = `Permissions: ${permLabel}`;
      $("headHint").textContent = isHeadSteward ? " You can approve/revoke tickets below." : (isSimgridOnly ? " You can publish greenlit tickets to SimGrid." : "");

      $("hint").textContent = `Showing ${filtered.length} ticket(s). (Newest first)`;

      for (const t of filtered){
        const tr = document.createElement("tr");

        const submitted = !!t.simgridSubmitted;
        const green = !!t.simgridGreenlit;
        const pending = !!t.simgridPendingGreenlit && !green;

        // Greenlit column MUST show "Published to SimGrid" after submission
        const greenTag = submitted
          ? `<span class="tag ok">PUBLISHED</span>`
          : (green
              ? `<span class="tag ok">YES</span>`
              : (pending ? `<span class="tag neutral">PENDING</span>` : `<span class="tag bad">NO</span>`));

        const proof = (t.proofUrl || "").trim();
        const proofLink = proof ? `<a href="${escapeHtml(proof)}" target="_blank" rel="noopener">Open</a>` : "—";

        const isBusy = busyIds.has(t.id);

        const canHeadAct = isHeadSteward && !isBusy;
        const canSimgridAct = isSimgridOnly && !isBusy;

        // actions
        let actionHtml = "—";

        // Completed tickets: no actions
        if (!submitted){
          // Head steward actions
          if (isHeadSteward){
            if (green){
              actionHtml = `
                <button class="danger" ${canHeadAct ? "" : "disabled"} data-action="revoke" data-id="${escapeHtml(t.id)}">
                  Revoke
                </button>
              `;
            } else {
              actionHtml = `
                <div class="row" style="gap:8px;">
                  <button class="primary" ${canHeadAct ? "" : "disabled"} data-action="approve" data-id="${escapeHtml(t.id)}">
                    Greenlight
                  </button>
                  ${
                    pending
                      ? `<button ${canHeadAct ? "" : "disabled"} data-action="clearPending" data-id="${escapeHtml(t.id)}">
                           Pending green light
                         </button>`
                      : `<button ${canHeadAct ? "" : "disabled"} data-action="pending" data-id="${escapeHtml(t.id)}">
                           Pending green light
                         </button>`
                  }
                </div>
              `;
            }
          }

          // SimGrid actions (ONLY simgrid users, ONLY when already greenlit)
          if (isSimgridOnly && green){
            actionHtml = `
              <button class="primary" ${canSimgridAct ? "" : "disabled"} data-action="submitSimgrid" data-id="${escapeHtml(t.id)}">
                Published to SimGrid
              </button>
            `;
          }

          if ((isHeadSteward || isSimgridOnly) && isBusy){
            actionHtml += `<div class="muted" style="margin-top:6px;">Updating…</div>`;
          }
        } else {
          if ((isHeadSteward || isSimgridOnly) && isBusy){
            actionHtml += `<div class="muted" style="margin-top:6px;">Updating…</div>`;
          }
        }

        const auditHtml = auditText(t);

        // Status column MUST show "Published to SimGrid" after submission
        const statusText = submitted ? "Published to SimGrid" : (t.status || "");

        tr.innerHTML = `
          <td>${greenTag}</td>
          <td>${actionHtml}</td>
          <td>${auditHtml}</td>

          <td class="mono">${escapeHtml(t.id)}</td>
          <td>${escapeHtml(statusText)}</td>
          <td>${escapeHtml(t.event || "")}</td>
          <td>${escapeHtml(t.competition || "")}</td>
          <td>${escapeHtml(t.accused || "")}</td>
          <td>${escapeHtml(t.reporter || "")}</td>
          <td>${escapeHtml(t.track || "")}</td>
          <td><b>${escapeHtml(ticketPenalty(t))}</b></td>
          <td>${escapeHtml(t.stewardDecision || "")}</td>
          <td>${escapeHtml(formatTimestamp(t.timestamp))}</td>
          <td>${proofLink}</td>
        `;

        tbody.appendChild(tr);
      }

      tbody.querySelectorAll("button[data-action]").forEach(btn => {
        btn.onclick = () => {
          const id = btn.getAttribute("data-id");
          const action = btn.getAttribute("data-action");
          const ticket = allRows.find(x => x.id === id);
          if (!ticket) return;

          // Permissions gate
          if (action === "submitSimgrid"){
            if (!isSimgridOnly) return toast("Read-only account.");
          } else {
            if (!isHeadSteward) return toast("Read-only account.");
          }

          const metaRows = [
            { k: "Ticket", v: `<span class="mono">${escapeHtml(ticket.id)}</span>` },
            { k: "Event", v: escapeHtml(ticket.event || "—") },
            { k: "Competition", v: escapeHtml(ticket.competition || "—") },
            { k: "Accused", v: escapeHtml(ticket.accused || "—") },
            { k: "Reporter", v: escapeHtml(ticket.reporter || "—") },
            { k: "Penalty", v: `<b>${escapeHtml(ticketPenalty(ticket))}</b>` },
            { k: "Status", v: escapeHtml(ticket.status || "—") }
          ];

          if (action === "approve"){
            openModal({
              title: "Greenlight ticket for publishing?",
              subtitle: "Head Steward approval required",
              body: "This will mark the ticket as approved for publishing. You can revoke later if needed.",
              confirmText: "Greenlight",
              confirmStyle: "primary",
              metaRows,
              onConfirm: async () => setGreenlight(id, true)
            });
            return;
          }

          if (action === "pending"){
            openModal({
              title: "Mark as Pending green light?",
              subtitle: "Awaiting Head Steward confirmation",
              body: "This will place the ticket into the 'Pending green light' list until it is greenlit or cleared.",
              confirmText: "Set pending",
              confirmStyle: "primary",
              metaRows,
              onConfirm: async () => setPendingGreenlight(id, true)
            });
            return;
          }

          if (action === "clearPending"){
            openModal({
              title: "Clear Pending green light?",
              subtitle: "Remove from pending list",
              body: "This will remove the pending status (ticket will no longer appear in 'Pending green light' view).",
              confirmText: "Clear pending",
              confirmStyle: "danger",
              metaRows,
              onConfirm: async () => setPendingGreenlight(id, false)
            });
            return;
          }

          if (action === "submitSimgrid"){
            openModal({
              title: "Publish to SimGrid and complete?",
              subtitle: "SimGrid processing action (final step)",
              body: "This will mark the ticket as Published to SimGrid and it will disappear from the Greenlit view (completed). It will still be visible in 'All finalised'.",
              confirmText: "Publish to SimGrid",
              confirmStyle: "primary",
              metaRows,
              onConfirm: async () => setSubmittedToSimgrid(id)
            });
            return;
          }

          // revoke
          openModal({
            title: "Revoke greenlight?",
            subtitle: "This will remove publishing approval",
            body: "This will mark the ticket as NOT greenlit. It will disappear from the 'Greenlit only' view.",
            confirmText: "Revoke",
            confirmStyle: "danger",
            metaRows,
            onConfirm: async () => setGreenlight(id, false)
          });
        };
      });
    }

    async function loadFinalised(){
      try{
        $("tbody").innerHTML = "";
        $("countPill").textContent = "Loading…";
        $("hint").textContent = "Loading tickets…";

        const snap = await db.collection("tickets").limit(500).get();
        const rows = snap.docs.map(d => {
          const x = d.data() || {};
          return {
            id: d.id,
            status: x.status || "",
            event: x.event || "",
            competition: x.competition || "",
            accused: x.accused || "",
            reporter: x.reporter || "",
            track: x.track || "",
            postRaceCode: x.postRaceCode || "",
            ruleBreach: x.ruleBreach || "",
            stewardDecision: x.stewardDecision || "",
            proofUrl: x.proofUrl || "",
            timestamp: x.timestamp || null,

            simgridGreenlit: x.simgridGreenlit === true,
            simgridGreenlitBy: x.simgridGreenlitBy || "",
            simgridGreenlitAt: x.simgridGreenlitAt || null,

            // pending green light
            simgridPendingGreenlit: x.simgridPendingGreenlit === true,
            simgridPendingBy: x.simgridPendingBy || "",
            simgridPendingAt: x.simgridPendingAt || null,

            // submitted to simgrid (completion)
            simgridSubmitted: x.simgridSubmitted === true,
            simgridSubmittedBy: x.simgridSubmittedBy || "",
            simgridSubmittedAt: x.simgridSubmittedAt || null,

            // revoke audit
            simgridRevokedBy: x.simgridRevokedBy || "",
            simgridRevokedAt: x.simgridRevokedAt || null
          };
        });

        // sort by timestamp newest first
        rows.sort((a,b) => timestampMs(b.timestamp) - timestampMs(a.timestamp));

        allRows = rows;
        renderFiltered();
        toast("Loaded ✅");
      }catch(e){
        console.error(e);
        toast("Load failed:\n" + (e?.message || e));
      }
    }

    async function waitForFirebaseReady(maxMs = 8000){
      const start = Date.now();
      while (Date.now() - start < maxMs){
        if (typeof auth !== "undefined" && typeof db !== "undefined" && auth && db) return true;
        await new Promise(r => setTimeout(r, 80));
      }
      return false;
    }

    (async () => {
      const ok = await waitForFirebaseReady();
      if (!ok){
        toast("Firebase not ready.\nCheck firebase-init.js path + console.");
        return;
      }

      auth.onAuthStateChanged(async (user) => {
        try{
          if (!user){ window.location.href = "admin.html"; return; }
          currentEmail = (user.email || "").toLowerCase().trim();

          const adminSnap = await db.collection("admins").doc(currentEmail).get();
          if (!adminSnap.exists){ await auth.signOut(); window.location.href = "admin.html"; return; }

          const data = adminSnap.data() || {};
          roleText = String(data.role || "").toLowerCase();

          isSimgrid = roleText.includes("simgrid");
          isHeadSteward = roleText.includes("head") || data.headsteward === true || data.owner === true;

          // ONLY simgrid users (not head stewards) get the "Publish to SimGrid" action
          isSimgridOnly = isSimgrid && !isHeadSteward;

          // Keep access rules the same: SimGrid OR Head can view.
          if (!isSimgrid && !isHeadSteward){
            toast("Access denied (simgrid only).");
            await auth.signOut();
            window.location.href = "admin.html";
            return;
          }

          const nameGuess = (currentEmail.split("@")[0] || "").replace(/[._-]+/g, " ").trim();
          const niceName = nameGuess ? nameGuess.replace(/\b\w/g, c => c.toUpperCase()) : "Admin";

          if (isHeadSteward){
            $("welcomeLine").textContent = `Welcome, ${niceName}. You can approve/revoke finalised tickets for publishing (or mark them pending).`;
          } else if (isSimgridOnly){
            $("welcomeLine").textContent = `Welcome, ${niceName}. You can publish greenlit tickets to SimGrid to complete them.`;
          } else {
            $("welcomeLine").textContent = `Welcome, ${niceName}. This page shows finalised tickets approved for publishing.`;
          }

          $("who").textContent = `Signed in as: ${currentEmail} | role: ${data.role || "admin"}`;

          const permLabel =
            isHeadSteward ? "Head Steward" :
            isSimgridOnly ? "SimGrid" :
            "Read-only";
          $("permPill").textContent = `Permissions: ${permLabel}`;

          await loadFinalised();
        }catch(e){
          toast("Auth/load error:\n" + (e?.message || e));
        }
      });
    })();
  </script>
</body>
</html>
